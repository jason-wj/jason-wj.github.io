<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(置顶)区块链的未来究竟是什么？</title>
    <url>/articles/e71eb575/</url>
    <content><![CDATA[<p>2021-msg: 全新改版发布，原先弱相关文章均已清理；密码学内容暂不在此处开放；后续会将域名和资源迁至国内，提高访问速度。</p>
<iframe width="100%" height="300" src="//player.bilibili.com/player.html?aid=290076960&bvid=BV13f4y1s7xH&cid=322038660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
  </entry>
  <entry>
    <title>fabric基础-Fabric CA介绍及使用</title>
    <url>/articles/342ca2c8/</url>
    <content><![CDATA[<p>Fabric网络中，身份信息文件、TLS通信文件，都需要有专门的模块来管理。通常测试时，为了方便，我们可以使用Fabric官方提供的<code>crypto</code>工具来快速生成需要到证书等。但真正的生产环境中，必须要有一个中心证书机构同一管理和维护证书，合理的规划CA层级，使得新组织加入时不会影响正在使用的证书，并且具有良好的扩展性。官方提供的<code>Fabric CA</code>本身就是为了解决这个问题而生的，是一个完全独立的模块。随着Fabric网络规模的扩大，CA中心由简单的一两个节点，可能会逐步扩充为一个集群等。作为Fabric的入口，很有必要掌握<code>Fabric CA</code>的一些原理和应用。</p>
<a id="more"></a>

<h2 id="1、Fabric-CA整体架构"><a href="#1、Fabric-CA整体架构" class="headerlink" title="1、Fabric CA整体架构"></a>1、Fabric CA整体架构</h2><img src="/articles/342ca2c8/1.png" class="" title="Fabric架构">
<ol>
<li>Fabric CA根证书服务：建议在正是环境中只存在一个根证书，当然根据具体情况也可以有多个。该证书不用于具体CA证书颁发，具体的颁发行为交由中间CA来处理。该服务重要是用于统一管理中间证书。</li>
<li>Fabric CA中间证书服务：每个中间证书都隶属于根证书，或隶属于其它中间证书，在正式环境中，建议每个组织对应一个中间证书，由该中间证书负责处理该组织的全部节点和成员的证书颁发。</li>
<li>Fabric CA服务器集群：可以把中间证书服务通过HA Proxy实现Fabric CA服务器集群。将流量负载平衡到一个Fabric CA集群成员。各汲取成员生成的证书保存到同一个数据库中，方便查询身份和证书。</li>
<li>Fabric CA客户端：负责登记、注册、销毁证书。</li>
<li>两种方式和CA服务器交互：直接使用CA客户端、通过SDK调用</li>
</ol>
<h3 id="1-1-主要功能"><a href="#1-1-主要功能" class="headerlink" title="1.1 主要功能"></a>1.1 主要功能</h3><ol>
<li>各实体的身份注册和登记</li>
<li>给各实体发放登记证书(ECerts)</li>
<li>给各实体发放交易证书(TCerts)</li>
<li>各颁发证书的更新和销毁</li>
</ol>
<h2 id="2、下载与安装"><a href="#2、下载与安装" class="headerlink" title="2、下载与安装"></a>2、下载与安装</h2><ol>
<li>可直接下载官方相应系统最新编译好的二进制文件，下载入口：<a href="https://github.com/hyperledger/fabric-ca/releases">fabric-ca可执行程序</a> 或者使用源码编译生成可执行程序，源码仓库：<a href="https://github.com/hyperledger/fabric-ca">fabric-ca源码</a><br>二进制程序。</li>
<li>这里建议直接使用官方已编译好的，本文使用的是<code>v1.5.0</code>版本</li>
<li>二进制可执行程序分为两个：<br>服务器端：<code>fabric-ca-server</code>，顾名思义，用于提供CA服务，需要放到指定服务器<br>客户端：<code>fabric-ca-client</code>，用于连接CA服务，可以客户端操作和测试CA服务，放在你想放的地方即可。</li>
<li>为方便操作，建议设置环境变量，这个过程不阐述。</li>
</ol>
<h2 id="3、fabric-ca-server使用"><a href="#3、fabric-ca-server使用" class="headerlink" title="3、fabric-ca-server使用"></a>3、fabric-ca-server使用</h2><h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p>这个过程只是生成启动前的初始化文件，其实下一个步骤<code>启动</code>已经包含了这个过程，根据实际需要可选择是否要跳过该步骤。<br>设置工作主目录，这里有这样一个规则，优先级由上至下：</p>
<ol>
<li>命令行设置<code>-home</code></li>
<li>配置环境变量：<code>FABRIC_CA_SERVER_HOME</code></li>
<li>配置环境变量：<code>FABRIC_CA_HOME</code></li>
<li>配置环境变量：<code>FABRIC_CFG_PATH</code></li>
<li>使用当前二进制所在目录</li>
</ol>
<p>初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-server init -b admin:adminpw --home ./fabric_ca_server</span><br></pre></td></tr></table></figure>
<p><code>-b</code>：设置默认管理员的账户和密码<br><code>--home</code>：设置默认工作目录<br>命令执行后，会有一系列的日志，记录了整个执行过程，这个日志在这里就不贴上来了。<br>执行后，会在工作目录下生成如下文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── IssuerPublicKey                  # 身份混合器会用到（零知识证明）</span><br><span class="line">├── IssuerRevocationPublicKey        # 身份混合器会用到（零知识证明）</span><br><span class="line">├── ca-cert.pem                      # 自签名CA根证书，用于验证其它证书的有效性</span><br><span class="line">├── fabric-ca-server-config.yaml     # CA服务端配置文件，服务启动时会读取这里的配置信息</span><br><span class="line">├── fabric-ca-server.db              # 用于存储注册用户和证书的数据库，这里默认用的是sqlite</span><br><span class="line">└── msp                              # 存放CA中心生成的个人身份的私钥文件，用于生成根证书和其他证书，生成的文件格式为_sk</span><br><span class="line">    └── keystore</span><br><span class="line">        ├── 41a1416624e186b4f5f19ae643c8e2b2493f5175226b49668fb34dfa7cc2bd9e_sk</span><br><span class="line">        ├── IssuerRevocationPrivateKey</span><br><span class="line">        └── IssuerSecretKey</span><br></pre></td></tr></table></figure>
<p>其中，<code>fabric-ca-server-config.yaml</code>涉及到一系列CA服务器的配置属性，需要根据了解逐步去配置，里面官方给每个属性都配有说明。这块如果展开说，篇幅不够的，后续根据需要看是否需要开专门一篇文章来讲解这个配置文件的内容。</p>
<h3 id="3-2-启动"><a href="#3-2-启动" class="headerlink" title="3.2 启动"></a>3.2 启动</h3><p>启动时，会生成一系列检测信息，<code>启动过程本身就包含了初始化过程，如果先前没有初始化，或者没有指定配置文件，则该过程会自动生成新的初始化文件</code>。<br>启动后，默认端口号是：<code>7054</code>，用来监听客户端的请求。要改别的端口号，则前往配置设置。<br>启动命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-server start -b admin:adminpw --home ./fabric_ca_server --cfg.affiliations.allowremove --cfg.identities.allowremove</span><br></pre></td></tr></table></figure>
<p><code>--cfg.affiliations.allowremove</code>：指定允许删除联盟<br><code>--cfg.identities.allowremove</code>：指定允许删除用户</p>
<h3 id="3-3-sqlite-db"><a href="#3-3-sqlite-db" class="headerlink" title="3.3 sqlite db"></a>3.3 sqlite db</h3><p>默认使用的是sqlite数据库，ca server初始化完成后，会生成<code>fabric-ca-server.db</code>，使用navicat打开后，会发现里面总共7张表，分别为：</p>
<ol>
<li><code>affiliations</code>：存储机构组织</li>
<li><code>certificates</code>：客户端登录账号会在此处有一个记录</li>
<li><code>credentials</code>：</li>
<li><code>nonces</code>：</li>
<li><code>properties</code>：</li>
<li><code>revocation_authority_info</code>：</li>
<li><code>users</code>：用户账户</li>
</ol>
<h2 id="4、fabric-ca-client使用"><a href="#4、fabric-ca-client使用" class="headerlink" title="4、fabric-ca-client使用"></a>4、fabric-ca-client使用</h2><ol>
<li><p>这个是ca客户端，主要用来和ca服务器端的交互，主要涉及到以下几个命令：<br><code>register</code>：注册用户身份<br><code>enroll</code>：登记用户身份<br><code>reenroll</code>：重新登记用户身份<br><code>revoke</code>：注销已签发的用户证书<br><code>affiliation list</code>：列举组织关系<br><code>affiliation remove</code>：移除组织关系<br><code>affiliation add</code>：添加组织关系</p>
</li>
<li><p>注：务必先启动ca服务器端</p>
</li>
<li><p>默认启动的ca server，数据库里组织是没什么用的，需要删除掉，然后重新添加一个需要的组织，然后为该组织注册一个账号。这整个操作流程，正好满足ca客户端的基本使用，为此按照这个思路，讲解以下流程</p>
</li>
<li><p>以下操作建议为ca客户端配置一个根目录<code>FABRIC_CA_CLIENT_HOME</code>，取代<code>--home</code>参数</p>
</li>
</ol>
<h3 id="4-1-登记账号"><a href="#4-1-登记账号" class="headerlink" title="4.1 登记账号"></a>4.1 登记账号</h3><p>CA客户端要操作任何内容，都需要先登记相应的账号，这里我们登记管理员账号admin。<br>登记的目的是获取签名证书，这样之后只要用相应账号密码连接ca服务即可操作相应功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client enroll -d --enrollment.profile tls -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<h3 id="4-2-查看现有组织"><a href="#4-2-查看现有组织" class="headerlink" title="4.2 查看现有组织"></a>4.2 查看现有组织</h3><p>可以直观返回当前ca数据库组织关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client  affiliation list -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p>返回默认组织关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">affiliation: .</span><br><span class="line">   affiliation: org2</span><br><span class="line">      affiliation: org2.department1</span><br><span class="line">   affiliation: org1</span><br><span class="line">      affiliation: org1.department1</span><br><span class="line">      affiliation: org1.department2</span><br></pre></td></tr></table></figure>
<h3 id="4-3-删除组织"><a href="#4-3-删除组织" class="headerlink" title="4.3 删除组织"></a>4.3 删除组织</h3><p>需要admin账户拥有删除组织的权限。默认自带的组织并没有什么用，可以逐个删除，比如删除org1组织</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除组织1</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org1 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除组织2</span></span><br><span class="line">./fabric-ca-client  affiliation remove --force org2 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p><code>--force</code>：可以强制删除组织和其子组织</p>
<h3 id="4-4-添加组织"><a href="#4-4-添加组织" class="headerlink" title="4.4 添加组织"></a>4.4 添加组织</h3><p>组织添加有规则限制，比如组织格式为：com.jason.org1，需要先添加组织<code>com</code>，然后添加<code>com.jason</code>，最后添加<code>com.jason.org1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加组织com</span></span><br><span class="line">fabric-ca-client affiliation add com -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加组织com.jason</span></span><br><span class="line">fabric-ca-client affiliation add com.jason -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加组织com.jason.org1</span></span><br><span class="line">fabric-ca-client affiliation add com.jason.org1 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加组织com.jason.org2</span></span><br><span class="line">fabric-ca-client affiliation add com.jason.org2 -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp</span><br></pre></td></tr></table></figure>
<p>通过查看可知，当前ca数据库中，组织关系为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">affiliation: com</span><br><span class="line">   affiliation: com.jason</span><br><span class="line">      affiliation: com.jason.org1</span><br><span class="line">      affiliation: com.jason.org2</span><br></pre></td></tr></table></figure>
<h3 id="4-5-为指定组织添加证书"><a href="#4-5-为指定组织添加证书" class="headerlink" title="4.5 为指定组织添加证书"></a>4.5 为指定组织添加证书</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fabric-ca-client getcainfo -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/organizations/msp</span><br></pre></td></tr></table></figure>
<h3 id="4-6-注册用户身份"><a href="#4-6-注册用户身份" class="headerlink" title="4.6 注册用户身份"></a>4.6 注册用户身份</h3><p>需要记住的是，注册完成之后，要及时登记(enroll)，否则该账号依旧无法做任何操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注册</span></span><br><span class="line">./fabric-ca-client register -u http://admin:adminpw@localhost:7054 --id.name orderer.jason.com --id.type orderer --id.affiliation &quot;com.jason&quot; --id.attrs &#x27;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&#x27; --id.secret=123456 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登记</span></span><br><span class="line">./fabric-ca-client enroll -d --enrollment.profile tls -u http://orderer.jason.com:123456@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/peerOrganizations/msp </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-7-重新登记用户身份"><a href="#4-7-重新登记用户身份" class="headerlink" title="4.7 重新登记用户身份"></a>4.7 重新登记用户身份</h3><p>比如证书快到期了，或者想要更换证书，则重新登记</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client reenroll -d --enrollment.profile tls -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<h3 id="4-8-注销已签发的证书"><a href="#4-8-注销已签发的证书" class="headerlink" title="4.8 注销已签发的证书"></a>4.8 注销已签发的证书</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fabric-ca-client revoke -e &quot;orderer.jason.com&quot; -r &quot;注销原因：xxxx&quot; -u http://admin:adminpw@localhost:7054 --home ./fabric_ca_client  -M ./crypto_config/ordererOrganizations/msp </span><br></pre></td></tr></table></figure>
<p><code>-e</code>：用户账号<br><code>-r</code>：注销原因</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了CA服务端和客户端的操作以及执行原理</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
        <category>Fabric基础</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS基础-高级操作</title>
    <url>/articles/6ebd6fe7/</url>
    <content><![CDATA[<p>本文主要讲IPFS的一些高级应用，虽说高级，但依旧属于IPFS基础中尽可能掌握的内容。主要讲解IPFS网络中如何持久保存数据、如何发布消息、命名空间怎样使用等。</p>
<a id="more"></a>

<h2 id="IPFS中发布动态内容"><a href="#IPFS中发布动态内容" class="headerlink" title="IPFS中发布动态内容"></a>IPFS中发布动态内容</h2><p>从IPFS原理可知，每上传一个文件，都有唯一的一个地址指向这个文件，假如我发布了一篇博客，此时得到一个地址<code>A</code>，如果我对博客内容做了一点改动，重新发布后，得到的地址变为了<code>B</code>， 这样会对博客浏览者造成很大困惑，无法通过一个稳定的地址来访问我的这篇博客。针对此类问题，IPFS推出了一个新的技术，叫<code>IPNS（星际文件命名系统）</code>，其实这技术也不算新了，很多年前就已经推出了。 使用该技术，会为一个文件提供一个稳定的命名空间或者叫地址（姑且这么理解），无论文件改变多少次，该地址始终都会指向最新改动后的文件。也就是说，无论我的博客修改并发布多少次，<code>IPNS</code>的地址始终指向我最后一次修改后的博客。</p>
<h3 id="先新建一个文件，并上传到IPFS"><a href="#先新建一个文件，并上传到IPFS" class="headerlink" title="先新建一个文件，并上传到IPFS"></a>先新建一个文件，并上传到IPFS</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason&quot; &gt; test.txt</span><br><span class="line">ipfs add test.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</span><br></pre></td></tr></table></figure>
<h3 id="通过RSA公钥绑定文件内容"><a href="#通过RSA公钥绑定文件内容" class="headerlink" title="通过RSA公钥绑定文件内容"></a>通过RSA公钥绑定文件内容</h3><ol>
<li>查看当前IPFS节点的所有公钥<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs key list -l</span><br></pre></td></tr></table></figure>
输出结果：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0 self </span><br></pre></td></tr></table></figure>
表示当前IPFS节点只有一个公钥key，且其别名为<code>self</code>，表示属于节点ID的，就是说该公钥唯一对应到IPFS的节点ID</li>
<li>创建新的RSA公钥<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs key gen --type=rsa --size=2048 newkey</span><br></pre></td></tr></table></figure>
生成新的公钥：<code>k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1</code><br>也就是说，此时该IPFS节点有两个公钥了，用上面的命令<code>ipfs key list -l</code>查看:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0 self   </span><br><span class="line">k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1       newkey</span><br></pre></td></tr></table></figure>
发现新加了一个公钥匙，对应别称为<code>newkey</code></li>
<li>将文件CID挂载到<code>newkey</code>的公钥地址上<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs name publish --key=newkey QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
输出结果：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Published to k2k4r8pp1pt90mojqe0xgerxyjum439xhob526rvmhd5iambe7ri60f1: /ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
输出表明已经将文件CID关联到指定公钥了，即绑定了固定的一个地址，也就是IPNS地址</li>
<li>浏览器访问：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/ipns/k51qzi5uqu5dmd05ublqz4hxj2iuyy888cihg06pzda9lm4qghxnwrnwywaup0</span><br></pre></td></tr></table></figure></li>
<li>以后每次改动文件后，重复执行上面的步骤，最终都可以用同一个公钥来访问这个文件最新状态，其实也就是，每次公钥绑定了哪个CID，就能通过公钥(IPNS)在浏览器中看到对应CID的文件内容</li>
</ol>
<h3 id="通过当前节点绑定文件内容"><a href="#通过当前节点绑定文件内容" class="headerlink" title="通过当前节点绑定文件内容"></a>通过当前节点绑定文件内容</h3><p>看了上面的内容，其实很容易理解这个节点绑定文件内容的逻辑，也就是说<code>ipfs name publish</code>的时候，不要指定<code>--key</code>，则会默认将CID绑定到节点的<code>self</code>的公钥上，这个公钥本来就是关联节点ID的，因此文件就直接和节点绑定了，这样的坏处是，整个节点只能指向一个文件，很不灵活，因此一般不会在生产环境中使用这种方式。这里就不详细说明了（没啥好讲的，都是同一回事）。</p>
<h2 id="持久保存IPFS网络数据"><a href="#持久保存IPFS网络数据" class="headerlink" title="持久保存IPFS网络数据"></a>持久保存IPFS网络数据</h2><p>如果文件存储在别人的IPFS节点上，直接在自己节点<code>ipfs cat 文件</code>，虽然能够读取到远程节点的这个文件，但这个文件只会临时缓存到自己的节点上，一段时间后，自己节点的缓存机制（<code>手动命令：ipfs repo gc</code>）会自动将这个文件给删除掉，造成下次从自己节点再次读取该文件的时，还得重新缓存的问题，严重影响了体验。<br>为此，需要一个方式，能够永久保留下从远程节点读取到的文件。这里需要用到的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin add QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>如此可以将远程文件永久保存在自己节点上</p>
<h3 id="查看当前节点有哪些永久保存的文件和目录"><a href="#查看当前节点有哪些永久保存的文件和目录" class="headerlink" title="查看当前节点有哪些永久保存的文件和目录"></a>查看当前节点有哪些永久保存的文件和目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin ls --type=all</span><br></pre></td></tr></table></figure>
<h3 id="资源手动回收"><a href="#资源手动回收" class="headerlink" title="资源手动回收"></a>资源手动回收</h3><p>也就是手动清除缓存，释放资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs repo gc</span><br></pre></td></tr></table></figure>
<h3 id="强制删除本地的某个文件目录及其子文件"><a href="#强制删除本地的某个文件目录及其子文件" class="headerlink" title="强制删除本地的某个文件目录及其子文件"></a>强制删除本地的某个文件目录及其子文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pin rm -r QmejvEPop4D7YUadeGqYWmZxHhLc4JBUCzJJHWMzdcMe2y</span><br></pre></td></tr></table></figure>
<h2 id="操作IPFS-Merkle-DAG"><a href="#操作IPFS-Merkle-DAG" class="headerlink" title="操作IPFS Merkle DAG"></a>操作IPFS Merkle DAG</h2><p>IPFS的两个核心概念：默克尔树（Merkle）和有向无环图（DAG）。数据的存储结构大部分是Merkle DAG形式构成。理论部分不在这里介绍，本文主要介绍Merkle DAG的操作。<br>之所以介绍，是因为在操作<code>分布式数据库</code>、<code>分布式版本控制软件</code>时，非常重要。 更通俗的说，就是操作一个文件的子块数据时，是需要掌握这部分内容的<br>关于块和对象的裂变理论部分，本文不作详述。只要记着：<code>Block超过256Kb，就会生成新的Block；Object的Links数量超过174个，就会生成新的Object</code></p>
<h3 id="创建Merkle-DAG结构"><a href="#创建Merkle-DAG结构" class="headerlink" title="创建Merkle DAG结构"></a>创建Merkle DAG结构</h3><p>通过<code>ipfs add</code>上传的文件，本身就是为文件创建Merkle DAG对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs add test.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmWJgfUvpjNN7ycjYac86kogRPmS1Bj33gH2LRMA9dPW1j test.txt</span><br></pre></td></tr></table></figure>
<p>查看结构信息和子对象信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object links -v QmWJgfUvpjNN7ycjYac86kogRPmS1Bj33gH2LRMA9dPW1j</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hash                                           Size   Name</span><br><span class="line">QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP 262158 </span><br><span class="line">QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV 19869 </span><br></pre></td></tr></table></figure>
<p>可以看出有两个地址来管理这个<code>test.txt</code>文件，第一个地址：<code>QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</code>对应文件的256kb文件块，另一个地址：<code>QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV</code>对应文件的剩余大小。也就是说，一个文件是按照256kb来切分文件块的。<br>使用如下命令即可查看每个子块的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br><span class="line">ipfs cat QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV</span><br></pre></td></tr></table></figure>
<h3 id="组装子块数据"><a href="#组装子块数据" class="headerlink" title="组装子块数据"></a>组装子块数据</h3><p>该命令可以将文件的指定子块合并成一个新文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP QmVp79sgyHbzvpF8cdB7pmpbBYEkNoKUEBajTzpv9HhdqV &gt; test2.txt</span><br></pre></td></tr></table></figure>
<p>这是Merkle DAG的一种应用。该应用同时也可以用于身份校验，比如某两个子块合并后校验权限A，某三个子块合并后校验权限B，这个扩展应用根据需要灵活考虑。</p>
<h3 id="块和对象的区别"><a href="#块和对象的区别" class="headerlink" title="块和对象的区别"></a>块和对象的区别</h3><ol>
<li>块：代表的是文件分割后的一部分，可以通过如下命令查看块信息，只有hash和对应的大小：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block stat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br></pre></td></tr></table></figure>
输出结果：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Key: QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br><span class="line">Size: 262158</span><br></pre></td></tr></table></figure></li>
<li>对象：一般代表的是在IPFS中存储的一个完整文件，当然，块也可以理解是一个对象。查看信息，比如块hash用如下命令查看：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object stat QmZCxwMMGar8RDc4ckezyL1uNS2ACKKyUvh6kDc6g2urHP</span><br></pre></td></tr></table></figure>
输出结果：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NumLinks:       0</span><br><span class="line">BlockSize:      262158</span><br><span class="line">LinksSize:      4      # 链接本身也是有容量等</span><br><span class="line">DataSize:       262154 </span><br><span class="line">CumulativeSize: 262158</span><br></pre></td></tr></table></figure>
可以看出输出结果明显比用块查看多出很多信息，入链接数、块大小、对象大小等</li>
</ol>
<h3 id="操作Block"><a href="#操作Block" class="headerlink" title="操作Block"></a>操作Block</h3><p>对于小的文件(小于256Kb)，可以直接使用block来操作，能够提高处理效率。</p>
<ol>
<li><p>block存储小数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason block&quot; | ipfs block put</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure></li>
<li><p>block读取小数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block get QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason block</span><br></pre></td></tr></table></figure></li>
<li><p>查看block信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block stat QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Key: QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br><span class="line">Size: 18</span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs block rm QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">removed QmQbQ6mZ79dj7VSXUZWDfLavVvwEYkRrhbpELMDP3J4CtY</span><br></pre></td></tr></table></figure>
<h3 id="操作Object"><a href="#操作Object" class="headerlink" title="操作Object"></a>操作Object</h3></li>
<li><p>创建IPFS DAG对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason object&quot; | ipfs add</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43 QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure></li>
<li><p>返回对象数据，输出JSON格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object get QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&quot;Links&quot;:[],&quot;Data&quot;:&quot;\u0008\u0002\u0012\u0013hello jason object\n\u0018\u0013&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出返回两个字段：Links子块链接和Data数据</p>
</li>
<li><p>返回解码后的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object data QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason object</span><br></pre></td></tr></table></figure></li>
<li><p>为已有数据追加新数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;patch info&quot; &gt; ./patch.txt</span><br><span class="line">ipfs object patch append-data QmZU1y9z8WxQJLAxQHrqFDrQsmLrLYuHiCfMYhbLFP8S43 ./patch.txt</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QmfDtGvBafCPCoR6hNetXAgBZ2kg4Y2CPpfHL2RRGU38z2</span><br></pre></td></tr></table></figure></li>
<li><p>解析新内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs object data QmfDtGvBafCPCoR6hNetXAgBZ2kg4Y2CPpfHL2RRGU38z2</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello jason object</span><br><span class="line">patch info</span><br></pre></td></tr></table></figure>
<h2 id="IPFS消息发布"><a href="#IPFS消息发布" class="headerlink" title="IPFS消息发布"></a>IPFS消息发布</h2><p>该功能当前属于实验功能(<code>记忆从0.4版本到今天0.8版本这个功能一直处于实验阶段</code>)，需要在启动IPFS节点的时候，带入如下参数，开启消息功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon --enable-pubsub-experiment</span><br></pre></td></tr></table></figure>
<h3 id="相关主要命令"><a href="#相关主要命令" class="headerlink" title="相关主要命令"></a>相关主要命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本节点订阅的全部主题</span></span><br><span class="line">ipfs pubsub ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出与本节点相连接的开通pubsub功能的节点</span></span><br><span class="line">ipfs pubsub peers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布数据到相应的主题</span></span><br><span class="line">ipfs pubsub pub &lt;topic&gt;&lt;data&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 订阅主题</span></span><br><span class="line">ipfs pubsub sub &lt;topic&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>多节点模拟主题发布与订阅，需先确保各个节点的私有环境，排除外界其余关联节点的干扰。比如A、B两个节点，将B节点关联到A节点</p>
</li>
<li><p>在A节点订阅主题<code>topic-A</code>，如此凡是发往这个这个主题的消息，都会被A接收</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pubsub sub topic-A</span><br></pre></td></tr></table></figure>
<p>此时A处于接收状态</p>
</li>
<li><p>在B节点对主题<code>topic-A</code>发布消息<code>Hello Jason</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs pubsub pub topic-A &quot;Hello Jason&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>此时A节点收到B节点发来的信息：<code>Hello Jason</code></p>
</li>
<li><p>扩展：消息可以通过中间节点转发：A-&gt;C-&gt;B，就是说即使C不订阅任何主题，只要B订阅了A的主题，依旧能经过C来接收到</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>可以用于及时通信</li>
<li>可用于分布式数据库</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文综合介绍了IPFS的一些高级操作，能够更深的了解一些IPFS的应用层的技术逻辑，对后续业务层应用会起到一定的帮助。</p>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS主要命令汇总</title>
    <url>/articles/5ce15195/</url>
    <content><![CDATA[<p>本文主要是汇总一些IPFS常用的命令，方便查询。</p>
<a id="more"></a>

<h2 id="配置IPFS存储目录"><a href="#配置IPFS存储目录" class="headerlink" title="配置IPFS存储目录"></a>配置IPFS存储目录</h2><p>设置IPFS_PATH环境命令，默认值为：~/.ipfs</p>
<h2 id="根命令"><a href="#根命令" class="headerlink" title="根命令"></a>根命令</h2><table>
<thead>
<tr>
<th>选项标识</th>
<th>选项类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>-c,-config</td>
<td>string</td>
<td>指定配置文件所在路径</td>
</tr>
<tr>
<td>-D,-debug</td>
<td>bool</td>
<td>以debug模式操作，缺省为false</td>
</tr>
<tr>
<td>-help</td>
<td>bool</td>
<td>展示完整的命令帮助文档，缺省为false</td>
</tr>
<tr>
<td>-h</td>
<td>bool</td>
<td>展示精简命令帮助文档，缺省为false</td>
</tr>
<tr>
<td>-L,-local</td>
<td>bool</td>
<td>在本地运行命令，缺省为false</td>
</tr>
<tr>
<td>-api</td>
<td>string</td>
<td>使用具体的API实例（缺省为/ip4/127.0.0.1/tcp/5001）</td>
</tr>
</tbody></table>
<h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>init</td>
<td>初始化IPFS本地配置</td>
</tr>
<tr>
<td>add(path)</td>
<td>添加一个文件到IPFS</td>
</tr>
<tr>
<td>cat(ref)</td>
<td>展示IPFS对象数据</td>
</tr>
<tr>
<td>get(ref)</td>
<td>下载IPFS对象</td>
</tr>
<tr>
<td>ls(ref)</td>
<td>从一个对象中列出链接</td>
</tr>
<tr>
<td>Refs(ref)</td>
<td>从一个对象中列出链接哈希</td>
</tr>
</tbody></table>
<h3 id="IPFS数据结构命令"><a href="#IPFS数据结构命令" class="headerlink" title="IPFS数据结构命令"></a>IPFS数据结构命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>block</td>
<td>与数据存储中的原始块交互</td>
</tr>
<tr>
<td>object</td>
<td>与原始DAG节点交互</td>
</tr>
<tr>
<td>fils</td>
<td>将对象抽象为UNIX文件系统，并与对象交互</td>
</tr>
<tr>
<td>dag</td>
<td>与IPLD文件交互（<code>是否已上线？</code>）</td>
</tr>
</tbody></table>
<h3 id="IPFS高级命令"><a href="#IPFS高级命令" class="headerlink" title="IPFS高级命令"></a>IPFS高级命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>daemon</td>
<td>开启IPFS运行后台进程</td>
</tr>
<tr>
<td>mount</td>
<td>挂载一个IPFS只读的挂载点</td>
</tr>
<tr>
<td>resolve</td>
<td>解析多类型CID名称</td>
</tr>
<tr>
<td>name</td>
<td>发布并解析IPNS名字</td>
</tr>
<tr>
<td>key</td>
<td>发布并列出IPNS名字密钥对</td>
</tr>
<tr>
<td>dns</td>
<td>解析DNS链接</td>
</tr>
<tr>
<td>pin</td>
<td>将对象锁定到本地存储</td>
</tr>
<tr>
<td>repo</td>
<td>操作IPFS仓库</td>
</tr>
<tr>
<td>stats</td>
<td>各种操作状态</td>
</tr>
<tr>
<td>filestore</td>
<td>管理文件仓库(实验中)</td>
</tr>
</tbody></table>
<h3 id="IPFS网络通信命令表"><a href="#IPFS网络通信命令表" class="headerlink" title="IPFS网络通信命令表"></a>IPFS网络通信命令表</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>展示IPFS节点信息</td>
</tr>
<tr>
<td>bootstrap</td>
<td>添加或删除引导节点</td>
</tr>
<tr>
<td>swarm</td>
<td>管理P2P网络链接</td>
</tr>
<tr>
<td>dht</td>
<td>请求有关值或节点的分布式哈希表</td>
</tr>
<tr>
<td>ping</td>
<td>测量一个连接的延迟</td>
</tr>
<tr>
<td>diag</td>
<td>打印诊断信息</td>
</tr>
</tbody></table>
<h3 id="IPFS工具命令命令"><a href="#IPFS工具命令命令" class="headerlink" title="IPFS工具命令命令"></a>IPFS工具命令命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>config</td>
<td>管理配置</td>
</tr>
<tr>
<td>version</td>
<td>展示IPFS版本信息</td>
</tr>
<tr>
<td>update</td>
<td>下载并应用go-ipfs更新</td>
</tr>
<tr>
<td>commands</td>
<td>列出所有可用命令</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS基础-基础操作</title>
    <url>/articles/600687bc/</url>
    <content><![CDATA[<p>本文主要是综合的介绍IPFS的命令行使用方式，掌握对文件的基本操作，同时从整体上对IPFS有一个初步的了解。</p>
<a id="more"></a>

<h2 id="IPFS初始化"><a href="#IPFS初始化" class="headerlink" title="IPFS初始化"></a>IPFS初始化</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首次使用IPFS时，需要执行该命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化IPFS仓库，会在~/.ipfs目录中生成初始化文件，</span></span><br><span class="line">ipfs init</span><br></pre></td></tr></table></figure>
<p>该命令执行后，会被周围的公共节点发现该节点，如果不想被发现，或者在私有服务器使用IPFS，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs init --profile server</span><br></pre></td></tr></table></figure>
<h3 id="初始化文件说明"><a href="#初始化文件说明" class="headerlink" title="初始化文件说明"></a>初始化文件说明</h3><p>在<code>~/.ipfs</code>中，会生成如下几个文件：</p>
<ol>
<li><code>blocks</code>：本地仓库存储的CID文件块链接目录</li>
<li><code>keystore</code>：密钥对文件存储目录</li>
<li><code>datastore</code>：LevelDB数据文件目录</li>
<li><code>config</code>：配置文件(非目录),json格式</li>
<li><code>version</code>：文件，记录当前IPFS的版本号</li>
</ol>
<h3 id="IPFS存储文件目录设置"><a href="#IPFS存储文件目录设置" class="headerlink" title="IPFS存储文件目录设置"></a>IPFS存储文件目录设置</h3><p>在环境变量中，设置<code>$IPFS_PATH</code>，docker镜像的默认地址设置为了：<code>/data/ipfs/</code>，其余默认一般为：<code>~/.ipfs</code></p>
<h3 id="config配置文件说明"><a href="#config配置文件说明" class="headerlink" title="config配置文件说明"></a>config配置文件说明</h3><p>配置文件无疑是当前最关心的内容，后续可根据需要来调整配置，具体内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;API&quot;</span>: &#123;   <span class="comment">//节点API配置</span></span><br><span class="line">    <span class="attr">&quot;HTTPHeaders&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Addresses&quot;</span>: &#123;   <span class="comment">//节点网络通信multiaddress配置</span></span><br><span class="line">    <span class="attr">&quot;API&quot;</span>: <span class="string">&quot;/ip4/0.0.0.0/tcp/5001&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Announce&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;/ip4/0.0.0.0/tcp/8080&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;NoAnnounce&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;Swarm&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;/ip4/0.0.0.0/tcp/4001&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/ip6/::/tcp/4001&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/ip4/0.0.0.0/udp/4001/quic&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/ip6/::/udp/4001/quic&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;AutoNAT&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;Bootstrap&quot;</span>: [   <span class="comment">//中继节点multiaddress配置</span></span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/ip4/104.131.131.82/udp/4001/quic/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;Datastore&quot;</span>: &#123;  <span class="comment">//存储配置</span></span><br><span class="line">    <span class="attr">&quot;BloomFilterSize&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;GCPeriod&quot;</span>: <span class="string">&quot;1h&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;HashOnRead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Spec&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;mounts&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;child&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;blocks&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;shardFunc&quot;</span>: <span class="string">&quot;/repo/flatfs/shard/v1/next-to-last/2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;sync&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;flatfs&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;mountpoint&quot;</span>: <span class="string">&quot;/blocks&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;prefix&quot;</span>: <span class="string">&quot;flatfs.datastore&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;measure&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;child&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;compression&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;datastore&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;levelds&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;mountpoint&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;prefix&quot;</span>: <span class="string">&quot;leveldb.datastore&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;measure&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mount&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;StorageGCWatermark&quot;</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="attr">&quot;StorageMax&quot;</span>: <span class="string">&quot;10GB&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Discovery&quot;</span>: &#123;  <span class="comment">//LibP2P Discovery配置</span></span><br><span class="line">    <span class="attr">&quot;MDNS&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;Interval&quot;</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Experimental&quot;</span>: &#123;   <span class="comment">//实验功能开关配置</span></span><br><span class="line">    <span class="attr">&quot;FilestoreEnabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;GraphsyncEnabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Libp2pStreamMounting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;P2pHttpProxy&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;ShardingEnabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;StrategicProviding&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;UrlstoreEnabled&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Gateway&quot;</span>: &#123;   <span class="comment">//HTTP 网关配置</span></span><br><span class="line">    <span class="attr">&quot;APICommands&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;HTTPHeaders&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Headers&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;X-Requested-With&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Range&quot;</span>,</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Methods&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;GET&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;Access-Control-Allow-Origin&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;NoDNSLink&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;NoFetch&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;PathPrefixes&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;PublicGateways&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;RootRedirect&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Writable&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Identity&quot;</span>: &#123;  <span class="comment">//节点身份信息</span></span><br><span class="line">    <span class="attr">&quot;PeerID&quot;</span>: <span class="string">&quot;12D3KooWSVzdPE1nXHAh9CyqAayFA8psJ9n6DwTkByiD8gWnm9b1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;PrivKey&quot;</span>: <span class="string">&quot;CAESQMQL3NrWkdjsQ++yxdWvlnCSaltDpYTKRA4+CRZhibgQ9+Hd9lslOXRd0pF4dqCtOIMHMpgtbTVaqba5bfOqYeQ=&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Ipns&quot;</span>: &#123;   <span class="comment">//Ipns配置</span></span><br><span class="line">    <span class="attr">&quot;RecordLifetime&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;RepublishPeriod&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ResolveCacheSize&quot;</span>: <span class="number">128</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span>: &#123;  <span class="comment">//文件系统挂载配置</span></span><br><span class="line">    <span class="attr">&quot;FuseAllowOther&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;IPFS&quot;</span>: <span class="string">&quot;/ipfs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;IPNS&quot;</span>: <span class="string">&quot;/ipns&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Peering&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Peers&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Pinning&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;RemoteServices&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Plugins&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Plugins&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Provider&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Strategy&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Pubsub&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DisableSigning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Router&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Reprovider&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Interval&quot;</span>: <span class="string">&quot;12h&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Strategy&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Routing&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;dht&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Swarm&quot;</span>: &#123;  <span class="comment">//P2P Swarm配置</span></span><br><span class="line">    <span class="attr">&quot;AddrFilters&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;ConnMgr&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;GracePeriod&quot;</span>: <span class="string">&quot;20s&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;HighWater&quot;</span>: <span class="number">900</span>,</span><br><span class="line">      <span class="attr">&quot;LowWater&quot;</span>: <span class="number">600</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;basic&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DisableBandwidthMetrics&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;DisableNatPortMap&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;EnableAutoRelay&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;EnableRelayHop&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Transports&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Multiplexers&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">&quot;Network&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">&quot;Security&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加入IPFS网络环境"><a href="#加入IPFS网络环境" class="headerlink" title="加入IPFS网络环境"></a>加入IPFS网络环境</h2><h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon</span><br></pre></td></tr></table></figure>
<p>通过该命令，可以将本机的IPFS连接到公网的IPFS网络，同时启动了HTTP网关服务，方便后续HTTP WEB交互</p>
<h3 id="查看对等方IPFS节点信息"><a href="#查看对等方IPFS节点信息" class="headerlink" title="查看对等方IPFS节点信息"></a>查看对等方IPFS节点信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs swarm peers</span><br></pre></td></tr></table></figure>
<p>执行后，可以看到有大量节点地址</p>
<h2 id="与IPFS进行交互"><a href="#与IPFS进行交互" class="headerlink" title="与IPFS进行交互"></a>与IPFS进行交互</h2><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello jason&quot; &gt; test.txt</span><br><span class="line">ipfs add test.txt </span><br></pre></td></tr></table></figure>
<p>此时控制台返回结果：<code>added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</code><br>表示<code>test.txt</code>文件在IPFS的hash地址(CID)为：<code>QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</code></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>读出的内容和<code>test.txt</code>中完全一致：<code>hello jason</code></p>
<h3 id="验证内容唯一性"><a href="#验证内容唯一性" class="headerlink" title="验证内容唯一性"></a>验证内容唯一性</h3><p>只要文件内容不变，则CID不变</p>
<h3 id="写入文件的名称和目录信息"><a href="#写入文件的名称和目录信息" class="headerlink" title="写入文件的名称和目录信息"></a>写入文件的名称和目录信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs add -w test.txt</span><br></pre></td></tr></table></figure>
<p>返回两个<code>CID</code>，具体输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">added QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP test.txt</span><br><span class="line">added QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT </span><br></pre></td></tr></table></figure>
<p>其中第一条问文件内容的CID；第二条指向的是一个目录（即 <code>IPFS Wrapped</code>），记录了文件内容的文件内容的CID、文件名、文件大小、</p>
<h3 id="读取IPFS-Wrapped获取文件信息"><a href="#读取IPFS-Wrapped获取文件信息" class="headerlink" title="读取IPFS Wrapped获取文件信息"></a>读取IPFS Wrapped获取文件信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs ls -v QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hash                                           Size Name</span><br><span class="line">QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP 12   test.txt</span><br></pre></td></tr></table></figure>
<p><code>IPFS Wrapped</code>的CID为目录，因此只能用<code>ls</code>命令，不能用<code>cat</code>命令，<code>-v</code>是将字段描述展示出来。</p>
<h3 id="通过父目录来获取文件内容"><a href="#通过父目录来获取文件内容" class="headerlink" title="通过父目录来获取文件内容"></a>通过父目录来获取文件内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs cat QmY8utLB2d9KKpjaR3mhTngqYc1grAZDnTaXgMfMzUsXGT/test.txt</span><br></pre></td></tr></table></figure>
<p>地址就是那个<code>IPFS Wrapped</code>的CID</p>
<h3 id="查看哪些节点存储了指定文件"><a href="#查看哪些节点存储了指定文件" class="headerlink" title="查看哪些节点存储了指定文件"></a>查看哪些节点存储了指定文件</h3><p>这里通过<code>test.txt</code>的CID来查看有哪些节点存储了这个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs dht findprovs QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">12D3KooWSVzdPE1nXHAh9CyqAayFA8psJ9n6DwTkByiD8gWnm9b1</span><br></pre></td></tr></table></figure>
<p>可以看出，输出的是本机的节点地址，也就是当前只有本机节点存储了这个文件</p>
<h2 id="与HTTP-Web交互"><a href="#与HTTP-Web交互" class="headerlink" title="与HTTP Web交互"></a>与HTTP Web交互</h2><h3 id="前提要求"><a href="#前提要求" class="headerlink" title="前提要求"></a>前提要求</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一定要先启动守护进程</span></span><br><span class="line">ipfs daemon</span><br></pre></td></tr></table></figure>
<h3 id="从本地HTTP网关中获取IPFS数据"><a href="#从本地HTTP网关中获取IPFS数据" class="headerlink" title="从本地HTTP网关中获取IPFS数据"></a>从本地HTTP网关中获取IPFS数据</h3><p>在浏览器地址中输入如下内容，地址可以是localhost，也可以是远端的指定地址。默认是8080端口为web端口，我用的是自己的docker镜像，将端口映射为了8081</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>页面输出的就是<code>test.txt</code>的内容：<code>hello jason</code></p>
<h3 id="从公共HTTP网关获取IPFS数据"><a href="#从公共HTTP网关获取IPFS数据" class="headerlink" title="从公共HTTP网关获取IPFS数据"></a>从公共HTTP网关获取IPFS数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://ipfs.io/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br><span class="line">http://ipfs.infura.io/ipfs/QmcMR7dqXvUxgCXpwmKHyeu4mbwGAfvd5zoa7fY4UYmtPP</span><br></pre></td></tr></table></figure>
<p>基于IPFS的特点，既然我的IPFS节点已经和公共网络的连接上了，那在别的公共节点上，也应该能通过CID读取到我的<code>test.txt</code>内容，也就是说，以上两个链接也能访问到<code>test.txt</code>的内容。</p>
<h3 id="IPFS-Web控制台"><a href="#IPFS-Web控制台" class="headerlink" title="IPFS Web控制台"></a>IPFS Web控制台</h3><p>IPFS自带一个web控制台，界面很简单，能够满足基础操作，端口号默认为<code>5001</code>，具体如下浏览器访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:5001/webui</span><br></pre></td></tr></table></figure>
<p>在启动<code>ipfs daemon</code>的情况下，默认的IPFS是无法远程访问web控制台的，或者不允许跨域请求，因此需要在节点上配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin &#x27;[&quot;http://xx.xx.xx.xx:5001&quot;, &quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:5001&quot;, &quot;https://webui.ipfs.io&quot;]&#x27;</span><br><span class="line">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods &#x27;[&quot;PUT&quot;, &quot;POST&quot;]&#x27;</span><br></pre></td></tr></table></figure>
<p>具体IP和端口号需要自己根据实际情况调整。<br>若依旧无法访问，检查下自己的接口是不是被防火墙拦截了，以下是我启动后的一张图示：</p>
<img src="/articles/600687bc/1.jpg" class="" title="IPFS Web控制台">
<img src="/articles/600687bc/2.jpg" class="" title="已存储文件">

<h2 id="在线调试工具"><a href="#在线调试工具" class="headerlink" title="在线调试工具"></a>在线调试工具</h2><p>ipfs官方提供了一个线上环境，不用部署IPFS即可操作相关命令，线上环境地址：<code>https://ipfs.docs.apiary.io</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只讲了IPFS的基础命令，而IPFS还有大量高级命令，需要自己根据官方文档逐步去了解。相信在此处，对IPFS的应用已经有了一定的基础。</p>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS开篇-简单部署和私有环境部署</title>
    <url>/articles/25678954/</url>
    <content><![CDATA[<p>2018年也曾有一段时间在研究IPFS并在项目中应用，也写了一篇类似文章：<a href="/articles/7987f3ac/index.html">ipfs私有环境搭建</a>，一晃眼已经3年了，<br>兜兜转转，我又重新拿起了IPFS，因为这三年的经历以及现在所处的工作环境让我明白，它的价值是毋庸置疑的。现在的IPFS也非曾经的IPFS，很有必要在重新掌握一遍。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IPFS的安装有多种方式，早前我<a href="/articles/7987f3ac/index.html">ipfs私有环境搭建</a>文中是通过docker来安装部署的，今天在测试环境下，为了确保环境干净，我依旧选择docker，<br>但不同的是，这次选择使用<code>docker</code>+<code>docker-compose</code>方式，尽可能简化安装过程，毕竟，我的目的是要了解其内部具体工作流程，不要把太多精力花在安装部署上。<br>因此，首先确保你的环境安装有docker和docker-compose</p>
<h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><h3 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jason-wj/docker_bash.git</span><br><span class="line">cd docker_bash</span><br></pre></td></tr></table></figure>
<p>我将常用的一些docker镜像都集成到上面的脚本中了，下载后，有兴趣可以看看，在这里主要就是关注IPFS在docker-compose.yml中的编排</p>
<h3 id="启动IPFS容器"><a href="#启动IPFS容器" class="headerlink" title="启动IPFS容器"></a>启动IPFS容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh start ipfs</span><br></pre></td></tr></table></figure>
<p>该操作可以通过docker-compose将IPFS启动</p>
<h3 id="进入IPFS容器"><a href="#进入IPFS容器" class="headerlink" title="进入IPFS容器"></a>进入IPFS容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh exec ipfs</span><br></pre></td></tr></table></figure>
<ol>
<li>该操作可以直接进入到IPFS容器中，然后操作ipfs的各种命令，比如第一条命令，查看版本号：<code>ipfs --version</code></li>
<li>在容器内部，ipfs实例已运行，也就是<code>ipfs init</code>在容器启动前就已经完成了，文件默认存储位置在<code>/data/ipfs/</code></li>
</ol>
<h3 id="停止IPFS容器"><a href="#停止IPFS容器" class="headerlink" title="停止IPFS容器"></a>停止IPFS容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.sh </span><br></pre></td></tr></table></figure>
<p>该操作将会停止并清除IPFS容器，当然，映射出来的文件依旧存在，下次重新启动后，依旧可以继续读取先前保存的内容。</p>
<h2 id="私有环境部署"><a href="#私有环境部署" class="headerlink" title="私有环境部署"></a>私有环境部署</h2><p>最好熟悉IPFS基本操作之后，回头在考虑私有环境多节点部署。<br>默认节点启动后，会根据内置默认的关联信息，去连接公网的IPFS节点。如果要建立私有环境，需要删除关联节点信息，逐个加入指定节点，并且这些节点使用相同的私钥。这里就不详细说明部署过程了，后期根据思路逐步来部署。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官方也提供了IPFS的多种安装方式，有直接安装二进制命令行的，有可视化安装本地客户端的等等，都可以试试。本文我只是根据自己情况，为简化流程，<br>使用自己封装的脚本来运行IPFS。一个节点启动后，后续即可用于掌握命令或者掌握程序对接和调用。</p>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs基础</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric基础-综合简介</title>
    <url>/articles/4636a38c/</url>
    <content><![CDATA[<p>fabric的背景、作用等等，这里就不介绍了，网上一搜一大堆。本文主要从技术层面来讲解fabric的特点、主要概念以及架构，从而能够快速对fabric能有一个整体上的认知。</p>
<a id="more"></a>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><img src="/articles/4636a38c/1.png" class="" title="Fabric架构">

<p>图中可知主要分为：网络层、核心层、接口层。</p>
<ol>
<li><p>网络层<br>负责P2P网络的实现，取保区块链分布式存储的一致性。使用了gRPC协议以及Gossip协议。</p>
</li>
<li><p>接口层<br>给第三方提供API、可通过Events监控事件，方便第三方应用调用和处理</p>
</li>
<li><p>核心层</p>
<ol>
<li>成员服务：包括注册、登记、申请证书等，为保证联盟成员数据的安全性，必须获得证书才能加入链中。</li>
<li>区块链服务：负责账本的计算和存储、节点的排序服务、背书验证管理以及账本存储方式等功能等实现</li>
<li>链码服务：智能合约，用于支撑业务</li>
</ol>
</li>
</ol>
<h2 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h2><ol>
<li>交易流程是Fabric的核心运行机制以及整体运行原理，很有必要去完整掌握。</li>
<li>Fabric中，并不是像公链那样一个节点集中处理各种问题，而是根据功能到不同，划分为了不同的节点和角色。大体上节点分为：处理业务的Peer节点以及用于达成排序共识的Order节点，其中Peer节点根据不同功能，还可具体划分为不同角色的节点，如背书节点Peer、提交节点Peer。关于节点概念、功能和细节，后续逐步会去详细讲解，在此只要有个大概了解即可。</li>
<li>在Fabric中，处理每笔交易都需要都需要对交易信息进行权限校验，确保上链的数据是经过授权允许的。</li>
</ol>
<h3 id="流程描述（重点掌握）"><a href="#流程描述（重点掌握）" class="headerlink" title="流程描述（重点掌握）"></a>流程描述（重点掌握）</h3><img src="/articles/4636a38c/3.png" class="" title="Fabric交易流程">

<ol>
<li>应用程序客户端通过SDK调用成员服务，进行注册、登记并获取身份证书</li>
<li>应用程序客户端通过SDK向区块链网络发起一个交易提案(Proposal)，交易提案把本次交易要调用的合约标识，合约方法和参数信息以及客户端签名等信息发送给背书节点。</li>
<li>背书节点收到交易提案后，验证签名并确定交易者是否有权执行操作，同时根据背书策略模拟执行智能合约，并将结果及各自的CA证书签名返回给应用程序客户端。</li>
<li>应用程序客户端收到背书节点返回的信息后，判断提案结果是否一致，以及是否参照指定的背书策略执行。如果没有足够的背书，则终止处理；否则，应用程序客户端把数据打包到一起，组成一个交易并签名，发送给排序节点（角色）。</li>
<li>排序节点（角色）对接收到的交易进行共识排序，然后按照区块生成策略，将一批交易打包到一起，生成新的区块，发送给提交节点(Peer)。</li>
<li>提交节点收到区块后，会对区块中的每笔交易进行校验，检查交易依赖的输入输出是否符合当前区块链的状态，完成后将区块追加到本地的区块链，并修改世界状态(即确保参数为最新值)</li>
</ol>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>Fabric的关键技术主要分为：<code>账本</code>、<code>智能合约</code>、<code>通道</code>、<code>节点</code>、<code>排序</code>、<code>接口</code>，通过这六部分底层内容的了解，可以很好的了解Fabric的运行机制</p>
<h3 id="1-账本-Ledger"><a href="#1-账本-Ledger" class="headerlink" title="1. 账本(Ledger)"></a>1. 账本(Ledger)</h3><p>主要是区块本身以及世界状态的存储，有序、防篡改。</p>
<img src="/articles/4636a38c/2.png" class="" title="Fabric交易流程">
<ol>
<li>本地文件系统<br>将区块存储于文件系统的硬盘中，每个区块中保存区块头(Block Header)、区块数据(Block Data)、区块元数据(Block Metadata，<code>配置相关信息?</code>)，通过区块头中的前一个区块的哈希值指向前一个区块区块的当前哈希值。</li>
<li>状态数据库<br>存储在链交易中出现的所有键值对的最新值，调用链码执行交易可改变状态数据。为了高效执行联码调用，最新值都保存在状态数据库中。默认状态数据库为LevelDB（特点：简单的KV），可选择Couchdb作为数据库（特点：富文本查询）。</li>
<li>账本索引数据库<br>文件系统中保存区块时，会在数据库(LevelDB)中保存索引。提高查询区块交易信息的速度。<code>注意这里跟状态数据库无关，状态数据库更多的是链码对应的业务数据。</code></li>
<li>历史状态数据库<br>一个键值更改后，更改的历史记录是保存在数据库中的。同样可以使用LevelDB或CouchDB，查询状态的时候，也可以查看值的历史更改记录。</li>
</ol>
<h3 id="2-智能合约-Chaincode"><a href="#2-智能合约-Chaincode" class="headerlink" title="2. 智能合约(Chaincode)"></a>2. 智能合约(Chaincode)</h3><p>用于处理业务的代码，稍微了解区块链的人应该都明白这个概念，只是Fabric中，更喜欢用<code>链码</code>来表达智能合约的意思。由于Fabric的授权机制，<code>链码</code>的生命周期较为复杂，其中1.4版和2.0版的生命周期差异很大，从打包、签名到最终安装、发布，涉及的细节较多，后续会专门来讲解这部分内容，这里有个了解即可。后续更多的是以2.0版为主来讲解。</p>
<h3 id="3-通道-Channel"><a href="#3-通道-Channel" class="headerlink" title="3. 通道(Channel)"></a>3. 通道(Channel)</h3><ol>
<li>一条channel可以理解为是一条独立的区块链，在其中拥有独立的创世区块以及智能合约。它是Peer之间通信的私有空间，channel内交易的数据与外部环境隔绝，保证channel内部数据安全。一条channel内部参与交易的成员，都需要经过身份验证和授权。</li>
<li>Fabric网络是多通道设计，也就是说，一个Peer节点可以同时加入不同的channel。</li>
<li>每个Channel都有自己的锚节点，通过锚节点可以与其它通道进行交互（比如合约内，可以通过锚节点访问另一个通道的某个参数），但本身通道的账本是隔绝的。</li>
</ol>
<h3 id="4-Peer节点"><a href="#4-Peer节点" class="headerlink" title="4. Peer节点"></a>4. Peer节点</h3><ol>
<li>是区块链交易处理和账本维护的主体，主要负责参与共识过程和通过执行链码实现对账本的读写操作。</li>
<li>Peer节点根据功能不同可以划分为：<code>背书节点(Endorser Peer)</code>、<code>提交节点(Committer Peer)</code><ol>
<li>背书节点(Endorser Peer)：根据事先设定好的策略对交易进行签名背书，在链码实例化的时候设置背书策略，指定哪些节点用于背书。当客户端向节点发起交易背书时，该节点才能有背书功能，否则只是普通的记账节点。</li>
<li>提交节点(Committer Peer)：也是普通的记账节点，负责维护状态数据和账本的副本。</li>
</ol>
</li>
<li>Peer节点根据通信不同可以划分为：<code>锚节点(Anchor Peer)</code>、<code>主节点(Leading Peer)</code><ol>
<li>锚节点(Anchor Peer)：随channel存在的，是能被其它channel发现的节点，每个channel上有一个或多个锚节点。</li>
<li>主节点(Leading Peer)：负责与Order通信，把共识后的区块传输到其它节点。</li>
</ol>
</li>
</ol>
<h3 id="5-Order排序"><a href="#5-Order排序" class="headerlink" title="5. Order排序"></a>5. Order排序</h3><p>对区块链网络中不同通道产生的交易进行排序，并广播给Peer。排序算法Fabric支持多种，如：Solo、Kafka、Raft等，Fabric2.0后，以Raft为主。</p>
<h3 id="6-API接口"><a href="#6-API接口" class="headerlink" title="6. API接口"></a>6. API接口</h3><p>方便第三方调用账本、chaincode、channel、节点、排序等</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Fabric的几个核心概念，通过这些概念能够对运行机制和原理有一个初步的了解。为后续深入掌握奠定了一个比较好的基础。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
        <category>Fabric基础</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（3）- 合约部署及操作</title>
    <url>/articles/b7ef0ae1/</url>
    <content><![CDATA[<p>前面两个章节，已经搭建好了一个基本的fabric测试网络，在已有基础上，本文在其中加入智能合约，也就是<code>chaincode</code>，如此一条用于测试的fabric联盟链就算完整了。后续就可以在该测试链基础上研究fabric的具体细节了。</p>
<a id="more"></a>

<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><ol>
<li>请先看<a href="/articles/79376746/index.html">fabric-samples基本使用（1）- 下载准备</a>以及<a href="/articles/3b7f5326/index.html">fabric-samples基本使用（2）- 启动测试网络</a></li>
<li><code>chaincode</code>目前支持goalng、java来实现，考虑到技术栈和远期规划，这里我还是以golang为主，本文测试网络将会调用官方提供的demo合约。</li>
</ol>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>先确保网络已经正常启动</p>
<h3 id="1-发布合约"><a href="#1-发布合约" class="headerlink" title="1. 发布合约"></a>1. 发布合约</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里使用官方测试案例fabcar</span></span><br><span class="line">./network.sh deployCC -ccn fabcar -ccp ../chaincode/fabcar/go/ -ccl go</span><br></pre></td></tr></table></figure>
<p>在官方测试网络提供的脚本中，只有这一条命令即可发布一条合约，早前版本的脚本，如果不传入参数，会默认调用官方的<code>fabCar</code>合约来发布，但当前最新版脚本强制要求指定合约，<br>应该是为了让脚本更加通用。<br>这里强制要求最少传入三个参数：<code>合约名称 -ccn</code>、<code>合约路径 -ccp</code>、<code>合约开发语言 -ccl</code>，其余可选参数，如策略等，若不传入，则使用官方提供的默认值。</p>
<h3 id="2-合约发布期间产生的日志"><a href="#2-合约发布期间产生的日志" class="headerlink" title="2. 合约发布期间产生的日志"></a>2. 合约发布期间产生的日志</h3><p>在fabric2.0，对合约的生命周期有了更细的划分，以下是<code>fabcar</code>合约发布整个流程的日志(无删减)，通过日志可以很快了解一个合约发布需要涉及到的主要步骤，这里每个步骤我在其中加入了描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 合约发布的环境描述，在&#39;mychannel&#39;中发布</span><br><span class="line">deploying chaincode on channel &#39;mychannel&#39;</span><br><span class="line">executing with the following</span><br><span class="line">- CHANNEL_NAME: mychannel</span><br><span class="line">- CC_NAME: fabcar</span><br><span class="line">- CC_SRC_PATH: ..&#x2F;chaincode&#x2F;fabcar&#x2F;go&#x2F;</span><br><span class="line">- CC_SRC_LANGUAGE: go</span><br><span class="line">- CC_VERSION: 1.0</span><br><span class="line">- CC_SEQUENCE: 1</span><br><span class="line">- CC_END_POLICY: NA</span><br><span class="line">- CC_COLL_CONFIG: NA</span><br><span class="line">- CC_INIT_FCN: NA</span><br><span class="line">- DELAY: 3</span><br><span class="line">- MAX_RETRY: 5</span><br><span class="line">- VERBOSE: false</span><br><span class="line"></span><br><span class="line">2. 根据合约代码中go.mod描述的依赖，下载相关依赖</span><br><span class="line">Vendoring Go dependencies at ..&#x2F;chaincode&#x2F;fabcar&#x2F;go&#x2F;</span><br><span class="line">~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;chaincode&#x2F;fabcar&#x2F;go ~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network</span><br><span class="line">go: downloading github.com&#x2F;hyperledger&#x2F;fabric-contract-api-go v1.1.0</span><br><span class="line">go: downloading github.com&#x2F;hyperledger&#x2F;fabric-chaincode-go v0.0.0-20200424173110-d7076418f212</span><br><span class="line">go: downloading github.com&#x2F;hyperledger&#x2F;fabric-protos-go v0.0.0-20200424173316-dd554ba3746e</span><br><span class="line">go: downloading github.com&#x2F;golang&#x2F;protobuf v1.3.2</span><br><span class="line">go: downloading google.golang.org&#x2F;grpc v1.23.0</span><br><span class="line">go: downloading github.com&#x2F;xeipuuv&#x2F;gojsonschema v1.2.0</span><br><span class="line">go: downloading github.com&#x2F;go-openapi&#x2F;spec v0.19.4</span><br><span class="line">go: downloading github.com&#x2F;gobuffalo&#x2F;packr v1.30.1</span><br><span class="line">go: downloading github.com&#x2F;xeipuuv&#x2F;gojsonreference v0.0.0-20180127040603-bd5ef7bd5415</span><br><span class="line">go: downloading github.com&#x2F;go-openapi&#x2F;jsonpointer v0.19.3</span><br><span class="line">go: downloading github.com&#x2F;go-openapi&#x2F;jsonreference v0.19.2</span><br><span class="line">go: downloading github.com&#x2F;go-openapi&#x2F;swag v0.19.5</span><br><span class="line">go: downloading github.com&#x2F;gobuffalo&#x2F;envy v1.7.0</span><br><span class="line">go: downloading github.com&#x2F;gobuffalo&#x2F;packd v0.3.0</span><br><span class="line">go: downloading golang.org&#x2F;x&#x2F;net v0.0.0-20190827160401-ba9fcec4b297</span><br><span class="line">go: downloading google.golang.org&#x2F;genproto v0.0.0-20180831171423-11092d34479b</span><br><span class="line">go: downloading github.com&#x2F;xeipuuv&#x2F;gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f</span><br><span class="line">go: downloading github.com&#x2F;PuerkitoBio&#x2F;purell v1.1.1</span><br><span class="line">go: downloading github.com&#x2F;mailru&#x2F;easyjson v0.0.0-20190626092158-b2ccc519800e</span><br><span class="line">go: downloading gopkg.in&#x2F;yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com&#x2F;joho&#x2F;godotenv v1.3.0</span><br><span class="line">go: downloading github.com&#x2F;rogpeppe&#x2F;go-internal v1.3.0</span><br><span class="line">go: downloading golang.org&#x2F;x&#x2F;sys v0.0.0-20190710143415-6ec70d6a5542</span><br><span class="line">go: downloading github.com&#x2F;PuerkitoBio&#x2F;urlesc v0.0.0-20170810143723-de5bf2ad4578</span><br><span class="line">go: downloading golang.org&#x2F;x&#x2F;text v0.3.2</span><br><span class="line">~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network</span><br><span class="line">Finished vendoring Go dependencies</span><br><span class="line"></span><br><span class="line">3. 打包合约，将合约打包为*.tar.gz压缩包，里面是包含合约源码和上一步骤下载的依赖</span><br><span class="line">+ peer lifecycle chaincode package fabcar.tar.gz --path ..&#x2F;chaincode&#x2F;fabcar&#x2F;go&#x2F; --lang golang --label fabcar_1.0</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">Chaincode is packaged</span><br><span class="line"></span><br><span class="line">4-1. 为org1的peer0安装合约</span><br><span class="line">Installing chaincode on peer0.org1...</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode install fabcar.tar.gz</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">2021-04-22 12:37:21.229 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nKfabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a\022\nfabcar_1.0&quot; &gt; </span><br><span class="line">2021-04-22 12:37:21.229 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a</span><br><span class="line">Chaincode is installed on peer0.org1</span><br><span class="line"></span><br><span class="line">4-2. 为org2的peer0安装合约</span><br><span class="line">Install chaincode on peer0.org2...</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode install fabcar.tar.gz</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">2021-04-22 12:37:43.834 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nKfabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a\022\nfabcar_1.0&quot; &gt; </span><br><span class="line">2021-04-22 12:37:43.850 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a</span><br><span class="line">Chaincode is installed on peer0.org2</span><br><span class="line"></span><br><span class="line">5. 检查org1的peer0安装了哪些合约，这里可以看出成功安装了fabcar_1.0</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode queryinstalled</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a, Label: fabcar_1.0</span><br><span class="line">Query installed successful on peer0.org1 on channel</span><br><span class="line"></span><br><span class="line">6-1. 在org1的peer0授权合约，就是说合约规则默认要求多个组织确认后，才可以上链，可以理解为多签。</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network&#x2F;organizations&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem --channelID mychannel --name fabcar --version 1.0 --package-id fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a --sequence 1</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">2021-04-22 12:37:46.658 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [cbc8814b90142b71153fba5cd3aa276b25365d43bfbc07ec05f573094889933a] committed with status (VALID) at localhost:7051</span><br><span class="line">Chaincode definition approved on peer0.org1 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">6-2. org1的peer0授权合约后，在org1的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 1</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org1 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">6-3. org1的peer0授权合约后，在org2的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 2</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org2 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">6-4. 在org2的peer0授权合约，就是说合约规则默认要求多个组织确认后，才可以上链，可以理解为多签。</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network&#x2F;organizations&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem --channelID mychannel --name fabcar --version 1.0 --package-id fabcar_1.0:b41ab9af76a078ae8af2b9897c51f6a0c401e4c6c777414d766698b1b7fac00a --sequence 1</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">2021-04-22 12:37:55.389 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [42c8e7326c69c7859d77ccdb9509d71ff3a3fbeeb98619972c3633b9dfff338e] committed with status (VALID) at localhost:9051</span><br><span class="line">Chaincode definition approved on peer0.org2 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">6-5. org2的peer0授权合约后，在org1的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 1</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org1 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">6-6. org2的peer0授权合约后，在org2的peer0检查合约在各组织的授权是否成功</span><br><span class="line">Using organization 2</span><br><span class="line">Checking the commit readiness of the chaincode definition on peer0.org2 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name fabcar --version 1.0 --sequence 1 --output json</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">	&quot;approvals&quot;: &#123;</span><br><span class="line">		&quot;Org1MSP&quot;: true,</span><br><span class="line">		&quot;Org2MSP&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">7. 前面的合约已安装、授权（多签）完毕，这里开始在org1的peer0和org2的peer0提交定义合约，可以理解为初始化出一个合约模板，这也是fabric2.0的一个特性，同一个合约可以重复使用</span><br><span class="line">Using organization 1</span><br><span class="line">Using organization 2</span><br><span class="line">+ peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network&#x2F;organizations&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem --channelID mychannel --name fabcar --peerAddresses localhost:7051 --tlsRootCertFiles &#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network&#x2F;organizations&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles &#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;test-network&#x2F;organizations&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt --version 1.0 --sequence 1</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">2021-04-22 12:38:04.422 CST [chaincodeCmd] ClientWait -&gt; INFO 001 txid [abfb67fbeaff552237a982020350063d98ad9620ad0a72e1505aa650fd55eb2c] committed with status (VALID) at localhost:9051</span><br><span class="line">2021-04-22 12:38:04.422 CST [chaincodeCmd] ClientWait -&gt; INFO 002 txid [abfb67fbeaff552237a982020350063d98ad9620ad0a72e1505aa650fd55eb2c] committed with status (VALID) at localhost:7051</span><br><span class="line">Chaincode definition committed on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">8-1 在org1的peer0检查合约定义成功与否</span><br><span class="line">Using organization 1</span><br><span class="line">Querying chaincode definition on peer0.org1 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to Query committed status on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name fabcar</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">Committed chaincode definition for chaincode &#39;fabcar&#39; on channel &#39;mychannel&#39;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org1 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">8-2 在org2的peer0检查合约定义成功与否</span><br><span class="line">Using organization 2</span><br><span class="line">Querying chaincode definition on peer0.org2 on channel &#39;mychannel&#39;...</span><br><span class="line">Attempting to Query committed status on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name fabcar</span><br><span class="line">+ res&#x3D;0</span><br><span class="line">Committed chaincode definition for chaincode &#39;fabcar&#39; on channel &#39;mychannel&#39;:</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org2 on channel &#39;mychannel&#39;</span><br><span class="line"></span><br><span class="line">8-3 如果脚本传入了初始化方法，则调用合约初始化函数，如果没传入，则不执行</span><br><span class="line">Chaincode initialization is not required</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，《fabric-samples基本使用》三部曲已经完成，走完整个流程，对fabric整体会有一个大概的了解，明显能感觉到，联盟链对理念和架构明显比公链复杂很多。<br>当然，<code>fabric-samples</code>内容远远不止于此，如果有时间，建议最好详细读一下整套脚本，配合官方文档，先对fabric有个全局观。<br>后续将会梳理一些fabric偏原理、架构类的内容，逐步深入。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（2）- 启动测试网络</title>
    <url>/articles/3b7f5326/</url>
    <content><![CDATA[<p>fabric-samples中的<code>test-network</code>提供了一个简单的demo测试网络，方便新人学习的同时也方便开发人员测试合约和一些网络组合。<br>本文主要介绍该测试网络的启动，包括channel的部署等。</p>
<a id="more"></a>

<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><ol>
<li>请先看<a href="/articles/79376746/index.html">fabric-samples基本使用（一）- 下载准备</a></li>
<li><code>test-network</code>网络中，默认提供了一个<code>order</code>以及两个<code>peer</code>，peer分别属于org1和org2两个组织，这两个组织均在同一个channel中</li>
</ol>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="步骤1-启动网络"><a href="#步骤1-启动网络" class="headerlink" title="步骤1-启动网络"></a>步骤1-启动网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh up -s couchdb</span><br></pre></td></tr></table></figure>
<p>该命令将启动一个order和两个peer节点，每个节点各自生成自己对组织文件（包含MSP、账户、tls等），fabric默认使用的是leveldb存储数据存储状态数据，如果要对数据做富文本查询，建议用<code>-s couchdb</code>来启用couchdb，<br>创建联盟选择好数据库后，以后则不可再更换数据库（基于当前规则）。<br><code>注意</code>：账户、证书的生成，这里是用的fabric自带的工具生成的，这个仅仅适用于测试环境，在真正的生产环境，是需要有专门的CA中心来统一管理证书发放。</p>
<h3 id="步骤2-创建通道"><a href="#步骤2-创建通道" class="headerlink" title="步骤2-创建通道"></a>步骤2-创建通道</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh createChannel</span><br></pre></td></tr></table></figure>
<p>该命令将创建一条名为<code>mychannel</code>的channel，一条channel就可以理解为是一条链，创建channel的过程就是初始化一条链的过程。主要经历以下过程：</p>
<ol>
<li>channel初始化配置文件生成，</li>
<li>org1组织根据上一步生成的配置文件，创建<code>mychannel</code>并提交给order（需要order签名文件授权），order确认后，<code>mychannel</code>创建成功</li>
<li>分别将org1和org2加入<code>mychannel</code></li>
<li>分别为org1和org2设置锚节点，每个组织至少要有一个锚节点，主要用于更新普通channel，通道间通信</li>
</ol>
<h3 id="步骤3-关闭清除网络"><a href="#步骤3-关闭清除网络" class="headerlink" title="步骤3-关闭清除网络"></a>步骤3-关闭清除网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure>
<p>若部署操作有异常，或者要清除已有环境，可使用该命令停止和清除测试网络相关文件，包括docker容器等。</p>
<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此，一条基本的fabric测试联盟链搭建完成。一个order、2个peer组成一个联盟，在这个联盟中，总共只有一条通道mychannel。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是<code>fabric-samples</code>节点网络的创建以及channel的生成，大概讲了下操作流程，具体细节需要自己去<code>network.sh</code>脚本中查看。<br>接触fabric之后，你会发现，整个使用过程你都是在围绕着账户签名和证书来进行的，fabric在区块链领域中最大的特点就是<code>鉴权</code>。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric-samples基本使用（1）- 下载准备</title>
    <url>/articles/79376746/</url>
    <content><![CDATA[<p>超级账本这些年一直在零零碎碎的学习和使用着，也做过一些项目。在此打算将已有的笔记和一些新的学习心得梳理出来。<br>姑且不说Fabric是什么，相信我，比起<a href="https://hyperledger-fabric.readthedocs.io/">官方文档</a>，官方提供的 <a href="https://github.com/hyperledger/fabric-samples">测试网络 fabric-samples</a> 一定是最好的入门教程，结合本系列文章对其使用的介绍，相信很快就能了解到Fabric到底是什么。</p>
<a id="more"></a>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文基于<code>fabric 2.3.1</code>以及<code>fabric-ca 1.5</code>，需要环境<code>docker以及docker-compose.yml</code>。</p>
<h2 id="下载相关内容"><a href="#下载相关内容" class="headerlink" title="下载相关内容"></a>下载相关内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步 下载代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples</span><br><span class="line"><span class="built_in">cd</span> fabric-samples</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步 下载可执行程序和配置，解压后，确保conf目录和bin目录在fabric-samples的根目录中</span></span><br><span class="line">方式1（境外网站，没特殊手段下载会很慢）：使用官方脚本：curl -sSL https://bit.ly/2ysbOFE | bash -s  若打不开，本文下一节有该脚本供参考</span><br><span class="line">方式2：前往：https://github.com/hyperledger/fabric/releases/ 下载可执行程序并解压</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 下载ca可执行程序，放在第二步的bin目录下</span></span><br><span class="line">https://github.com/hyperledger/fabric-ca/releases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目录结构如下：</span></span><br><span class="line">.</span><br><span class="line">└── fabric-samples</span><br><span class="line">    ├── bin</span><br><span class="line">    │ ├── configtxgen</span><br><span class="line">    │ ├── configtxlator</span><br><span class="line">    │ ├── cryptogen</span><br><span class="line">    │ ├── discover</span><br><span class="line">    │ ├── fabric-ca-client</span><br><span class="line">    │ ├── fabric-ca-server</span><br><span class="line">    │ ├── idemixgen</span><br><span class="line">    │ ├── orderer</span><br><span class="line">    │ ├── osnadmin</span><br><span class="line">    │ └── peer</span><br><span class="line">    ├── config</span><br><span class="line">    │ ├── configtx.yaml</span><br><span class="line">    │ ├── core.yaml</span><br><span class="line">    │ └── orderer.yaml</span><br><span class="line">    ├── asset-transfer-abac</span><br><span class="line">    ├── asset-transfer-basic</span><br><span class="line">    ├── asset-transfer-events</span><br><span class="line">    ├── asset-transfer-ledger-queries</span><br><span class="line">    ├── asset-transfer-private-data</span><br><span class="line">    ├── asset-transfer-sbe</span><br><span class="line">    ├── asset-transfer-secured-agreement</span><br><span class="line">    ├── auction</span><br><span class="line">    ├── chaincode</span><br><span class="line">    ├── CHANGELOG.md</span><br><span class="line">    ├── ci</span><br><span class="line">    ├── CODE_OF_CONDUCT.md</span><br><span class="line">    ├── CODEOWNERS</span><br><span class="line">    ├── commercial-paper</span><br><span class="line">    ├── CONTRIBUTING.md</span><br><span class="line">    ├── fabcar</span><br><span class="line">    ├── high-throughput</span><br><span class="line">    ├── interest_rate_swaps</span><br><span class="line">    ├── LICENSE</span><br><span class="line">    ├── MAINTAINERS.md</span><br><span class="line">    ├── off_chain_data</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── scripts</span><br><span class="line">    ├── SECURITY.md</span><br><span class="line">    ├── test-application</span><br><span class="line">    ├── test-network  </span><br><span class="line">    ├── token-erc-20</span><br><span class="line">    ├── token-erc-721</span><br><span class="line">    └── token-utxo</span><br><span class="line">以上目录，test-network是启动测试网络需要的脚本等，而其余目录主要是chaincode案例</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步 fabric相关docker镜像下载</span></span><br><span class="line">建议使用官方脚本</span><br><span class="line">curl -sSL https://bit.ly/2ysbOFE | bash -s</span><br><span class="line">可一次性将镜像、二进制等下载，并且目录自动解压，唯一缺点是，墙外网络，你懂的。参考下一章节的镜像下载部分的脚本</span><br></pre></td></tr></table></figure>
<h2 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h2><p>官方提供的资源下载脚本，可参考，根据需要去资源原站手动下载，速度感觉会快一些。<br>脚本结尾部分的三段功能，分别是下载<code>samples</code>、<code>镜像</code>、<code>二进制</code>，可根据需要来选择使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if version not passed in, default to latest released version</span></span><br><span class="line">VERSION=2.3.1</span><br><span class="line"><span class="comment"># if ca version not passed in, default to latest released version</span></span><br><span class="line">CA_VERSION=1.4.9</span><br><span class="line">ARCH=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(uname -s|tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;|sed &#x27;s/mingw64_nt.*/windows/&#x27;)</span>-<span class="subst">$(uname -m | sed &#x27;s/x86_64/amd64/g&#x27;)</span>&quot;</span>)</span><br><span class="line">MARCH=$(uname -m)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">printHelp</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: bootstrap.sh [version [ca_version]] [options]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;options:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-h : this help&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-d : bypass docker image download&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-s : bypass fabric-samples repo clone&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;-b : bypass download of platform-specific binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;e.g. bootstrap.sh 2.3.1 1.4.9 -s&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;will download docker images and binaries for Fabric v2.3.1 and Fabric CA v1.4.9&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dockerPull() pulls docker images from fabric and chaincode repositories</span></span><br><span class="line"><span class="comment"># note, if a docker image doesn&#x27;t exist for a requested release, it will simply</span></span><br><span class="line"><span class="comment"># be skipped, since this script doesn&#x27;t terminate upon errors.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dockerPull</span></span>() &#123;</span><br><span class="line">    <span class="comment">#three_digit_image_tag is passed in, e.g. &quot;1.4.7&quot;</span></span><br><span class="line">    three_digit_image_tag=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="comment">#two_digit_image_tag is derived, e.g. &quot;1.4&quot;, especially useful as a local tag for two digit references to most recent baseos, ccenv, javaenv, nodeenv patch releases</span></span><br><span class="line">    two_digit_image_tag=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$three_digit_image_tag</span>&quot;</span> | cut -d<span class="string">&#x27;.&#x27;</span> -f1,2)</span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        image_name=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;====&gt; hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        docker pull <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span></span><br><span class="line">        docker tag <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>&quot;</span></span><br><span class="line">        docker tag <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>&quot;</span> <span class="string">&quot;hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$two_digit_image_tag</span>&quot;</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cloneSamplesRepo</span></span>() &#123;</span><br><span class="line">    <span class="comment"># clone (if needed) hyperledger/fabric-samples and checkout corresponding</span></span><br><span class="line">    <span class="comment"># version to the binaries and docker images to be downloaded</span></span><br><span class="line">    <span class="keyword">if</span> [ -d first-network ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if we are in the fabric-samples repo, checkout corresponding version</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Already in fabric-samples repo&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d fabric-samples ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if fabric-samples repo already cloned and in current directory,</span></span><br><span class="line">        <span class="comment"># cd fabric-samples</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Changing directory to fabric-samples&quot;</span></span><br><span class="line">        <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Cloning hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">        git <span class="built_in">clone</span> -b master https://github.com/hyperledger/fabric-samples.git &amp;&amp; <span class="built_in">cd</span> fabric-samples</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> GIT_DIR=.git git rev-parse v<span class="variable">$&#123;VERSION&#125;</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Checking out v<span class="variable">$&#123;VERSION&#125;</span> of hyperledger/fabric-samples&quot;</span></span><br><span class="line">        git checkout -q v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;fabric-samples v<span class="variable">$&#123;VERSION&#125;</span> does not exist, defaulting master&quot;</span></span><br><span class="line">        git checkout -q master</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will download the .tar.gz</span></span><br><span class="line"><span class="function"><span class="title">download</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> BINARY_FILE=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> URL=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading: &quot;</span> <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span></span><br><span class="line">    curl -L --retry 5 --retry-delay 3 <span class="string">&quot;<span class="variable">$&#123;URL&#125;</span>&quot;</span> | tar xz || rc=$?</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$rc</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; There was an error downloading the binary file.&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 22</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;==&gt; Done.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullBinaries</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binaries&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/<span class="variable">$&#123;BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binary is not available to download &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;===&gt; Downloading version <span class="variable">$&#123;CA_TAG&#125;</span> platform specific fabric-ca-client binary&quot;</span></span><br><span class="line">    download <span class="string">&quot;<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span> <span class="string">&quot;https://github.com/hyperledger/fabric-ca/releases/download/v<span class="variable">$&#123;CA_VERSION&#125;</span>/<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;------&gt; <span class="variable">$&#123;CA_TAG&#125;</span> fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) &lt;----&quot;</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullDockerImages</span></span>() &#123;</span><br><span class="line">    <span class="built_in">command</span> -v docker &gt;&amp; /dev/null</span><br><span class="line">    NODOCKER=$?</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;NODOCKER&#125;</span>&quot;</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        FABRIC_IMAGES=(peer orderer ccenv tools)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$VERSION</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        2.*)</span><br><span class="line">            FABRIC_IMAGES+=(baseos)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;FABRIC_IMAGES:&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric Images&quot;</span></span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; Pulling fabric ca Image&quot;</span></span><br><span class="line">        CA_IMAGE=(ca)</span><br><span class="line">        dockerPull <span class="string">&quot;<span class="variable">$&#123;CA_TAG&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CA_IMAGE[@]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;===&gt; List out hyperledger docker images&quot;</span></span><br><span class="line">        docker images | grep hyperledger</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Docker not installed, bypassing download of Fabric images&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=========================================================&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOCKER=<span class="literal">true</span></span><br><span class="line">SAMPLES=<span class="literal">true</span></span><br><span class="line">BINARIES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse commandline args pull out</span></span><br><span class="line"><span class="comment"># version and/or ca-version strings first</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]  &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        CA_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">if</span> [ -n  <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$&#123;1:0:1&#125;</span>&quot;</span> != <span class="string">&quot;-&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            THIRDPARTY_IMAGE_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prior to 1.2.0 architecture was determined by uname -m</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$VERSION</span> =~ ^1\.[0-1]\.* ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> FABRIC_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> CA_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> THIRDPARTY_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;THIRDPARTY_IMAGE_VERSION&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># starting with 1.2.0, multi-arch images will be default</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;CA_TAG:=&quot;$CA_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;FABRIC_TAG:=&quot;$VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line">    : <span class="string">&quot;<span class="variable">$&#123;THIRDPARTY_TAG:=&quot;$THIRDPARTY_IMAGE_VERSION&quot;&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BINARY_FILE=hyperledger-fabric-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz</span><br><span class="line">CA_BINARY_FILE=hyperledger-fabric-ca-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># then parse opts</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;h?dsb&quot;</span> opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        h|\?)</span><br><span class="line">            printHelp</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d)  DOCKER=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        s)  SAMPLES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        b)  BINARIES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SAMPLES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Clone hyperledger/fabric-samples repo&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    cloneSamplesRepo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BINARIES</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric binaries&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullBinaries</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DOCKER</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Pull Hyperledger Fabric docker images&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullDockerImages</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<code>fabric-samples</code>相关文件下载并准备工作完毕，后续操作请看下一篇讲解。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>lotus应用第1讲-2k扇区开发环境部署和应用</title>
    <url>/articles/1c05114c/</url>
    <content><![CDATA[<p>基于环境限制，使用2k扇区测试和校验lotus功能。<br>此环境的部署和使用，官方文档也有提供，但讲的太过简洁，传送门在这里：<a href="https://docs.filecoin.io/build/local-devnet/#devnet-with-vanilla-lotus-binaries">Run a Filecoin local devnet</a><br>本文主要是细化官方文档中的描述，加入个人理解和使用心得。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于lotus的编译和部署，可以参考我整理的脚本：<a href="https://github.com/jason-wj/filecoin-doc">filecoin-doc</a><br>本文直接从编译后的使用过程开始讲解。<br>ps: <code>后续根据对lotus的深入了解，会逐步完善本文一些描述不清、不准确的地方</code></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>文件下载或者数据同步失败一般就是网路访问问题，目前的解决方式就是用vpn或者代理</p>
<h3 id="步骤1-下载2k扇区封装所需的证明文件"><a href="#步骤1-下载2k扇区封装所需的证明文件" class="headerlink" title="步骤1-下载2k扇区封装所需的证明文件"></a>步骤1-下载2k扇区封装所需的证明文件</h3><p>该文件用于后续扇区封装时的校验，具体用途还不明了，下载耗时久，大概1G文件需要下载。<br>不用代理的话，国内网络下载很慢，可能得等十几个小时</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus fetch-params 2048</span><br></pre></td></tr></table></figure>
<h3 id="步骤2-设置预封装扇区"><a href="#步骤2-设置预封装扇区" class="headerlink" title="步骤2-设置预封装扇区"></a>步骤2-设置预封装扇区</h3><p>按我理解就是节点发布前通过程序预先封装好2个扇区（就是预先认证确认），每个扇区2kb。<br>用模拟数据封装的，执行后，会生成对应的矿工账户（密钥）、文件等信息<br>这一步骤纯粹就是为了测试而生成的。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed pre-seal --sector-size 2KiB --num-sectors 2</span><br></pre></td></tr></table></figure>
<p>执行后，会生成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cache                       缓存</span><br><span class="line">├── pre-seal-t01000.json        矿工信息</span><br><span class="line">├── pre-seal-t01000.key         矿工私钥</span><br><span class="line">├── sealed                      已经封装好的两个扇区（2个文件）</span><br><span class="line">├── sectorstore.json            封装配置信息</span><br><span class="line">└── unsealed                    空文件，应该是存放尚未被封装的</span><br></pre></td></tr></table></figure>
<h3 id="步骤3-生成创世块配置文件"><a href="#步骤3-生成创世块配置文件" class="headerlink" title="步骤3-生成创世块配置文件"></a>步骤3-生成创世块配置文件</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed genesis new localnet.json</span><br></pre></td></tr></table></figure>
<h3 id="步骤4-将预封装生成的矿工信息，加入到创世配置文件中"><a href="#步骤4-将预封装生成的矿工信息，加入到创世配置文件中" class="headerlink" title="步骤4-将预封装生成的矿工信息，加入到创世配置文件中"></a>步骤4-将预封装生成的矿工信息，加入到创世配置文件中</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-seed genesis add-miner localnet.json ~/.genesis-sectors/pre-seal-t01000.json</span><br></pre></td></tr></table></figure>
<p>加入后，再去看<code>localnet.json</code>，里面多了个矿工的信息</p>
<h3 id="步骤5-启动lotus守护进程"><a href="#步骤5-启动lotus守护进程" class="headerlink" title="步骤5-启动lotus守护进程"></a>步骤5-启动lotus守护进程</h3><p>根据前面生成的<code>localnet.json</code>，启动lotus守护进程。<br>根据在源码中查阅，这里需要注意的是：<code>--lotus-make-genesis</code>和<code>--genesis-template</code>这两个参数应该仅是测试和开发时使用，在命令行列表中本身是不对外展示的。<br>其中：</p>
<ol>
<li><code>--lotus-make-genesis</code>是用来生成car压缩文件，目前猜测是创世相关内容，具体作用未知。</li>
<li><code>--genesis-template</code>用来指定创世配置，就是前面生成的。</li>
<li><code>--bootstrap</code>是否监听或者同步别的节点（猜的）</li>
</ol>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus daemon --lotus-make-genesis=devgen.car --genesis-template=localnet.json --bootstrap=false</span><br></pre></td></tr></table></figure>
<h3 id="步骤6-为lotus导入默认的矿工私钥"><a href="#步骤6-为lotus导入默认的矿工私钥" class="headerlink" title="步骤6-为lotus导入默认的矿工私钥"></a>步骤6-为lotus导入默认的矿工私钥</h3><p>保持<code>第5步</code>运行窗口，使用新的命令行窗口。<br>就是lotus当前节点默认钱包账户（私钥可对应生成账户）<br>该私钥在<code>第二步</code>中已生成</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus wallet import --as-default ~/.genesis-sectors/pre-seal-t01000.key</span><br></pre></td></tr></table></figure>
<h3 id="步骤7-为lotus-miner初始化配置矿工信息"><a href="#步骤7-为lotus-miner初始化配置矿工信息" class="headerlink" title="步骤7 为lotus-miner初始化配置矿工信息"></a>步骤7 为lotus-miner初始化配置矿工信息</h3><p>配置均是基于<code>步骤2</code>生成的文件来操作的</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-miner init --genesis-miner --actor=t01000 --sector-size=2KiB --pre-sealed-sectors=~/.genesis-sectors --pre-sealed-metadata=~/.genesis-sectors/pre-seal-t01000.json --nosync</span><br></pre></td></tr></table></figure>
<h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>这一步消耗资源严重，谨慎操作，启动后，一个完整的节点运行案例就形成了。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">./lotus-miner run --nosync</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Lotus</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>Filecoin</tag>
        <tag>Lotus</tag>
      </tags>
  </entry>
  <entry>
    <title>lotus源码解读第1讲-目录结构说明</title>
    <url>/articles/510314b6/</url>
    <content><![CDATA[<p>根据个人理解，逐步添加各目录描述。</p>
<a id="more"></a>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── Dockerfile.lotus    构造容器</span><br><span class="line">├── LICENSE-APACHE</span><br><span class="line">├── LICENSE-MIT</span><br><span class="line">├── Makefile            项目编译文件，可编译获取依赖，生成指定可执行程序等，重点</span><br><span class="line">├── README.md</span><br><span class="line">├── SECURITY.md</span><br><span class="line">├── api                 接口服务</span><br><span class="line">├── build               构建节点的函数（待定）</span><br><span class="line">├── chain               实现与链的交互功能</span><br><span class="line">├── cli                 lotus可执行程序的主要命令，这些命令汇总后，会加入合并到cmd模块下的lotus中</span><br><span class="line">├── cmd                 模块化命令，其中每个文件夹都可以独立编译成一个程序，供独立使用</span><br><span class="line">├── conformance</span><br><span class="line">├── documentation       使用文档</span><br><span class="line">├── extern</span><br><span class="line">├── gen</span><br><span class="line">├── genesis</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── journal</span><br><span class="line">├── lib                 各模块公用的函数</span><br><span class="line">├── lotuspond</span><br><span class="line">├── markets</span><br><span class="line">├── metrics</span><br><span class="line">├── miner               定义产出区块逻辑</span><br><span class="line">├── node                节点实现</span><br><span class="line">├── paychmgr</span><br><span class="line">├── scripts             一些快捷脚本，比如节点部署等</span><br><span class="line">├── storage             定义存储矿工逻辑</span><br><span class="line">├── system</span><br><span class="line">├── testplans</span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Lotus</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Filecoin</tag>
        <tag>Lotus</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊dpos共识改造-实现dpos算法（1）</title>
    <url>/articles/2092aa9f/</url>
    <content><![CDATA[<p>dpos是什么，为什么要改造成dpos，这些问题小编就不解释了。可参考：<a href="/articles/bbe43e3f">委托股权证明原理(DPOS)–翻译及解读</a><br>对以太坊做dpos共识改造，从0开始是不可能的，这里小编参考了<a href="https://github.com/meitu/go-ethereum">美图以太坊dpos改造</a>。美图实验室的改造相比较来说更加直观，网上这方面对信息不多，为此，小编参考该项目重头敲了一遍这个共识。收益颇多，也发现了很多不足的地方。</p>
<a id="more"></a>
<p>美图官方发布的改造教程解说并不多，讲述的内容也很简洁。为此，小编通过这篇文章详细解释下dpos在以太坊中的改造细节。自我总结的同时，希望能对大家有所帮助。<br>美图是在ethereum1.7.4上改造dpos的，而小编是在1.8.20上改造的，会有一些差异，但影响不大。<br>本文最后会介绍这次改造中的不足之处，后续会逐步完善。</p>
<h2 id="本文源码下载"><a href="#本文源码下载" class="headerlink" title="本文源码下载"></a>本文源码下载</h2><p>本文是在以太坊基础上改造的，整个源码迟些时候会放在github上，其实这源码就是美图官方的，只是小编根据自己的想法做了一些改动。<br>每个阶段的改动，都会单独切换一个分支。<br>分阶段实现，更容易理解这次改造的过程。<br>dpos相关源码位置都有对应的单元测试，可快速验证每个方法。<br>关键地方，小编都加入了中文注释。</p>
<h2 id="dpos整体框架"><a href="#dpos整体框架" class="headerlink" title="dpos整体框架"></a>dpos整体框架</h2><p>小编先前在<a href="/articles/3673b530">以太坊源码解读-第6.1讲-共识模块入口设计</a>以及<a href="/articles/231042d1">以太坊源码解读-第6.2讲-pow共识算法实现</a>中解释过，<br>实现一套共识算法，是需要在以太坊提供的共识引擎之下完成。<br>这里先说一下本文dpos的全局参数：</p>
<ol>
<li>每隔10秒钟生成一个块，</li>
<li>每一天（24小时）进行一轮新的选举</li>
<li>验证人有21个</li>
<li>验证人最小人数为15人（计算方式：21*2/3+1）</li>
</ol>
<p>美图DPOS的实现方案如下图所示：</p>
<img src="/articles/2092aa9f/1.png" class="" title="Dpos算法整体结构">
<p>注意区分候选人和验证人，<code>验证人是候选人之一，但候选人不一定是验证人</code><br>从上图可以看出，分成三大部分，这里简述一下其中每部分的作用：</p>
<ol>
<li>dpos_context和dpos_context_pro：用来存储和操作验证人、投票、候选人等信息，是通过trie来将这些信息存储在leveldb中。这些信息主要分为5部分：<ol>
<li>EpochTrie：记录当前周期的验证人列表</li>
<li>DelegateTrie：记录每个候选人对应的投票人，一个候选人有不同的投票人</li>
<li>VoteTrie：记录投票人对应的候选人，每个投票人只能对应一个候选人</li>
<li>MintCntTrie：记录验证人在当前周期内的出块数</li>
<li>CandidateTrie：候选人集合，其中包含了验证人</li>
</ol>
</li>
<li>epoch_context：dpos验证阶段的处理，图中可知，主要完成四部分内容：<ol>
<li>CountVotes:获取候选人及其对应投票数（积分）</li>
<li>KickoutValidator：踢除不合格的验证人</li>
<li>LookupValidator：获取当前验证人，就是确定应该由哪个验证人来出块</li>
<li>TryElec：发起新一轮选举，从候选人中选出验证人</li>
</ol>
</li>
<li>Dpos：实现共识引擎，dpos的主体</li>
</ol>
<p>来看看dpos算在在以太坊中的结构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|____params.go</span><br><span class="line">|____context</span><br><span class="line">| |____dpos_context.go</span><br><span class="line">| |____dpos_context_proto.go</span><br><span class="line">|____dpos_test.go</span><br><span class="line">|____api.go</span><br><span class="line">|____epoch_context_test.go</span><br><span class="line">|____epoch_context.go</span><br><span class="line">|____dpos.go</span><br></pre></td></tr></table></figure>
<p>正对应上面提到的3部分内容。</p>
<p>整个实现过程，小编也建议按照上面1、2、3的顺序来实现。下面小编就按照这个步骤来一一讲解。</p>
<h2 id="dpos-context和dpos-context-pro"><a href="#dpos-context和dpos-context-pro" class="headerlink" title="dpos_context和dpos_context_pro"></a>dpos_context和dpos_context_pro</h2><p>上面小编说过，dpos选举的数据信息都会以trie的形式保存在以太坊的leveldb之中。dpos_context和dpos_context_pro就是用来处理这一过程的。<br>就是说，这一过程是对trie树的操作过程<br>小编想要说的是dpos_context_pro是为了方便外部对接而通过gencodec将dpos_context自动转换生成的。也就是说真正的核心是dpos_context。<br>理解dpos_context.go中内容尤为重要。</p>
<p>先来看看结构体其结构体和重要参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	epochPrefix     = []<span class="keyword">byte</span>(<span class="string">&quot;epoch-&quot;</span>)</span><br><span class="line">	delegatePrefix  = []<span class="keyword">byte</span>(<span class="string">&quot;delegate-&quot;</span>)</span><br><span class="line">	votePrefix      = []<span class="keyword">byte</span>(<span class="string">&quot;vote-&quot;</span>)</span><br><span class="line">	candidatePrefix = []<span class="keyword">byte</span>(<span class="string">&quot;candidate-&quot;</span>)</span><br><span class="line">	mintCntPrefix   = []<span class="keyword">byte</span>(<span class="string">&quot;mintCnt-&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DposContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	EpochTrie     *trie.Trie <span class="comment">//记录每个周期的验证人列表</span></span><br><span class="line">	DelegateTrie  *trie.Trie <span class="comment">//记录候选人-&gt;投票人</span></span><br><span class="line">	VoteTrie      *trie.Trie <span class="comment">//记录投票人-&gt;候选人</span></span><br><span class="line">	CandidateTrie *trie.Trie <span class="comment">//记录候选人列表</span></span><br><span class="line">	MintCntTrie   *trie.Trie <span class="comment">//记录验证人在周期内的出块数目</span></span><br><span class="line"></span><br><span class="line">	db ethdb.Database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观，dpos的五个前缀，后续操作的数据将会在这些前缀之后保存，索引很容易找到结果。<br>以太坊trie树是一种kv类型对，上面提到的五种trie，具体数据是如下格式来保存：</p>
<ol>
<li>EpochTrie数据格式：<br>key：epoch-validator<br>value：xxxxxxxxxxxxxxx (<code>ps</code>：xxxxxxxxxxxxxxx表示经过rlp序列化的所有验证人地址)</li>
<li>DelegateTrie数据格式：<br>key：delegate-候选人地址-投票人地址<br>value：投票人地址</li>
<li>VoteTrie数据格式：<br>key：vote-投票人地址<br>value：候选人地址</li>
<li>CandidateTrie数据格式：<br>key：candidate-候选人地址<br>value；候选人地址</li>
<li>MintCntTrie数据格式：<br>key；mintCnt-周期数（2进制）-验证人<br>value：当前验证人本周期总共挖块数（2进制å）<br><code>ps</code>：此处是小编自己理解，可能不正确：<code>其中，第5个加入周期数的目的：若不加入周期数，则这五棵trie经过rlp生成的hash，每一轮有可能都一样，对其签名会造成很大困扰</code></li>
</ol>
<p>接着看看DposContext的几个重要方法：</p>
<h3 id="Copy-复制当前dpos状态"><a href="#Copy-复制当前dpos状态" class="headerlink" title="Copy():复制当前dpos状态"></a>Copy():复制当前dpos状态</h3><p>将当前DposContext对象复制出来，其实就是复制出当前Dpos状态，一般用于快照操作。拿到某时刻的状态。</p>
<h3 id="Snapshot-快照，同上"><a href="#Snapshot-快照，同上" class="headerlink" title="Snapshot():快照，同上"></a>Snapshot():快照，同上</h3><p>快照。其实就是调用了上面提到的Copy()方法。</p>
<h3 id="RevertToSnapShot-：快照读取"><a href="#RevertToSnapShot-：快照读取" class="headerlink" title="RevertToSnapShot()：快照读取"></a>RevertToSnapShot()：快照读取</h3><p>这个其实就是将快照信息转移到主体DposContext中，描述不好理解，贴代码，一目了然：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DposContext)</span> <span class="title">RevertToSnapShot</span><span class="params">(snapshot *DposContext)</span></span> &#123;</span><br><span class="line">	d.EpochTrie = snapshot.EpochTrie</span><br><span class="line">	d.DelegateTrie = snapshot.DelegateTrie</span><br><span class="line">	d.CandidateTrie = snapshot.CandidateTrie</span><br><span class="line">	d.VoteTrie = snapshot.VoteTrie</span><br><span class="line">	d.MintCntTrie = snapshot.MintCntTrie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KickoutCandidate-：踢除候选人"><a href="#KickoutCandidate-：踢除候选人" class="headerlink" title="KickoutCandidate()：踢除候选人"></a>KickoutCandidate()：踢除候选人</h3><p>该方法用于踢掉某个候选人（候选人有可能是验证人）<br>该方法在这里就不贴具体代码了，<br>删除某个候选人，需要涉及到三个trie：</p>
<ol>
<li>CandidateTrie：删掉对应候选人</li>
<li>DelegateTrie：删掉候选人何其对应的投票人</li>
<li>VoteTrie：删掉投票人对应的候选人</li>
</ol>
<p>从中也可以看出：<code>一个候选人可以有不同的投票人；一个投票人只能为一个候选人投票</code></p>
<h3 id="BecomeCandidate-：成为候选人"><a href="#BecomeCandidate-：成为候选人" class="headerlink" title="BecomeCandidate()：成为候选人"></a>BecomeCandidate()：成为候选人</h3><p>任何拥有以太坊账户的人，都可以成为候选人。<br>当然，真正线上的这一过程，是需要严格控制的。</p>
<h3 id="Delegate-：为某候选人投票"><a href="#Delegate-：为某候选人投票" class="headerlink" title="Delegate()：为某候选人投票"></a>Delegate()：为某候选人投票</h3><p>每轮选举，一个投票人只能为一个候选人投票，若该投票人已经为某候选人投票，想要再给新的候选人投票，则会覆盖原先旧的投票记录</p>
<h3 id="UnDelegate-：取消某投票人投票记录"><a href="#UnDelegate-：取消某投票人投票记录" class="headerlink" title="UnDelegate()：取消某投票人投票记录"></a>UnDelegate()：取消某投票人投票记录</h3><ol>
<li>判断投票人是否已经投过票，以及给谁投的票</li>
<li>投票人不是给候选人candidate投的票，则不可以做取消操作</li>
<li>将候选人对应投票人删除</li>
<li>将投票人对应候选人删除</li>
</ol>
<h3 id="GetValidators-：获取验证人列表"><a href="#GetValidators-：获取验证人列表" class="headerlink" title="GetValidators()：获取验证人列表"></a>GetValidators()：获取验证人列表</h3><p>获取当前验证人列表</p>
<h3 id="SetValidators-：设置当前验证人"><a href="#SetValidators-：设置当前验证人" class="headerlink" title="SetValidators()：设置当前验证人"></a>SetValidators()：设置当前验证人</h3><p>设置当前验证人</p>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ol>
<li>dpos_context和dpos_context_pro很容易让人感到凌乱，这是因为要跟别的模块交互的缘故，毕竟header只有hash，并没有具体块数据来支撑trie。<br>后期如何将两者融合，或者用新的解决方案来处理，这是需要考虑的一个问题。</li>
<li>整体的数据操作方法没问题，但并没有做太大约束，比如成为候选人的条件等，当然，这属于dpos细节设计过程，这需要自行根据需要来设计。</li>
</ol>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>这一部分的实现，小编没有给出具体源码，主要是考虑到篇幅，另外一个原因是实现本身并没有太复杂的逻辑。<br>定义了db中要存储的前缀和具体数据。这部分内容还是很容易理解的。<br>trie由于新增了前缀操作，为此做了一些改动，这个改动在本文最后给出。</p>
<h2 id="epoch-context"><a href="#epoch-context" class="headerlink" title="epoch_context"></a>epoch_context</h2><p>这一部分属于对验证人的操作过程，比如统计投票数、踢除不合格验证人等操作。属于dpos最重要的一部分。目前提供了以下几个方法，这里一一来详细说明</p>
<h3 id="CountVotes-统计投票数"><a href="#CountVotes-统计投票数" class="headerlink" title="CountVotes() 统计投票数"></a>CountVotes() 统计投票数</h3><p>一个候选人会拥有多个投票人，该方法目的就是统计出所有候选人中，每个候选人分别拥有多少投票数。<br>目前是这样进行统计的：</p>
<ol>
<li>通过candidateTrie获取所有候选人</li>
<li>通过delegateTrie检测某候选人是否有投票（备注：delegateTrie表示候选人对应的投票人，也就是只要检测该候选人是否有投票人即可）</li>
<li>一个候选人有多个投票人，将该候选人所有的投票人的账户余额相加的结果，就是当前候选人的投票数，比如每个投票人当前账户分别拥有1000wei，该候选人有5个投票人，则该候选人的投票数就是5000，将<code>候选人-&gt;投票数</code>记录在map</li>
<li>将map结果返回，其中就是所有候选人投票数</li>
</ol>
<h3 id="KickoutValidator-踢除不合格验证人"><a href="#KickoutValidator-踢除不合格验证人" class="headerlink" title="KickoutValidator() 踢除不合格验证人"></a>KickoutValidator() 踢除不合格验证人</h3><p>踢除当前周期内不合格的验证人，<br>如果一个周期内，一个验证人的出块数不够50%，则将其踢出。比如：一周期是24小时（86400秒），每隔10秒产生一个块，总共有21个验证人，则86400/10/21*0.5=206块，就是说，一个验证人一个周期生成的块数不足206块，则该验证人在新的一轮选举中被踢除。<br>要确保踢出验证人后，剩余的所有候选人的人数在一个安全阈值内，一般是要满足总验证人的2/3</p>
<h3 id="LookupValidator-获取当前验证人-也就是调度验证人"><a href="#LookupValidator-获取当前验证人-也就是调度验证人" class="headerlink" title="LookupValidator() 获取当前验证人,也就是调度验证人"></a>LookupValidator() 获取当前验证人,也就是调度验证人</h3><p>该方法是根据当前周期以及出块时间从验证人列表中选择一个正确的验证人。</p>
<h3 id="TryElect-开始选举验证人"><a href="#TryElect-开始选举验证人" class="headerlink" title="TryElect() 开始选举验证人"></a>TryElect() 开始选举验证人</h3><p>该过程用于从候选人中选择验证人。</p>
<ol>
<li>若上一个块的周期和当前块的周期不是同一周期，则触发选举 </li>
<li>获取上一周期验证人以及对应的出块数</li>
<li>踢除上一周期不合格的验证人</li>
<li>获取所有候选人及其对应的投票数，选择最高21位作为验证人</li>
<li>将21位验证人顺序随机打乱</li>
</ol>
<h3 id="不足之处-1"><a href="#不足之处-1" class="headerlink" title="不足之处"></a>不足之处</h3><p>候选人数量需要限制</p>
<h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>本小节主要是对验证人的操作，目的就是踢掉不合格的验证人，选择新的验证人。<br>这些都属于dpos内部逻辑。</p>
<h2 id="Dpos"><a href="#Dpos" class="headerlink" title="Dpos"></a>Dpos</h2><p>这个模块是用来实现以太坊共识引擎接口的。<br>需要知道，dpos中，不需要叔块概念、不需要难度概念。<br>先来看看Dpos的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dpos <span class="keyword">struct</span> &#123;</span><br><span class="line">	config *DposConfig</span><br><span class="line">	db     ethdb.Database <span class="comment">//存储验证人相关信息</span></span><br><span class="line"></span><br><span class="line">	signer common.Address <span class="comment">//打包人</span></span><br><span class="line">	signFn SignerFn</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ARCCache是一个线程安全的固定大小的自适应替换缓存工具。</span></span><br><span class="line">	<span class="comment">//ARC是对标准LRU缓存的一种改进，它跟踪使用的频率和最近情况。</span></span><br><span class="line">	<span class="comment">//这样就避免了对新条目的突然访问，无法将经常使用的旧条目逐出。</span></span><br><span class="line">	<span class="comment">//它为标准的LRU缓存增加了一些额外的跟踪开销，计算上它大约是成本的2倍，并且额外的内存开销与缓存的大小成线性关系。</span></span><br><span class="line">	<span class="comment">//ARC已获得IBM专利，但类似于需要设置参数的TwoQueueCache（2Q,双队列缓存).</span></span><br><span class="line">	signatures           *lru.ARCCache <span class="comment">//等待验签的块</span></span><br><span class="line">	confirmedBlockHeader *types.Header <span class="comment">//被确认了的块头部</span></span><br><span class="line">	mu   sync.RWMutex</span><br><span class="line">	stop <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的方法如下所示。</p>
<h3 id="VerifyHeader-验证头部"><a href="#VerifyHeader-验证头部" class="headerlink" title="VerifyHeader() 验证头部"></a>VerifyHeader() 验证头部</h3><p>验证块头部信息。<br>这里重要的一点是<code>header.Extra</code>数据，其中包含有ecp256k1签名信息，需要确保其中该信息。</p>
<h3 id="VerifySeal-验证块签名信息"><a href="#VerifySeal-验证块签名信息" class="headerlink" title="VerifySeal() 验证块签名信息"></a>VerifySeal() 验证块签名信息</h3><ol>
<li>创世块不验证</li>
<li>根据块的生成时间，获取该块的验证人地址，判断该验证人是否为块的签名人</li>
<li>另外重要的一点是：updateConfirmedBlockHeader()，这一步要更新待确认块的位置，让用户知道，当前哪些块被确认了，哪些块还没有。</li>
</ol>
<h3 id="Prepare-初始化准备"><a href="#Prepare-初始化准备" class="headerlink" title="Prepare() 初始化准备"></a>Prepare() 初始化准备</h3><p>对头部信息设置</p>
<h3 id="Finalize-奖励分发并进行新的选举"><a href="#Finalize-奖励分发并进行新的选举" class="headerlink" title="Finalize() 奖励分发并进行新的选举"></a>Finalize() 奖励分发并进行新的选举</h3><ol>
<li>为块生成者分发奖励</li>
<li>若父块和当前块是同一周期，则不选举；否则进行选举</li>
</ol>
<h3 id="Seal-打包签名"><a href="#Seal-打包签名" class="headerlink" title="Seal() 打包签名"></a>Seal() 打包签名</h3><p>对当前块进行签名<br>签名信息保存在header.extra中</p>
<h3 id="SealHash-返回head头部hash"><a href="#SealHash-返回head头部hash" class="headerlink" title="SealHash() 返回head头部hash"></a>SealHash() 返回head头部hash</h3><p>这个方法是用来生成一个块头部的hash，来看看源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dpos)</span> <span class="title">SealHash</span><span class="params">(header *types.Header)</span> <span class="params">(hash common.Hash)</span></span> &#123;</span><br><span class="line">	hasher := sha3.NewLegacyKeccak256()</span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Validator,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra[:<span class="built_in">len</span>(header.Extra)<span class="number">-65</span>], <span class="comment">//这里记录签名信息</span></span><br><span class="line">		header.MixDigest,</span><br><span class="line">		header.Nonce,</span><br><span class="line">		header.DposContext.Root(),</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用rlp编码，然后生成一个hash，这个就代表一个head，其中dpos部分，发现这样一行代码：<code>header.DposContext.Root()</code>，这表示dpos中的五棵trie被编码为一个hash存入其中。</p>
<h3 id="CheckValidator-检测验证人是否有效"><a href="#CheckValidator-检测验证人是否有效" class="headerlink" title="CheckValidator() 检测验证人是否有效"></a>CheckValidator() 检测验证人是否有效</h3><ol>
<li>上一个块和当前块时间是否正确</li>
<li>根据块当前时间获取验证人，然后跟header.signer比较是否一致</li>
</ol>
<h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>这一部分主要就是实现共识引擎的接口，相比较于pow，dpos的实现要容易很多</p>
<h2 id="trie数据存储"><a href="#trie数据存储" class="headerlink" title="trie数据存储"></a>trie数据存储</h2><p>以太坊的trie是什么东西，小编原先讲解过，并对其源码也做过深入分析<br>前面小编说过，dpos的五个trie是需要保存在db，以太坊原先的方式并不能满足这一需要，为此需要对现有的trie做一些改造。在现有trie模块的基础上，加入了如下两个文件：</p>
<ol>
<li>prefix_trie.go</li>
<li>prefix_trie_iterator.go</li>
</ol>
<h3 id="prefix-trie-go"><a href="#prefix-trie-go" class="headerlink" title="prefix_trie.go"></a>prefix_trie.go</h3><p>这个文件中是对Trie结构体方法的扩充，加入了前缀后，trie的更新插入等操作有了些许变化，代码不多，都贴出来了，这里就不做注释，很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrieWithPrefix</span><span class="params">(root common.Hash, prefix []<span class="keyword">byte</span>, db ethdb.Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</span><br><span class="line">	trie, err := New(root, NewDatabase(db))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	trie.prefix = prefix</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">NodeIteratorWithPrefix</span><span class="params">(start []<span class="keyword">byte</span>)</span> <span class="title">NodeIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		start = <span class="built_in">append</span>(t.prefix, start...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newNodeIterator(t, start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">PrefixIterator</span><span class="params">(prefix []<span class="keyword">byte</span>)</span> <span class="title">NodeIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		prefix = <span class="built_in">append</span>(t.prefix, prefix...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newPrefixIterator(t, prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">UpdateWithPrefix</span><span class="params">(key, value []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := t.TryUpdateWithPrefix(key, value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryUpdateWithPrefix</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	k := keybytesToHex(key)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(value) != <span class="number">0</span> &#123;</span><br><span class="line">		_, n, err := t.insert(t.root, <span class="literal">nil</span>, k, valueNode(value))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		t.root = n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		t.root = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">GetWithPrefix</span><span class="params">(key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	res, err := t.TryGetWithPrefix(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryGetWithPrefix</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	value, newroot, didResolve, err := t.tryGet(t.root, key, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">		t.root = newroot</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryDeleteWithPrefix</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.prefix != <span class="literal">nil</span> &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(t.prefix, key...)</span><br><span class="line">	&#125;</span><br><span class="line">	k := keybytesToHex(key)</span><br><span class="line">	_, n, err := t.<span class="built_in">delete</span>(t.root, <span class="literal">nil</span>, k)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	t.root = n</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prefix-trie-iterator-go"><a href="#prefix-trie-iterator-go" class="headerlink" title="prefix_trie_iterator.go"></a>prefix_trie_iterator.go</h3><p>对dpos各种trie需要进行遍历，而这个文件就是用来解决这一问题的。整个过程就是根据前缀来查找结果的。代码本身也不复杂，并且也不多，直接上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> prefixIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix       []<span class="keyword">byte</span></span><br><span class="line">	nodeIterator NodeIterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrefixIterator</span><span class="params">(trie *Trie, prefix []<span class="keyword">byte</span>)</span> <span class="title">NodeIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> trie.Hash() == emptyState &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(prefixIterator)</span><br><span class="line">	&#125;</span><br><span class="line">	nodeIt := newNodeIterator(trie, prefix)</span><br><span class="line">	prefix = keybytesToHex(prefix)</span><br><span class="line">	<span class="keyword">return</span> &amp;prefixIterator&#123;</span><br><span class="line">		nodeIterator: nodeIt,</span><br><span class="line">		prefix:       prefix[:<span class="built_in">len</span>(prefix)<span class="number">-1</span>],</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">hasPrefix</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.HasPrefix(it.nodeIterator.Path(), it.prefix)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Next</span><span class="params">(descend <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.nodeIterator.Next(descend) &#123;</span><br><span class="line">		<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> it.nodeIterator.Error()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Hash()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Parent</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		it.nodeIterator.Parent()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Path</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Path()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">Leaf</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.Leaf()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">LeafKey</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.LeafKey()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">LeafBlob</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> it.hasPrefix() &#123;</span><br><span class="line">		<span class="keyword">return</span> it.nodeIterator.LeafBlob()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *prefixIterator)</span> <span class="title">LeafProof</span><span class="params">()</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">//TODO 该方法暂时未用到</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>以太坊的理念是，每个功能都模块化，但是dpos的改造，将其中的内容都被扩散到不同的模块，耦合度过高。</li>
<li>本文中，更多描述的是dpos在以太坊共识模块中的实现，这个过程相对来说要好理解，但是，如果将以太坊切换为dpos，这才是工程中的难点，这个过程小编也正在验证，后续会发出新的文章来专门讲解这一过程。</li>
<li>补充一下，上面提到的每个模块，都有对应的单元测试，可以快速验证每个方法。</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第9讲-blockchain</title>
    <url>/articles/a749acc8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多条链分叉时候，如何选择？链中的块如何验证？每个块是如何组合的？怎样插入？还原？。。。<br>要理清这些问题，就必须了解<code>core-&gt;blockchain.go</code>其中的原理</p>
<a id="more"></a>
<p>这里代表的就是区块链的精髓，会牵涉到多个文件，我们一一来介绍。</p>
<h2 id="先来看blockchain结构体"><a href="#先来看blockchain结构体" class="headerlink" title="先来看blockchain结构体"></a>先来看blockchain结构体</h2><p>描述了一条链的结构，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//硬分叉的一些配置</span></span><br><span class="line">	chainConfig *params.ChainConfig</span><br><span class="line">	<span class="comment">//主要是trie节点的缓存配置，其中包括是否允许缓存、trie最多允许缓存的容量(MB)、缓存刷新到磁盘的时间</span></span><br><span class="line">	cacheConfig *CacheConfig       </span><br><span class="line">	<span class="comment">//用来存储最终数据的地方</span></span><br><span class="line">	db     ethdb.Database </span><br><span class="line">	<span class="comment">//根据块号优先级来对其中的trie树进行gc</span></span><br><span class="line">	triegc *prque.Prque</span><br><span class="line">	<span class="comment">// trie进行gc前的延时</span></span><br><span class="line">	gcproc time.Duration  </span><br><span class="line">	<span class="comment">//一条链的头部信息，这个是非线程安全的，具体后面再来分析</span></span><br><span class="line">	hc            *HeaderChain</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面几个个是一些事件，后面再来补充</span></span><br><span class="line">	rmLogsFeed    event.Feed</span><br><span class="line">	chainFeed     event.Feed</span><br><span class="line">	chainSideFeed event.Feed</span><br><span class="line">	chainHeadFeed event.Feed</span><br><span class="line">	logsFeed      event.Feed</span><br><span class="line">	scope         event.SubscriptionScope</span><br><span class="line">	<span class="comment">//创世区块</span></span><br><span class="line">	genesisBlock  *types.Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局的一个读写锁，用来锁定链的操作</span></span><br><span class="line">	mu      sync.RWMutex </span><br><span class="line">	<span class="comment">//插入锁</span></span><br><span class="line">	chainmu sync.RWMutex </span><br><span class="line">	<span class="comment">//待定</span></span><br><span class="line">	procmu  sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这些后面再来解释</span></span><br><span class="line">	checkpoint       <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//当前的区块头    </span></span><br><span class="line">	currentBlock     atomic.Value</span><br><span class="line">	<span class="comment">// 当前的快速同步的区块头. </span></span><br><span class="line">	currentFastBlock atomic.Value </span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理块和编码使用一些缓存</span></span><br><span class="line">	stateCache    state.Database </span><br><span class="line">	bodyCache     *lru.Cache     </span><br><span class="line">	bodyRLPCache  *lru.Cache     </span><br><span class="line">	receiptsCache *lru.Cache     </span><br><span class="line">	blockCache    *lru.Cache </span><br><span class="line">	<span class="comment">//暂时还不能插入的区块存放位置</span></span><br><span class="line">	futureBlocks  *lru.Cache     </span><br><span class="line"></span><br><span class="line">	<span class="comment">//链推出管道</span></span><br><span class="line">	quit    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">	<span class="comment">//原子操作，暂时不确定要干嘛</span></span><br><span class="line">	running <span class="keyword">int32</span> </span><br><span class="line">	<span class="comment">//用于中断块处理过程        </span></span><br><span class="line">	procInterrupt <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">//等待链的关闭          </span></span><br><span class="line">	wg            sync.WaitGroup </span><br><span class="line"></span><br><span class="line">	<span class="comment">//共识引擎</span></span><br><span class="line">	engine    consensus.Engine</span><br><span class="line">	<span class="comment">//用于处理块的接口</span></span><br><span class="line">	processor Processor </span><br><span class="line">	<span class="comment">//块和状态验证接口</span></span><br><span class="line">	validator Validator </span><br><span class="line">	vmConfig  vm.Config</span><br><span class="line"></span><br><span class="line">	<span class="comment">//错误块的缓存</span></span><br><span class="line">	badBlocks      *lru.Cache</span><br><span class="line">	<span class="comment">//一个方法，用来判断是否需要保留某个块              </span></span><br><span class="line">	shouldPreserve <span class="function"><span class="keyword">func</span><span class="params">(*types.Block)</span> <span class="title">bool</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链的构建过程"><a href="#链的构建过程" class="headerlink" title="链的构建过程"></a>链的构建过程</h2><p>生成一个全节点的链的入口，这是使用数据库里面的信息来构造的，来看看这个方法具体做了哪些内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">(db ethdb.Database, cacheConfig *CacheConfig, chainConfig *params.ChainConfig, engine consensus.Engine, vmConfig vm.Config, shouldPreserve <span class="keyword">func</span>(block *types.Block)</span> <span class="title">bool</span>) <span class="params">(*BlockChain, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cacheConfig == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//设置默认的缓存参数</span></span><br><span class="line">		cacheConfig = &amp;CacheConfig&#123;</span><br><span class="line">			<span class="comment">//默认节点256T</span></span><br><span class="line">			TrieNodeLimit: <span class="number">256</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">			<span class="comment">//将缓存刷新到磁盘的时间</span></span><br><span class="line">			TrieTimeLimit: <span class="number">5</span> * time.Minute,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化缓存</span></span><br><span class="line">	bodyCache, _ := lru.New(bodyCacheLimit)</span><br><span class="line">	bodyRLPCache, _ := lru.New(bodyCacheLimit)</span><br><span class="line">	receiptsCache, _ := lru.New(receiptsCacheLimit)</span><br><span class="line">	blockCache, _ := lru.New(blockCacheLimit)</span><br><span class="line">	futureBlocks, _ := lru.New(maxFutureBlocks)</span><br><span class="line">	badBlocks, _ := lru.New(badBlockLimit)</span><br><span class="line">	<span class="comment">//链结构体赋值</span></span><br><span class="line">	bc := &amp;BlockChain&#123;</span><br><span class="line">		chainConfig:    chainConfig,</span><br><span class="line">		cacheConfig:    cacheConfig,</span><br><span class="line">		db:             db,</span><br><span class="line">		triegc:         prque.New(<span class="literal">nil</span>),</span><br><span class="line">		stateCache:     state.NewDatabase(db),</span><br><span class="line">		quit:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		shouldPreserve: shouldPreserve,</span><br><span class="line">		bodyCache:      bodyCache,</span><br><span class="line">		bodyRLPCache:   bodyRLPCache,</span><br><span class="line">		receiptsCache:  receiptsCache,</span><br><span class="line">		blockCache:     blockCache,</span><br><span class="line">		futureBlocks:   futureBlocks,</span><br><span class="line">		engine:         engine,</span><br><span class="line">		vmConfig:       vmConfig,</span><br><span class="line">		badBlocks:      badBlocks,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置验证机制，这里会调用block_validator.go文件中的内容</span></span><br><span class="line">	bc.SetValidator(NewBlockValidator(chainConfig, bc, engine))</span><br><span class="line">	<span class="comment">//设置处理块机制，这里会调用state_processor.go文件中的内容</span></span><br><span class="line">	bc.SetProcessor(NewStateProcessor(chainConfig, bc, engine))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="comment">//链的头部，这块牵涉到headerchain.go文件</span></span><br><span class="line">	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创世块的设置</span></span><br><span class="line">	bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> bc.genesisBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoGenesis</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加载最新状态</span></span><br><span class="line">	<span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 手动检查链中是否有坏块，BadHashes中手动存入一些坏块地址，一般硬分叉使用</span></span><br><span class="line">	<span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//获取规范的区块链上面同样高度的区块头,</span></span><br><span class="line">			<span class="comment">//如果这个区块头确实是在我们的规范的区块链上的话,我们需要回滚到这个区块头的高度 - 1，此时高度为最新块</span></span><br><span class="line">			<span class="comment">//要确保规范块里没有坏块（硬分叉的块、非法块）</span></span><br><span class="line">			<span class="comment">//header.Number指向当前最新块</span></span><br><span class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</span><br><span class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Found bad hash, rewinding chain&quot;</span>, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.ParentHash)</span><br><span class="line">				<span class="comment">//会一直往上一个块回滚，直到稳定</span></span><br><span class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>) </span><br><span class="line">				log.Error(<span class="string">&quot;Chain rewind was successful, resuming normal operation&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//异步，将未来块（就是还在缓存中暂时没加入的块）加入到规范链中</span></span><br><span class="line">	<span class="comment">//其中会涉及到一个块的插入概念</span></span><br><span class="line">	<span class="keyword">go</span> bc.update() </span><br><span class="line">	<span class="keyword">return</span> bc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面最重要的几个部分：</p>
<ol>
<li>坏块的检查，</li>
<li>是从db中加载最新状态的过程，也就是<code>bc.loadLastState()</code>这个方法，</li>
<li>块的插入，<code>InsertChain()</code>方法</li>
</ol>
<p>接下来一一介绍这几部分内容</p>
<h3 id="坏块的检查"><a href="#坏块的检查" class="headerlink" title="坏块的检查"></a>坏块的检查</h3><p>BadHashes 可以手工禁止接受一些区块的hash值.在blocks.go里面.<br>可以避免一些硬分叉问题，保证链的正统性。</p>
<h3 id="bc-loadLastState-加载最新状态"><a href="#bc-loadLastState-加载最新状态" class="headerlink" title="bc.loadLastState()加载最新状态"></a>bc.loadLastState()加载最新状态</h3><p>从db中加载链的最新状态，这部分代码量也非常大，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">loadLastState</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取最新一个块的hash头部</span></span><br><span class="line">	head := rawdb.ReadHeadBlockHash(bc.db)</span><br><span class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Empty database, resetting chain&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset() <span class="comment">//使用创世块初始化链</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据块的hash获取当前块</span></span><br><span class="line">	currentBlock := bc.GetBlockByHash(head)</span><br><span class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Head block missing, resetting chain&quot;</span>, <span class="string">&quot;hash&quot;</span>, head)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset() <span class="comment">//使用创世块初始化链</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 看当前块的hash和db中记录能否联系上，不能则一直回滚</span></span><br><span class="line">	<span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Head state missing, repairing chain&quot;</span>, <span class="string">&quot;number&quot;</span>, currentBlock.Number(), <span class="string">&quot;hash&quot;</span>, currentBlock.Hash())</span><br><span class="line">		<span class="comment">//repair，会一直回滚，直到能够获取到状态的树</span></span><br><span class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置最新块</span></span><br><span class="line">	bc.currentBlock.Store(currentBlock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置当前链head</span></span><br><span class="line">	currentHeader := currentBlock.Header()</span><br><span class="line">	<span class="keyword">if</span> head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(head); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			currentHeader = header</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bc.hc.SetCurrentHeader(currentHeader)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置轻量级的块</span></span><br><span class="line">	bc.currentFastBlock.Store(currentBlock)</span><br><span class="line">	<span class="keyword">if</span> head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">if</span> block := bc.GetBlockByHash(head); block != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.currentFastBlock.Store(block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 日志展示</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InsertChain-，块的插入"><a href="#InsertChain-，块的插入" class="headerlink" title="InsertChain()，块的插入"></a>InsertChain()，块的插入</h3><p>插入区块链尝试把给定的区块插入到规范的链条,或者是创建一个分叉. 如果发生错误,那么会返回错误发生时候的index和具体的错误信息.<br>先来看插入块的入口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个总的方法，分为两部分，一部分用于插入多个块，</span></span><br><span class="line"><span class="comment">//另一部分属于累计的事件，将会被触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">InsertChain</span><span class="params">(chain types.Blocks)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n, events, logs, err := bc.insertChain(chain)</span><br><span class="line">	bc.PostChainEvents(events, logs)</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入部分的实现，这部分代码量有点大，但必须理解（插入的块必须连续）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertChain方法会执行区块链插入,并收集事件信息. 因为需要使用defer来处理解锁,所以把这个方法作为一个单独的方法.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">insertChain</span><span class="params">(chain types.Blocks)</span> <span class="params">(<span class="keyword">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(chain) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 做一个完整性检查，提供的链实际上是有序的和相互链接的</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(chain); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> chain[i].NumberU64() != chain[i<span class="number">-1</span>].NumberU64()+<span class="number">1</span> || chain[i].ParentHash() != chain[i<span class="number">-1</span>].Hash() &#123;</span><br><span class="line">			<span class="comment">//不满足基本规范，直接返回</span></span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;为节省篇幅，这个描述改动。表示：链不规范&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 锁机制</span></span><br><span class="line">	bc.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> bc.wg.Done()</span><br><span class="line"></span><br><span class="line">	bc.chainmu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> bc.chainmu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用队列来处理事件，这效果通常比用互斥锁的机制要快很多</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		<span class="comment">//起始时间，以太坊使用mclock.Now()来计算程序执行时间，这个更加精确</span></span><br><span class="line">		stats         = insertStats&#123;startTime: mclock.Now()&#125;  </span><br><span class="line">		<span class="comment">//事件长度和待加入的块数一致</span></span><br><span class="line">		events        = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(chain))</span><br><span class="line">		lastCanon     *types.Block</span><br><span class="line">		coalescedLogs []*types.Log</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//先检测这些块的合法性</span></span><br><span class="line">	headers := <span class="built_in">make</span>([]*types.Header, <span class="built_in">len</span>(chain))</span><br><span class="line">	seals := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(chain))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</span><br><span class="line">		headers[i] = block.Header()</span><br><span class="line">		seals[i] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(abort)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这行不太理解，这是新版加入的一行代码，原先是没有的，可能是减少分叉带来的一些问题吧</span></span><br><span class="line">	<span class="comment">// 从一批块中恢复发件人，并将它们缓存回相同的数据结构中。</span></span><br><span class="line">	<span class="comment">// 没有进行验证，也没有对无效签名作出任何反应。这取决于稍后调用代码。</span></span><br><span class="line">	<span class="comment">// 签名人会在分叉转换上碰碰运气。为避免问题，将所有交易都打上同一个签名？</span></span><br><span class="line">	senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[<span class="number">0</span>].Number()), chain)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理每个块</span></span><br><span class="line">	<span class="keyword">for</span> i, block := <span class="keyword">range</span> chain &#123;</span><br><span class="line">		<span class="comment">// 如果这些块正在终止，则停止往后执行</span></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;bc.procInterrupt) == <span class="number">1</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Premature abort during blocks processing&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有坏块，则停止处理之后的每个块，估计是尝试硬分叉吧</span></span><br><span class="line">		<span class="keyword">if</span> BadHashes[block.Hash()] &#123;</span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, ErrBlacklistedHash)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, ErrBlacklistedHash</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开始验证块</span></span><br><span class="line">		bstart := time.Now()</span><br><span class="line">		<span class="comment">//结果输出</span></span><br><span class="line">		err := &lt;-results</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//验证块</span></span><br><span class="line">			err = bc.Validator().ValidateBody(block)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err == ErrKnownBlock:</span><br><span class="line">			<span class="comment">//如果待插入的块比当前块的块号小，则忽略</span></span><br><span class="line">			<span class="keyword">if</span> bc.CurrentBlock().NumberU64() &gt;= block.NumberU64() &#123;</span><br><span class="line">				stats.ignored++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrFutureBlock:</span><br><span class="line">			<span class="comment">//如果该块的时间超过了当前时间+30s，则返回错误日志</span></span><br><span class="line">			max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)</span><br><span class="line">			<span class="keyword">if</span> block.Time().Cmp(max) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> i, events, coalescedLogs, fmt.Errorf(<span class="string">&quot;future block: %v &gt; %v&quot;</span>, block.Time(), max)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//若满足要求，则放入futureBlocks中，等待后续处理</span></span><br><span class="line">			bc.futureBlocks.Add(block.Hash(), block)</span><br><span class="line">			stats.queued++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrUnknownAncestor &amp;&amp; bc.futureBlocks.Contains(block.ParentHash()):</span><br><span class="line">		<span class="comment">//块祖先不确定，并且缓存中有该块，则更新</span></span><br><span class="line">			bc.futureBlocks.Add(block.Hash(), block)</span><br><span class="line">			stats.queued++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err == consensus.ErrPrunedAncestor:<span class="comment">//块状态无效，状态树问题</span></span><br><span class="line">			currentBlock := bc.CurrentBlock()</span><br><span class="line">			<span class="comment">//当前链的总难度</span></span><br><span class="line">			localTd := bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line">			<span class="comment">//新的链的总难度</span></span><br><span class="line">			externTd := <span class="built_in">new</span>(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>), block.Difficulty())</span><br><span class="line">			<span class="comment">//如果当前链难度大于新的链的难度，则将其加入db</span></span><br><span class="line">			<span class="keyword">if</span> localTd.Cmp(externTd) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//这是用来构造竞争的分叉，直到他们超过了标准的总难度。</span></span><br><span class="line">				<span class="keyword">if</span> err = bc.WriteBlockWithoutState(block, externTd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> winner []*types.Block</span><br><span class="line">			<span class="comment">//获取block的父块</span></span><br><span class="line">			parent := bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">			<span class="comment">//检查状态trie是否完全存在于数据库中。</span></span><br><span class="line">			<span class="comment">//parent.Root表示的是状态树（账户），并不是每个块都有状态</span></span><br><span class="line">			<span class="keyword">for</span> !bc.HasState(parent.Root()) &#123;</span><br><span class="line">				winner = <span class="built_in">append</span>(winner, parent)</span><br><span class="line">				parent = bc.GetBlock(parent.ParentHash(), parent.NumberU64()<span class="number">-1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//有状态树的被放在第一个，</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(winner)/<span class="number">2</span>; j++ &#123;</span><br><span class="line">				winner[j], winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j] = winner[<span class="built_in">len</span>(winner)<span class="number">-1</span>-j], winner[j]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将该组block加入</span></span><br><span class="line">			bc.chainmu.Unlock()</span><br><span class="line">			_, evs, logs, err := bc.insertChain(winner)</span><br><span class="line">			bc.chainmu.Lock()</span><br><span class="line">			events, coalescedLogs = evs, logs</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">//其余错误直接返回日志</span></span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取父块</span></span><br><span class="line">		<span class="keyword">var</span> parent *types.Block</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			parent = bc.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			parent = chain[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回一个状态树</span></span><br><span class="line">		state, err := state.New(parent.Root(), bc.stateCache)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用状态树处理待加入的块</span></span><br><span class="line">		receipts, logs, usedGas, err := bc.processor.Process(block, state, bc.vmConfig)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.reportBlock(block, receipts, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 验证待加入的块的状态信息</span></span><br><span class="line">		err = bc.Validator().ValidateState(block, parent, state, receipts, usedGas)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bc.reportBlock(block, receipts, err)</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理截止时间</span></span><br><span class="line">		proctime := time.Since(bstart)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 写入区块和状态</span></span><br><span class="line">		status, err := bc.WriteBlockWithState(block, receipts, state)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, events, coalescedLogs, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> CanonStatTy: <span class="comment">//插入了新区块</span></span><br><span class="line">			log.Debug(<span class="string">&quot;Inserted new block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash(), <span class="string">&quot;uncles&quot;</span>, <span class="built_in">len</span>(block.Uncles()),</span><br><span class="line">				<span class="string">&quot;txs&quot;</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">&quot;gas&quot;</span>, block.GasUsed(), <span class="string">&quot;elapsed&quot;</span>, common.PrettyDuration(time.Since(bstart)))</span><br><span class="line"></span><br><span class="line">			coalescedLogs = <span class="built_in">append</span>(coalescedLogs, logs...)</span><br><span class="line">			blockInsertTimer.UpdateSince(bstart)</span><br><span class="line">			events = <span class="built_in">append</span>(events, ChainEvent&#123;block, block.Hash(), logs&#125;)</span><br><span class="line">			lastCanon = block</span><br><span class="line"></span><br><span class="line">			bc.gcproc += proctime</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SideStatTy:  <span class="comment">// 插入了一个forked 区块</span></span><br><span class="line">			log.Debug(<span class="string">&quot;Inserted forked block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash(), <span class="string">&quot;diff&quot;</span>, block.Difficulty(), <span class="string">&quot;elapsed&quot;</span>,</span><br><span class="line">				common.PrettyDuration(time.Since(bstart)), <span class="string">&quot;txs&quot;</span>, <span class="built_in">len</span>(block.Transactions()), <span class="string">&quot;gas&quot;</span>, block.GasUsed(), <span class="string">&quot;uncles&quot;</span>, <span class="built_in">len</span>(block.Uncles()))</span><br><span class="line"></span><br><span class="line">			blockInsertTimer.UpdateSince(bstart)</span><br><span class="line">			events = <span class="built_in">append</span>(events, ChainSideEvent&#123;block&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		stats.processed++</span><br><span class="line">		stats.usedGas += usedGas</span><br><span class="line"></span><br><span class="line">		cache, _ := bc.stateCache.TrieDB().Size()</span><br><span class="line">		stats.report(chain, i, cache)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 事件加入</span></span><br><span class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</span><br><span class="line">		events = <span class="built_in">append</span>(events, ChainHeadEvent&#123;lastCanon&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, events, coalescedLogs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中牵涉到两个重要的方法：<code>WriteBlockWithState()</code>以及<code>reorg()</code>，建议也去阅读下，里面会具体判断应该使用哪条链。难度高的和难度低的链如何处理等问题。时间和精力有限，本文暂时就分析到这里。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分，链的初始化，其中加入了大量的检测，最终目的就是要有一个规范的链生成，当出现异常块时，会一直往前回滚，直到找到正常的块为止。也就是找一个最新的正常块。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第8讲-块(block)</title>
    <url>/articles/10e60082/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>块</code>贯穿了这个区块链的始终，前面的几篇文章总讲到块的生成，但具体到底怎么一回事，一直没提。<br>因此，小编认为还是有必要把一个block的细节梳理一下，本文主要是讲<code>core-&gt;types-&gt;block.go</code>文件中的内容。</p>
<a id="more"></a>
<p>先来看看一个块有哪些内容：<br> <br> 从图中，我们大体将一个块分为两部分，左半部分为Head，又半部分为Body.<br> Header相对轻量，涵盖了Block的所有属性，包括特征标示，前向指针，和内部数据集的验证哈希值等；body相对重量，持有内部数据集。每个Block的Header部分，Body部分，以及一些特征属性，都以[k,v]形式单独存储在底层数据库中。</p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>上面大概提到Body中有两部分内容，但真实的实现中，还有一些别的内容，如下结构。</p>

<p>下面是一个完整块的结构体描述，我们来看看一个块中具体到底有哪些内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//头部</span></span><br><span class="line">	header       *Header</span><br><span class="line">	<span class="comment">//叔块</span></span><br><span class="line">	uncles       []*Header</span><br><span class="line">	<span class="comment">//交易信息</span></span><br><span class="line">	transactions Transactions</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存数据操作</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line"></span><br><span class="line">	<span class="comment">//难度值相关，具体使用不明确，后面再来补坑</span></span><br><span class="line">	td *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内部使用，暂不明确，后面再来补坑</span></span><br><span class="line">	ReceivedAt   time.Time</span><br><span class="line">	ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第一种生成块的方式"><a href="#第一种生成块的方式" class="headerlink" title="第一种生成块的方式"></a>第一种生成块的方式</h3><p>根据传入信息生成一个完整块，<br>这里会看到交易树和收据树的处理，而状态树是在header中生成一个roothash，这个有兴趣可以单独去看，后面涉及到再专门去讲。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入的header信息会随着传入的txs和receipts发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="comment">//可以看出此处是拷贝的一个header，而td直接为0</span></span><br><span class="line">	b := &amp;Block&#123;header: CopyHeader(header), td: <span class="built_in">new</span>(big.Int)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(txs) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.TxHash = EmptyRootHash <span class="comment">//空的hash,rlp空的时候生成的</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//这里可以看出，只要有一笔交易被篡改，交易树的hash就会变</span></span><br><span class="line">		b.header.TxHash = DeriveSha(Transactions(txs)) <span class="comment">//根据传入的信息生成交易树的hash，</span></span><br><span class="line">		b.transactions = <span class="built_in">make</span>(Transactions, <span class="built_in">len</span>(txs)) </span><br><span class="line">		<span class="built_in">copy</span>(b.transactions, txs)<span class="comment">//具体的交易信息保存在块中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(receipts) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = EmptyRootHash <span class="comment">//收据树，空的hash,rlp空的时候生成的</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = DeriveSha(Receipts(receipts)) <span class="comment">//收据树列表hash</span></span><br><span class="line">		b.header.Bloom = CreateBloom(receipts) <span class="comment">//根据收据树生成一个布隆过滤器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(uncles) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.UncleHash = EmptyUncleHash</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.UncleHash = CalcUncleHash(uncles) <span class="comment">//将所有叔块生成一个hash</span></span><br><span class="line">		b.uncles = <span class="built_in">make</span>([]*Header, <span class="built_in">len</span>(uncles))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">			b.uncles[i] = CopyHeader(uncles[i]) <span class="comment">//拷贝叔块</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种生成块的方式"><a href="#第二种生成块的方式" class="headerlink" title="第二种生成块的方式"></a>第二种生成块的方式</h3><p>这种方式只是传入了header信息，区别于第一种：第一种会传入txs,receipts，会随着这些信息的变化，header发生变换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockWithHeader</span><span class="params">(header *Header)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Block&#123;header: CopyHeader(header)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block的相关方法"><a href="#block的相关方法" class="headerlink" title="block的相关方法"></a>block的相关方法</h3><p>列出目前还没被废弃的方法。</p>
<h4 id="序列化相关的两个方法：DecodeRLP和EncodeRLP"><a href="#序列化相关的两个方法：DecodeRLP和EncodeRLP" class="headerlink" title="序列化相关的两个方法：DecodeRLP和EncodeRLP"></a>序列化相关的两个方法：DecodeRLP和EncodeRLP</h4><p>该方法将解码rlp字节流，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">DecodeRLP</span><span class="params">(s *rlp.Stream)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//extblock结构体是用来存储解析结果的，其中包括header、uncles、transacitions</span></span><br><span class="line">	<span class="keyword">var</span> eb extblock </span><br><span class="line">	_, size, _ := s.Kind()</span><br><span class="line">	<span class="keyword">if</span> err := s.Decode(&amp;eb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	b.header, b.uncles, b.transactions = eb.Header, eb.Uncles, eb.Txs</span><br><span class="line">	b.size.Store(common.StorageSize(rlp.ListSize(size)))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法将一个block进行rlp序列化，不解释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rlp.Encode(w, extblock&#123;</span><br><span class="line">		Header: b.header,</span><br><span class="line">		Txs:    b.transactions,</span><br><span class="line">		Uncles: b.uncles,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h4><p>主要都是用来对外展示块信息，都是比较基础的方法，很好理解，先不要太过深的考虑每个方法什么地方使用，当梳理完这些内容后，心里自然会有底。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回叔块信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Uncles</span><span class="params">()</span> []*<span class="title">Header</span></span>          &#123; <span class="keyword">return</span> b.uncles &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示交易信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Transactions</span><span class="params">()</span> <span class="title">Transactions</span></span> &#123; <span class="keyword">return</span> b.transactions &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的hash返回其对应的交易信息，这个就是用来展示某交易是否在当前块中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Transaction</span><span class="params">(hash common.Hash)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, transaction := <span class="keyword">range</span> b.transactions &#123;</span><br><span class="line">		<span class="keyword">if</span> transaction.Hash() == hash &#123;</span><br><span class="line">			<span class="keyword">return</span> transaction</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块所在高度（*big.Int形式返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Number</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span>     &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Number) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块所在高度（uint64形式返回）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">NumberU64</span><span class="params">()</span> <span class="title">uint64</span></span>        &#123; <span class="keyword">return</span> b.header.Number.Uint64() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前块的总gas上限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">GasLimit</span><span class="params">()</span> <span class="title">uint64</span></span>     &#123; <span class="keyword">return</span> b.header.GasLimit &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前实际使用了的gas</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">GasUsed</span><span class="params">()</span> <span class="title">uint64</span></span>      &#123; <span class="keyword">return</span> b.header.GasUsed &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前块的难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Difficulty</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Difficulty) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前块的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Time</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span>       &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(b.header.Time) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来计算难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">MixDigest</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span>   &#123; <span class="keyword">return</span> b.header.MixDigest &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来计算难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Nonce</span><span class="params">()</span> <span class="title">uint64</span></span>            &#123; <span class="keyword">return</span> binary.BigEndian.Uint64(b.header.Nonce[:]) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布隆过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Bloom</span><span class="params">()</span> <span class="title">Bloom</span></span>             &#123; <span class="keyword">return</span> b.header.Bloom &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挖出当前块的账户地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Coinbase</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Address</span></span> &#123; <span class="keyword">return</span> b.header.Coinbase &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Root</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span>        &#123; <span class="keyword">return</span> b.header.Root &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">ParentHash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span>  &#123; <span class="keyword">return</span> b.header.ParentHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交易树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">TxHash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span>      &#123; <span class="keyword">return</span> b.header.TxHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收据树的根hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">ReceiptHash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123; <span class="keyword">return</span> b.header.ReceiptHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叔块的hash，这是由两个叔块数据生成的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">UncleHash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span>   &#123; <span class="keyword">return</span> b.header.UncleHash &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//额外的一些数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Extra</span><span class="params">()</span> []<span class="title">byte</span></span>            &#123; <span class="keyword">return</span> common.CopyBytes(b.header.Extra) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前块头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Header</span><span class="params">()</span> *<span class="title">Header</span></span> &#123; <span class="keyword">return</span> CopyHeader(b.header) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块的body，body主要就是交易和叔块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Body</span><span class="params">()</span> *<span class="title">Body</span></span> &#123; <span class="keyword">return</span> &amp;Body&#123;b.transactions, b.uncles&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前块的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">common</span>.<span class="title">StorageSize</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size := b.size.Load(); size != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> size.(common.StorageSize)</span><br><span class="line">	&#125;</span><br><span class="line">	c := writeCounter(<span class="number">0</span>)</span><br><span class="line">	rlp.Encode(&amp;c, b)</span><br><span class="line">	b.size.Store(common.StorageSize(c))</span><br><span class="line">	<span class="keyword">return</span> common.StorageSize(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共识算法校验一个块的时候会用到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">WithSeal</span><span class="params">(header *Header)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	cpy := *header</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Block&#123;</span><br><span class="line">		header:       &amp;cpy,</span><br><span class="line">		transactions: b.transactions,</span><br><span class="line">		uncles:       b.uncles,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">WithBody</span><span class="params">(transactions []*Transaction, uncles []*Header)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	block := &amp;Block&#123;</span><br><span class="line">		header:       CopyHeader(b.header),</span><br><span class="line">		transactions: <span class="built_in">make</span>([]*Transaction, <span class="built_in">len</span>(transactions)),</span><br><span class="line">		uncles:       <span class="built_in">make</span>([]*Header, <span class="built_in">len</span>(uncles)),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(block.transactions, transactions)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">		block.uncles[i] = CopyHeader(uncles[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个块的hash</span></span><br><span class="line"><span class="comment">//第一次调用时候计算，之后会被缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> hash := b.hash.Load(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hash.(common.Hash)</span><br><span class="line">	&#125;</span><br><span class="line">	v := b.header.Hash()</span><br><span class="line">	b.hash.Store(v)</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>介绍完整个块的大体情况后，接着来详细看看块内部的内容，先来看header</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>来看看一个块的head中都有哪些：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 指向父区块(parentBlock)的指针。除了创世块(Genesis Block)外，每个区块有且只有一个父区块。</span></span><br><span class="line">	ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组，它的存在，颇具匠心。</span></span><br><span class="line">	UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挖掘出这个区块的作者地址。在每次执行交易时系统会给与一定补偿的Ether，这笔金额就是发给这个地址的。</span></span><br><span class="line">	Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//StateDB中的“state Trie”的根节点的RLP哈希值。Block中，每个账户以stateObject对象表示，账户以Address为唯一标示，其信息在相关交易(Transaction)的执行中被修改。所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构里，形成“state Trie”。</span></span><br><span class="line">	Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Block中 交易树的根hash，由所有的交易生成的。“tx Trie”的根节点的RLP哈希值。Block的成员变量transactions中所有的tx对象，被逐个插入一个MPT结构，形成“tx Trie”。</span></span><br><span class="line">	TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//收据树。可以用来确认一笔交易成功与否，Block中的 “Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，形成”Receipt Trie”。</span></span><br><span class="line">	ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//布隆过滤器，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。</span></span><br><span class="line">	Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，它会应用在区块的‘挖掘’阶段。</span></span><br><span class="line">	Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//块号 Block的Number等于其父区块Number +1。</span></span><br><span class="line">	Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区块内所有Gas消耗的理论上限。该数值在区块创建时设置，与父区块有关。具体来说，根据父区块的GasUsed同GasLimit * 2/3的大小关系来计算得出。</span></span><br><span class="line">	GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块内所有Transaction执行时所实际消耗的Gas总和。</span></span><br><span class="line">	GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块“应该”被创建的时间。由共识算法确定，一般来说，要么等于parentBlock.Time + 15s，要么等于当前系统时间。</span></span><br><span class="line">	Time        *big.Int       <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//区块相关的附加信息</span></span><br><span class="line">	Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//该哈希值与Nonce值一起能够证明在该区块上已经进行了足够的计算（用于验证该区块挖矿成功与否的Hash值</span></span><br><span class="line">	MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一个64bit的哈希数，它被应用在区块的”挖掘”阶段，并且在使用中会被修改。</span></span><br><span class="line">	Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>gencodec</code>不是本文重点，有兴趣的可以单独去了解下这是什么，其实它主要就是扩展json的使用。</p>
<p><code>Root</code>，<code>TxHash</code>和<code>ReceiptHash</code>，分别取自三个MPT对象：<code>stateTrie</code>, <code>txTrie</code>, 和<code>receiptTrie</code>的根节点哈希值。 分别理解为是：<code>账户状态树</code>、<code>交易树</code>、<code>收据树</code><br>receiptTrie 必须在Block的所有交易执行完成才能生成；txTrie 理论上只需tx数组transactions即可，不过依然被限制在所有交易执行完后才生成；最有趣的是stateTrie，由于它存储了所有账户的信息，比如余额，发起交易次数，虚拟机指令数组等等，所以随着每次交易的执行，stateTrie 其实一直在变化，这就使得Root值也在变化中</p>
<blockquote>
<p><a href="https://blog.csdn.net/niyuelin1990/article/details/80423823">以太坊系列—Block核心数据结构</a></p>
</blockquote>
<h3 id="header对应的方法"><a href="#header对应的方法" class="headerlink" title="header对应的方法"></a>header对应的方法</h3><p>只有两个方法</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash()"></a>Hash()</h4><p>该方法主要是将头部内容生成一个hash，过程是：先将头部rlp序列化，再用keccak256将其生成一个32位的hash值，这是该方法的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Header)</span> <span class="title">Hash</span><span class="params">()</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	<span class="comment">//rlpHash方法就是为了实现：将头部rlp序列化，再用keccak256将其生成一个32位的hash值</span></span><br><span class="line">	<span class="keyword">return</span> rlpHash(h) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Size"><a href="#Size" class="headerlink" title="Size()"></a>Size()</h4><p>该方法用于近似的估算和限制各种缓存的消耗，主要是计算结构体中，指针类型数据的消耗<br>func (h *Header) Size() common.StorageSize {<br>    return common.StorageSize(unsafe.Sizeof(*h)) + common.StorageSize(len(h.Extra)+(h.Difficulty.BitLen()+h.Number.BitLen()+h.Time.BitLen())/8)<br>}</p>
<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p>body是一个简单的(可变的、不安全的)数据容器，用于存储和移动区块的数据内容(交易列表和叔块)在一起<br>可以理解成是一个中间载体，通过前面的描述应该可以理解，这是一个块的核心部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//交易记录</span></span><br><span class="line">	Transactions []*Transaction</span><br><span class="line">	<span class="comment">//叔块信息</span></span><br><span class="line">	Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块的排序"><a href="#块的排序" class="headerlink" title="块的排序"></a>块的排序</h2><p>block.go中的最后一部分内容就是这个块排序了，代码写的有点绕，但细看以下还是很容易理解的，主要就是根据块号的大小进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Blocks []*Block</span><br><span class="line"><span class="keyword">type</span> BlockBy <span class="function"><span class="keyword">func</span><span class="params">(b1, b2 *Block)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self BlockBy)</span> <span class="title">Sort</span><span class="params">(blocks Blocks)</span></span> &#123;</span><br><span class="line">	bs := blockSorter&#123;</span><br><span class="line">		blocks: blocks,</span><br><span class="line">		by:     self,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> blockSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	blocks Blocks</span><br><span class="line">	by     <span class="function"><span class="keyword">func</span><span class="params">(b1, b2 *Block)</span> <span class="title">bool</span> //使用哪种方式进行拍讯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写了排序的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(self.blocks) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	self.blocks[i], self.blocks[j] = self.blocks[j], self.blocks[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self blockSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> self.by(self.blocks[i], self.blocks[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Number</span><span class="params">(b1, b2 *Block)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> b1.header.Number.Cmp(b2.header.Number) &lt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章一个目的，了解一个块里到底有什么东西啊，这个块是怎么划分的，了解了这些，我们才能进一步往下走。<br>最起码要知道，一个块里有三种类型的MPT，一个交易树、一个收据树、一个状态树（具体干嘛，前面都有解释）。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第7讲-创世块</title>
    <url>/articles/85deafe/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创世块是以太坊的第一个块，随着逐步对以太坊的了解，越来越发现应该关注一下这些地方细节上的实现了。</p>
<a id="more"></a>
<p>创世块的文件在这里：<code>core-&gt;genesis.go</code>，这里定义了整个创世块的规则，本文主要就是分析这个文件。</p>
<h2 id="配置文件的结构体"><a href="#配置文件的结构体" class="headerlink" title="配置文件的结构体"></a>配置文件的结构体</h2><p>进去<code>core-&gt;genesis.go</code>这个文件，咋一看感觉有点乱，抽丝剥茧后，小编整理出下面的几个结构体，它们就是创世块的整个初始化原型。<br>这些结构体中的字段，都是用来直接解析<code>*.json</code>配置文件的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Genesis <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//这个Config主要是配置chainID以及共识相关（pow和pos），还有一些硬分叉信息，在此就不列出来了</span></span><br><span class="line">    <span class="comment">//chainID是一个标示，1标示以太坊公网，测试时，建议设置别的</span></span><br><span class="line">    Config     *params.ChainConfig <span class="string">`json:&quot;config&quot;`</span></span><br><span class="line">    <span class="comment">//随机值</span></span><br><span class="line">	Nonce      <span class="keyword">uint64</span>              <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">	Timestamp  <span class="keyword">uint64</span>              <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">	ExtraData  []<span class="keyword">byte</span>              <span class="string">`json:&quot;extraData&quot;`</span></span><br><span class="line">	GasLimit   <span class="keyword">uint64</span>              <span class="string">`json:&quot;gasLimit&quot;   gencodec:&quot;required&quot;`</span></span><br><span class="line">	Difficulty *big.Int            <span class="string">`json:&quot;difficulty&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	Mixhash    common.Hash         <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">    Coinbase   common.Address      <span class="string">`json:&quot;coinbase&quot;`</span></span><br><span class="line">    <span class="comment">//加入一些账户，以太坊启动后就能直接用这几个账户</span></span><br><span class="line">	Alloc      GenesisAlloc        <span class="string">`json:&quot;alloc&quot;      gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下面这三个是用来测试使用的</span></span><br><span class="line">	Number     <span class="keyword">uint64</span>      <span class="string">`json:&quot;number&quot;`</span></span><br><span class="line">	GasUsed    <span class="keyword">uint64</span>      <span class="string">`json:&quot;gasUsed&quot;`</span></span><br><span class="line">	ParentHash common.Hash <span class="string">`json:&quot;parentHash&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于将账户追加到以太坊中，方便直接使用</span></span><br><span class="line"><span class="keyword">type</span> GenesisAlloc <span class="keyword">map</span>[common.Address]GenesisAccount</span><br><span class="line"><span class="keyword">type</span> GenesisAccount <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code       []<span class="keyword">byte</span>                      <span class="string">`json:&quot;code,omitempty&quot;`</span></span><br><span class="line">	Storage    <span class="keyword">map</span>[common.Hash]common.Hash <span class="string">`json:&quot;storage,omitempty&quot;`</span></span><br><span class="line">	Balance    *big.Int                    <span class="string">`json:&quot;balance&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">    Nonce      <span class="keyword">uint64</span>                      <span class="string">`json:&quot;nonce,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">//用来测试</span></span><br><span class="line">	PrivateKey []<span class="keyword">byte</span>                      <span class="string">`json:&quot;secretKey,omitempty&quot;`</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了直观展示，我们看看操作部署以太坊时候，我们的配置文件，正好和上面一一对应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;chainId&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;homesteadBlock&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;eip155Block&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;eip158Block&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;0x81e71d34e8a9e4382c36fd90c3f234549106addd&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;20000000000000000000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;coinbase&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x20000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;extraData&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0x2fefd8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0x0000000000000042&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mixhash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x00&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便测试，一般会在<code>alloc</code>中添加几个默认账户。</p>
<h2 id="上述配置结构体的说明"><a href="#上述配置结构体的说明" class="headerlink" title="上述配置结构体的说明"></a>上述配置结构体的说明</h2><p>文件中，你会发现还有别的结构体，在此小编专门解释一下，因为上面提到的结构体是直接解析<code>*.json</code>的，会有很多限制，为此官方使用了<code>github.com/fjl/gencodec</code>包来扩充弥补其中的不足，可以在此处了解：<code>https://godoc.org/github.com/fjl/gencodec</code>。<br>文件头部，会发现有这两行内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate gencodec -type Genesis -field-override genesisSpecMarshaling -out gen_genesis.go</span></span><br><span class="line"><span class="comment">//go:generate gencodec -type GenesisAccount -field-override genesisAccountMarshaling -out gen_genesis_account.go</span></span><br></pre></td></tr></table></figure>
<p>其中<code>go:generate</code>是golang1.4引入的机制，编译期间，会将后面的命令执行，生成对应文件。<br>总结一下：</p>
<ol>
<li>需要了解<code>https://godoc.org/github.com/fjl/gencodec</code>这个</li>
<li>需要了解<code>go:generate</code>的作用</li>
</ol>
<h2 id="创世块的初始化设置"><a href="#创世块的初始化设置" class="headerlink" title="创世块的初始化设置"></a>创世块的初始化设置</h2><p>前面提到的是用来初始化创世块的结构体，其具体的操作是使用如下这个方法来实现的：<br><code>时间有限，暂时先写到这里</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若genesis为空，则进入主网</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupGenesisBlock</span><span class="params">(db ethdb.Database, genesis *Genesis)</span> <span class="params">(*params.ChainConfig, common.Hash, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//若自定义了创世块，却没有对Config进行配置，则返回错误</span></span><br><span class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &amp;&amp; genesis.Config == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> params.AllEthashProtocolChanges, common.Hash&#123;&#125;, errGenesisNoConfig</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化新配置的以太坊节点会用到</span></span><br><span class="line">	stored := rawdb.ReadCanonicalHash(db, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (stored == common.Hash&#123;&#125;) &#123; <span class="comment">//如果db中没有存储创世块</span></span><br><span class="line">		<span class="keyword">if</span> genesis == <span class="literal">nil</span> &#123; <span class="comment">//如果没有配置genesis，则使用主网的默认配置，这会连接到主网</span></span><br><span class="line">			log.Info(<span class="string">&quot;Writing default main-net genesis block&quot;</span>)</span><br><span class="line">			genesis = DefaultGenesisBlock()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果genesis不为空，则按照用户要求进行</span></span><br><span class="line">			log.Info(<span class="string">&quot;Writing custom genesis block&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		block, err := genesis.Commit(db) <span class="comment">//保存在db中</span></span><br><span class="line">		<span class="keyword">return</span> genesis.Config, block.Hash(), err <span class="comment">//返回结果，配置、创世块hash</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若是有自定义的genesis，则校验跟库中已有的是否一致 </span></span><br><span class="line">	<span class="keyword">if</span> genesis != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//因为创世块的配置文件每次都可以随意改动，该步骤用来检查创世块是否有所变动</span></span><br><span class="line">		hash := genesis.ToBlock(<span class="literal">nil</span>).Hash() <span class="comment">//ToBlock传入nil会返回一个标准创世块的hash</span></span><br><span class="line">		<span class="keyword">if</span> hash != stored &#123;  <span class="comment">//检查从数据库中读取的创世块hash和启动时候配置的创世块hash是否一致</span></span><br><span class="line">			<span class="keyword">return</span> genesis.Config, hash, &amp;GenesisMismatchError&#123;stored, hash&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取链的配置，注意不是创世块的配置</span></span><br><span class="line">	<span class="comment">// 根据传入的stored检测要建立什么样的网络，主网、测试网等</span></span><br><span class="line">	newcfg := genesis.configOrDefault(stored)</span><br><span class="line">	storedcfg := rawdb.ReadChainConfig(db, stored)</span><br><span class="line">	<span class="comment">// 如果db中没有对链的配置，则将newcfg配置进去</span></span><br><span class="line">	<span class="keyword">if</span> storedcfg == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Found genesis block without chain config&quot;</span>)</span><br><span class="line">		rawdb.WriteChainConfig(db, stored, newcfg)</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再次做配置，若genesis为空，则创世块的hash值必须是主网的值</span></span><br><span class="line">	<span class="keyword">if</span> genesis == <span class="literal">nil</span> &amp;&amp; stored != params.MainnetGenesisHash &#123;</span><br><span class="line">		<span class="keyword">return</span> storedcfg, stored, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查兼容性</span></span><br><span class="line">	<span class="comment">// 只有当前是区块0的时候，才能进行下面的操作</span></span><br><span class="line">	height := rawdb.ReadHeaderNumber(db, rawdb.ReadHeadHeaderHash(db))</span><br><span class="line">	<span class="keyword">if</span> height == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, fmt.Errorf(<span class="string">&quot;missing block number for head header hash&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	compatErr := storedcfg.CheckCompatible(newcfg, *height)</span><br><span class="line">	<span class="comment">//若已经有区块在db，则不能更改配置</span></span><br><span class="line">	<span class="keyword">if</span> compatErr != <span class="literal">nil</span> &amp;&amp; *height != <span class="number">0</span> &amp;&amp; compatErr.RewindTo != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newcfg, stored, compatErr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//相当于在0块时更新链的配置</span></span><br><span class="line">	rawdb.WriteChainConfig(db, stored, newcfg)</span><br><span class="line">	<span class="keyword">return</span> newcfg, stored, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个创世块的配置，其目的就是为了保证网络启动后，自始至终只能配置一次。主要的说明都记录在注释中了。其中涉及到了几个比较重要的方法：<code>ToBlock()</code>、<code>Commit()</code>，之后我们一一来说明。</p>
<h2 id="ToBlock"><a href="#ToBlock" class="headerlink" title="ToBlock()"></a>ToBlock()</h2><p>这个方法的目的就是生成一个创世块，同时将相关信息写入到db中.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Genesis)</span> <span class="title">ToBlock</span><span class="params">(db ethdb.Database)</span> *<span class="title">types</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		db = ethdb.NewMemDatabase() <span class="comment">//内存db</span></span><br><span class="line">	&#125;</span><br><span class="line">	statedb, _ := state.New(common.Hash&#123;&#125;, state.NewDatabase(db))</span><br><span class="line">	<span class="keyword">for</span> addr, account := <span class="keyword">range</span> g.Alloc &#123;</span><br><span class="line">		<span class="comment">//初始化时候设置的账户保存在db中</span></span><br><span class="line">		statedb.AddBalance(addr, account.Balance)</span><br><span class="line">		statedb.SetCode(addr, account.Code)</span><br><span class="line">		statedb.SetNonce(addr, account.Nonce)</span><br><span class="line">		<span class="comment">//将账户中的各种交易状态存入（注意此时并没有提交到真正数据库中，只是存入内存db）</span></span><br><span class="line">		<span class="keyword">for</span> key, value := <span class="keyword">range</span> account.Storage &#123;</span><br><span class="line">			statedb.SetState(addr, key, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取db根地址</span></span><br><span class="line">	root := statedb.IntermediateRoot(<span class="literal">false</span>)</span><br><span class="line">	<span class="comment">// 创世块的head</span></span><br><span class="line">	head := &amp;types.Header&#123;</span><br><span class="line">		<span class="comment">//块号</span></span><br><span class="line">		Number:     <span class="built_in">new</span>(big.Int).SetUint64(g.Number),</span><br><span class="line">		Nonce:      types.EncodeNonce(g.Nonce),</span><br><span class="line">		Time:       <span class="built_in">new</span>(big.Int).SetUint64(g.Timestamp),</span><br><span class="line">		<span class="comment">//父hash</span></span><br><span class="line">		ParentHash: g.ParentHash,</span><br><span class="line">		<span class="comment">//额外数据</span></span><br><span class="line">		Extra:      g.ExtraData,</span><br><span class="line">		<span class="comment">//gas限制</span></span><br><span class="line">		GasLimit:   g.GasLimit,</span><br><span class="line">		<span class="comment">//已使用的gas</span></span><br><span class="line">		GasUsed:    g.GasUsed,</span><br><span class="line">		<span class="comment">// 难度</span></span><br><span class="line">		Difficulty: g.Difficulty,</span><br><span class="line">		<span class="comment">//与nonce配合用于挖矿，由上一个区块的一部分生成的hash。</span></span><br><span class="line">		MixDigest:  g.Mixhash,</span><br><span class="line">		<span class="comment">//挖矿人</span></span><br><span class="line">		Coinbase:   g.Coinbase,</span><br><span class="line">		<span class="comment">//块hash</span></span><br><span class="line">		Root:       root,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创世块设置的默认gaslimit:4712388</span></span><br><span class="line">	<span class="keyword">if</span> g.GasLimit == <span class="number">0</span> &#123;</span><br><span class="line">		head.GasLimit = params.GenesisGasLimit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//默认难度：131072</span></span><br><span class="line">	<span class="keyword">if</span> g.Difficulty == <span class="literal">nil</span> &#123;</span><br><span class="line">		head.Difficulty = params.GenesisDifficulty</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//真正将数据存入db</span></span><br><span class="line">	statedb.Commit(<span class="literal">false</span>)</span><br><span class="line">	statedb.Database().TrieDB().Commit(root, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//返回创世块</span></span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(head, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，整个过程都是为了组装创世块，里面并没有太复杂的逻辑，能够知道的就是，默认的难度为：<code>131072</code>，默认的gasLimit：<code>4712388</code>，返回的创世块中，只有head即可。</p>
<h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit()"></a>Commit()</h2><p>这个主要就是把创世块的配置相关记录到db中，<br>对比上面的<code>ToBlock()</code>，会发现有rawdb和statedb两种不同的db操作，后者主要是存储块交易的各种信息，前者可以理解为是对后者的进一步封装，目前认为其主要是存储创世块相关配置信息，后续再把这个坑补上。。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Genesis)</span> <span class="title">Commit</span><span class="params">(db ethdb.Database)</span> <span class="params">(*types.Block, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取创世块</span></span><br><span class="line">	block := g.ToBlock(db)</span><br><span class="line">	<span class="comment">//只有创世块才可以操作</span></span><br><span class="line">	<span class="keyword">if</span> block.Number().Sign() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;can&#x27;t commit genesis block with number &gt; 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将块的信息加入rawdb之中</span></span><br><span class="line">	rawdb.WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty)</span><br><span class="line">	rawdb.WriteBlock(db, block)</span><br><span class="line">	rawdb.WriteReceipts(db, block.Hash(), block.NumberU64(), <span class="literal">nil</span>)</span><br><span class="line">	rawdb.WriteCanonicalHash(db, block.Hash(), block.NumberU64())</span><br><span class="line">	rawdb.WriteHeadBlockHash(db, block.Hash())</span><br><span class="line">	rawdb.WriteHeadHeaderHash(db, block.Hash())</span><br><span class="line"></span><br><span class="line">	config := g.Config</span><br><span class="line">	<span class="keyword">if</span> config == <span class="literal">nil</span> &#123;</span><br><span class="line">		config = params.AllEthashProtocolChanges</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将创世块的配置写入</span></span><br><span class="line">	rawdb.WriteChainConfig(db, block.Hash(), config)</span><br><span class="line">	<span class="keyword">return</span> block, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回各种模式的genesis"><a href="#返回各种模式的genesis" class="headerlink" title="返回各种模式的genesis"></a>返回各种模式的genesis</h2><p>这个是为了方便不同网络的测试和使用：<code>GenesisBlockForTesting</code>、<code>DefaultGenesisBlock</code>、<code>DefaultTestnetGenesisBlock</code>、<code>DefaultRinkebyGenesisBlock</code>、<code>DeveloperGenesisBlock</code>，可根据需要选择。<br>这个就不详述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创世块这里，总的来说，没有太复杂的操作，主要就是配置文件的读取，校验，然后存储在db。注意区分rawdb和statedb。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊各阶段说明</title>
    <url>/articles/ba73f461/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以太坊正式发布后总共会分为4大阶段，加上最早的一个测试阶段，总共5各阶段，为了后面方便跟踪，在此做一些详细记录。</p>
<a id="more"></a>
<h2 id="Olympic"><a href="#Olympic" class="headerlink" title="Olympic"></a>Olympic</h2><p>这是以太坊正式发布前的最后一个测试网络。<br>2015年5月发布</p>
<h2 id="第一阶段：Frontier（前沿）"><a href="#第一阶段：Frontier（前沿）" class="headerlink" title="第一阶段：Frontier（前沿）"></a>第一阶段：Frontier（前沿）</h2><p>第一个正式版本<br>2015年7月30日发布<br>POW共识</p>
<h2 id="第二阶段：Homestead（家园）"><a href="#第二阶段：Homestead（家园）" class="headerlink" title="第二阶段：Homestead（家园）"></a>第二阶段：Homestead（家园）</h2><p>2016年3月14日<br>POW共识</p>
<h2 id="第三阶段：Metropolis（大都会）"><a href="#第三阶段：Metropolis（大都会）" class="headerlink" title="第三阶段：Metropolis（大都会）"></a>第三阶段：Metropolis（大都会）</h2><p>该阶段划分的比较细</p>
<h3 id="vByzantium（拜占庭阶段）"><a href="#vByzantium（拜占庭阶段）" class="headerlink" title="vByzantium（拜占庭阶段）"></a>vByzantium（拜占庭阶段）</h3><p>2017年12月16日发布<br>POW共识</p>
<h3 id="vConstantinople（康斯坦丁堡阶段）"><a href="#vConstantinople（康斯坦丁堡阶段）" class="headerlink" title="vConstantinople（康斯坦丁堡阶段）"></a>vConstantinople（康斯坦丁堡阶段）</h3><p>当前这一阶段代码可以看到，<br>共识算法将会采用：Casper（PoW+PoS混合共识），貌似正式发布被推迟了</p>
<h2 id="第四阶段：Serenity（宁静）"><a href="#第四阶段：Serenity（宁静）" class="headerlink" title="第四阶段：Serenity（宁静）"></a>第四阶段：Serenity（宁静）</h2><p>等着吧，，，</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第6.2讲-pow共识算法实现</title>
    <url>/articles/231042d1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分，我们主要是来了解一下pow共识引擎的具体实现。<br>本文主要是梳理引擎主要方法的流程。</p>
<a id="more"></a>
<p>在<code>consensus模块-&gt;ethash-&gt;ethash.go</code>文件中，列出了pow共识具体实现的结构体<code>Ethash</code>。本文将着重介绍该结构体以及其对应实现的方法。其余问题，我们放在后续文章中讲解。</p>
<h2 id="结构体Ethash"><a href="#结构体Ethash" class="headerlink" title="结构体Ethash"></a>结构体<code>Ethash</code></h2><p>先来看看这个结构体，它本身就是pow算法的具体描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下几种挖矿模式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ModeNormal Mode = <span class="literal">iota</span></span><br><span class="line">	ModeShared    <span class="comment">//分享模式，避免缓存干扰</span></span><br><span class="line">	ModeTest      <span class="comment">//测试模式</span></span><br><span class="line">	ModeFake      <span class="comment">//伪模式？</span></span><br><span class="line">	ModeFullFake  <span class="comment">//完全伪模式，完全不验证块，提高速度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	CacheDir       <span class="keyword">string</span></span><br><span class="line">	CachesInMem    <span class="keyword">int</span></span><br><span class="line">	CachesOnDisk   <span class="keyword">int</span></span><br><span class="line">	DatasetDir     <span class="keyword">string</span></span><br><span class="line">	DatasetsInMem  <span class="keyword">int</span></span><br><span class="line">	DatasetsOnDisk <span class="keyword">int</span></span><br><span class="line">	PowMode        Mode   <span class="comment">//从此处可以设置不同的挖矿模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ethash <span class="keyword">struct</span> &#123;</span><br><span class="line">	config Config <span class="comment">//pow的一些基本配置，比如缓存路径、数据库路径等</span></span><br><span class="line"></span><br><span class="line">	caches   *lru <span class="comment">// 在内存中存放的缓存信息</span></span><br><span class="line">    datasets *lru <span class="comment">// 在内存中存放的数据库信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 挖矿相关</span></span><br><span class="line">	rand     *rand.Rand    <span class="comment">// nonces的随机种子</span></span><br><span class="line">	threads  <span class="keyword">int</span>           <span class="comment">// 有多少条线程在挖矿</span></span><br><span class="line">	update   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 通知更新挖矿参数</span></span><br><span class="line">	hashrate metrics.Meter <span class="comment">// 跟踪hash相关的速率，应该是用来监控，保证难度恒定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remote sealer related fields，之后的翻译，等我具体了解了细节再来解释</span></span><br><span class="line">	workCh       <span class="keyword">chan</span> *sealTask   <span class="comment">// Notification channel to push new work and relative result channel to remote sealer</span></span><br><span class="line">	fetchWorkCh  <span class="keyword">chan</span> *sealWork   <span class="comment">// Channel used for remote sealer to fetch mining work</span></span><br><span class="line">	submitWorkCh <span class="keyword">chan</span> *mineResult <span class="comment">// Channel used for remote sealer to submit their mining result</span></span><br><span class="line">	fetchRateCh  <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">uint64</span> <span class="comment">// Channel used to gather submitted hash rate for local or remote sealer.</span></span><br><span class="line">	submitRateCh <span class="keyword">chan</span> *hashrate   <span class="comment">// Channel used for remote sealer to submit their mining hashrate</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下都是测试时候使用到的参数</span></span><br><span class="line">	shared    *Ethash       <span class="comment">// Shared PoW verifier to avoid cache regeneration</span></span><br><span class="line">	fakeFail  <span class="keyword">uint64</span>        <span class="comment">// Block number which fails PoW check even in fake mode</span></span><br><span class="line">	fakeDelay time.Duration <span class="comment">// Time delay to sleep for before returning from verify</span></span><br><span class="line"></span><br><span class="line">	lock      sync.Mutex      <span class="comment">// Ensures thread safety for the in-memory caches and mining fields</span></span><br><span class="line">	closeOnce sync.Once       <span class="comment">// Ensures exit channel will not be closed twice.</span></span><br><span class="line">	exitCh    <span class="keyword">chan</span> <span class="keyword">chan</span> error <span class="comment">// Notification channel to exiting backend threads</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于要使用到大量的数据集，所以有两个指向lru的指针，一个指向db，一个指向内存。并且通过threads控制挖矿线程数。并在测试模式或fake模式下，简单快速处理，使之快速得到结果。</p>
<h2 id="共识算法接口实现"><a href="#共识算法接口实现" class="headerlink" title="共识算法接口实现"></a>共识算法接口实现</h2><p>上一篇文章<a href="/articles/3673b530">以太坊源码解读-第6.1讲-共识模块入口设计</a>我们得知，共识算法是实现<code>Engine接口</code>中的方法。也就是说结构体<code>Ethash</code>要实现其中的每一个接口，又因为它是POW的具体实现，还得实现pow中另一个接口<code>Hashrate()</code>。<br>而具体的实现是在<code>consensus.go</code>文件中。<br>下面我们一个个来解释。</p>
<h3 id="Author"><a href="#Author" class="headerlink" title="Author()"></a>Author()</h3><p>获取挖出当前块的矿工地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Author</span><span class="params">(header *types.Header)</span> <span class="params">(common.Address, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> header.Coinbase, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VerifyHeader"><a href="#VerifyHeader" class="headerlink" title="VerifyHeader()"></a>VerifyHeader()</h3><p>用于校验区块头部信息是否符合ethash共识引擎规则，</p>
<h4 id="先总结校验流程"><a href="#先总结校验流程" class="headerlink" title="先总结校验流程"></a>先总结校验流程</h4><p>后续涉及到块批量校验，叔块的校验等，都是执行下面类似的步骤。<br>该方法校验流程（具体细节看下面代码解析，该流程只用作梳理）：</p>
<ol>
<li>校验是否为<code>ModeFullFake</code>模式，是则返回成功，否则继续。</li>
<li>根据该块的块号和hash在链中判断，是否能找到该块，能则返回，否则继续</li>
<li>根据该块的父块的hash和块号，检测能否在链中找到该父块，不能则返回错误，否则继续。（此时说明该块是一个新块）</li>
<li>获取到父块后，进一步对该新块做更细的校验。<ol>
<li>块头部额外数据(head.extra)的长度是否超过了最大限制长度（据了解extra表示可以让矿工加入有限字符，dao分叉后这个extra被占用了）</li>
<li>判断该块是否为叔块（true、false）。<ol>
<li>该块若是叔块，则判断时间戳是否超过了256位长度，是则返回异常否则继续</li>
<li>该块若不是叔块，则判断该块时间戳是否超过当前时间（+15秒，可得知<code>每15秒左右出一个块</code>），若是则返回异常，否则继续</li>
</ol>
</li>
<li>判断该块的时间戳是否比父块的时间戳大，不是则返回异常，否则继续</li>
<li>根据该块和它父块难度计算预期的困难度，判断该预期困难度和该块中原先记录的困难度是否一致，不一致则返回异常，否则继续</li>
<li>判断<code>gaslimit</code>是否大于<code>2^63-1</code>，若大约则返回异常，否则继续（此处可得知gaslimit的上限是2^63-1，相当于9.2个左右的eth）</li>
<li>判断该块的<code>gasUsed</code>是否 &lt;= <code>gasLimit</code>，不是则返回异常，否则继续</li>
<li>确保当前块gaslimit相对于父块的是在一个范围内。若不是在该范围内，则返回异常否则继续。（此处可知，<code>gaslimit不得小于5000</code>）</li>
<li>子块number-父块number若不是1，则返回异常</li>
<li>校验密封？的块是否符合要求（这块暂时不太理解，再埋一个坑，回头填，只知道这块是很重要的，也是调用了共识引擎的一个接口实现）</li>
<li>如果所有检查通过，则验证硬分叉的特殊字段。</li>
</ol>
</li>
</ol>
<h4 id="具体代码分析"><a href="#具体代码分析" class="headerlink" title="具体代码分析"></a>具体代码分析</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">VerifyHeader</span><span class="params">(chain consensus.ChainReader, header *types.Header, seal <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ModeFullFake模式，则不做任何验证</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    number := header.Number.Uint64()</span><br><span class="line">    <span class="comment">// 若根据块号和hash能在链中找到，则说明该块存在</span></span><br><span class="line">	<span class="keyword">if</span> chain.GetHeader(header.Hash(), number) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时该块还没有被加入到链中，新生成的块，从其中尝试获取其父块</span></span><br><span class="line">	parent := chain.GetHeader(header.ParentHash, number<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;  <span class="comment">//拿不到父块，则返回异常</span></span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 拿到父块后，对该块做进一步到验证，用来确保该块的正确性</span></span><br><span class="line">    <span class="comment">// false表示不是叔块</span></span><br><span class="line">	<span class="keyword">return</span> ethash.verifyHeader(chain, header, parent, <span class="literal">false</span>, seal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，小编注释写的很详细了，主要就是验证块头部的正确性（其实就是验证块），前面代码都还好理解，在最后一行代码<code>ethash.verifyHeader(...)</code>（注意verifyHeader是首字母是小写，并不是共识通用引擎中的接口），从逻辑上我们可以看出，它是用来详细校验一个新生成的块，具体来看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">verifyHeader</span><span class="params">(chain consensus.ChainReader, header, parent *types.Header, uncle <span class="keyword">bool</span>, seal <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 头部额外的数据段长度合理，这个额外的数据段是什么，姑且放一放，最后再来补坑</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uint64</span>(<span class="built_in">len</span>(header.Extra)) &gt; params.MaximumExtraDataSize &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;extra-data too long: %d &gt; %d&quot;</span>, <span class="built_in">len</span>(header.Extra), params.MaximumExtraDataSize)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证块头部的时间戳</span></span><br><span class="line">	<span class="keyword">if</span> uncle &#123; <span class="comment">//叔块</span></span><br><span class="line">		<span class="keyword">if</span> header.Time.Cmp(math.MaxBig256) &gt; <span class="number">0</span> &#123; <span class="comment">//以太坊可以被认为是256位机器，超过后，则异常</span></span><br><span class="line">			<span class="keyword">return</span> errLargeBlockTime</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> header.Time.Cmp(big.NewInt(time.Now().Add(allowedFutureBlockTime).Unix())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//该块的生产时间超过了当前时间（+15秒），说明该块异常</span></span><br><span class="line">            <span class="comment">//也说明出一个块15秒</span></span><br><span class="line">			<span class="keyword">return</span> consensus.ErrFutureBlock  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> header.Time.Cmp(parent.Time) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errZeroBlockTime <span class="comment">//当前块时间戳比它上一个块的时间戳小，则说明块异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据该块的时间戳以及它父块的难度，获取当前块预期的难度值，CalcDifficulty是共识通用引擎的接口实现，我们稍后会专门分析</span></span><br><span class="line">	expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该块预期难度值和该块head中记录的难度值如果不一样，则返回错误</span></span><br><span class="line">	<span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断该块的gaslimit上限是否超过2^63-1</span></span><br><span class="line">	<span class="built_in">cap</span> := <span class="keyword">uint64</span>(<span class="number">0x7fffffffffffffff</span>)</span><br><span class="line">	<span class="keyword">if</span> header.GasLimit &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasLimit: have %v, max %v&quot;</span>, header.GasLimit, <span class="built_in">cap</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断该块的gasUsed是否 &lt;= gasLimit</span></span><br><span class="line">	<span class="keyword">if</span> header.GasUsed &gt; header.GasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasUsed: have %d, gasLimit %d&quot;</span>, header.GasUsed, header.GasLimit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保gas在允许范围内</span></span><br><span class="line">	diff := <span class="keyword">int64</span>(parent.GasLimit) - <span class="keyword">int64</span>(header.GasLimit)</span><br><span class="line">	<span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;   <span class="comment">//说明子块的gaslimit比父块的大，</span></span><br><span class="line">		diff *= <span class="number">-1</span>  <span class="comment">//保证差异值为正</span></span><br><span class="line">	&#125;</span><br><span class="line">	limit := parent.GasLimit / params.GasLimitBoundDivisor <span class="comment">//limit=父块gaslimit/1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//差异值过大，或者gaslimit比5000还要小，则返回</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uint64</span>(diff) &gt;= limit || header.GasLimit &lt; params.MinGasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gas limit: have %d, want %d += %d&quot;</span>, header.GasLimit, parent.GasLimit, limit)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子块number-父块number若不是1，则返回异常</span></span><br><span class="line">	<span class="keyword">if</span> diff := <span class="built_in">new</span>(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(<span class="number">1</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrInvalidNumber</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验密封？的块是否符合要求</span></span><br><span class="line">	<span class="keyword">if</span> seal &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.VerifySeal(chain, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果所有检查通过，则验证硬分叉的特殊字段。</span></span><br><span class="line">    <span class="comment">// misc上一篇文章小编也提到过，硬分叉相关，暂时不考虑，后续文章再专门分析</span></span><br><span class="line">	<span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := misc.VerifyForkHashes(chain.Config(), header, uncle); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该头部校验的相关内容，到此就讲解完了，开头处也总结了一下整个校验流程，基本可以参考它实现整个校验过程。接着我们看下一个共识引擎接口。</p>
<h3 id="CalcDifficulty"><a href="#CalcDifficulty" class="headerlink" title="CalcDifficulty()"></a>CalcDifficulty()</h3><p>用于计算<code>下一个块的难度</code>，以太坊分为不同的阶段（可参考：<a href="/articles/ba73f461">以太坊各阶段说明</a>），因此，这个难度计算针对不同的阶段会有不同的计算方式。<br>这个方法用于计算下一个块的难度，同时，从上面校验方法我们可知，该方法也用来校验块中的难度值是否一致。<br>可从以下代码看出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的实现需要一层层的探索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">CalcDifficulty</span><span class="params">(chain consensus.ChainReader, time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CalcDifficulty(chain.Config(), time, parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同阶段来计算下一个块的难度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcDifficulty</span><span class="params">(config *params.ChainConfig, time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">    next := <span class="built_in">new</span>(big.Int).Add(parent.Number, big1)</span><br><span class="line">    <span class="comment">//可以看到下面是不同阶段的</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> config.IsConstantinople(next): <span class="comment">//第三阶段的Metropolis（大都会）的vConstantinople（康斯坦丁堡阶段）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyConstantinople(time, parent)</span><br><span class="line">	<span class="keyword">case</span> config.IsByzantium(next): <span class="comment">//第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyByzantium(time, parent)</span><br><span class="line">	<span class="keyword">case</span> config.IsHomestead(next): <span class="comment">//第二阶段Homestead（家园）</span></span><br><span class="line">		<span class="keyword">return</span> calcDifficultyHomestead(time, parent) </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> calcDifficultyFrontier(time, parent) <span class="comment">//第一阶段Frontier（前沿）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前稳定版是在第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段），使用的纯pow共识算法。因此我们来具体看看这一阶段的难度值是如何计算的。</p>
<h4 id="先总结计算流程"><a href="#先总结计算流程" class="headerlink" title="先总结计算流程"></a>先总结计算流程</h4><ol>
<li>从第300万个块之后开始按照<code>拜占庭阶段</code>规则计算难度，</li>
<li>叔块难度介入，使用对应公式实计算，返回计算结果（公式下面给出）。</li>
<li>难度值始终不小于<code>131072</code>,创世块若不设置难度，默认也是这个大小。</li>
</ol>
<h4 id="具体代码分析-1"><a href="#具体代码分析-1" class="headerlink" title="具体代码分析"></a>具体代码分析</h4><p>第三阶段的Metropolis（大都会）的vByzantium（拜占庭阶段）的每个块的下一个块难度计算，进一步是从以下入口开始的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个起源和规则可以参考：https://eips.ethereum.org/EIPS/eip-649</span></span><br><span class="line"><span class="comment">// 3000000表示从以太坊从第300万个块之后都使用这样一个难度计算方式</span></span><br><span class="line"><span class="comment">// 这个被称为难度炸弹。。。</span></span><br><span class="line">calcDifficultyByzantium = makeDifficultyCalculator(big.NewInt(<span class="number">3000000</span>))</span><br></pre></td></tr></table></figure>
<p>看看具体计算的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看清楚代码，函数方法</span></span><br><span class="line"><span class="comment">// 这个过程叫做深水炸弹</span></span><br><span class="line"><span class="comment">// makeDifficultyCalculator返回的：是一个带有返回值的方法</span></span><br><span class="line"><span class="comment">// 方法参数bombDelay是块号，表示从哪个块开始</span></span><br><span class="line"><span class="comment">// 返回的方法中，第一个参数是块的时间戳，第二个是父块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDifficultyCalculator</span><span class="params">(bombDelay *big.Int)</span> <span class="title">func</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 要计算下一个块的难度，就需要先知道上一个块的编号</span></span><br><span class="line">	bombDelayFromParent := <span class="built_in">new</span>(big.Int).Sub(bombDelay, big1)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(time <span class="keyword">uint64</span>, parent *types.Header)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">		<span class="comment">// 参考：https://github.com/ethereum/EIPs/issues/100.</span></span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算的具体代码没有列出来，是按照这样一个计算公式实现该难度计算的：<br><code>diff = (parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) / 9), -99)) ) + 2^(periodCount - 2)</code><br>公式中可得知，难度的计算加入了叔块。<br>为了更加清晰，公式整理如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block_diff = parent_diff + [难度调整] + [难度炸弹]</span><br><span class="line">[难度调整] = parent_diff / <span class="number">2048</span> * max((<span class="number">2</span> <span class="keyword">if</span> <span class="built_in">len</span>(parent.uncles) <span class="keyword">else</span> <span class="number">1</span>) - (block_timestamp - parent_timestamp) / <span class="number">9</span>, <span class="number">-99</span>))</span><br><span class="line">[难度炸弹] = INT(<span class="number">2</span>^((periodCount / <span class="number">100000</span>) - <span class="number">2</span>))</span><br><span class="line">备注：在<span class="number">300</span>w~<span class="number">310</span>w块之间，[难度炸弹]=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="VerifyHeaders"><a href="#VerifyHeaders" class="headerlink" title="VerifyHeaders()"></a>VerifyHeaders()</h3><p>该方法和前面提到的<code>VerifyHeader</code>类似，只是这个是批量验证。<br>中间用到了大量的goroutine，看着代码量挺大的，其实蛮好理解的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">VerifyHeaders</span><span class="params">(chain consensus.ChainReader, headers []*types.Header, seals []<span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line">	... <span class="comment">// ModeFullFake，则什么也不处理，直接返回，此处代码略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保每个核都参与工作</span></span><br><span class="line">	workers := runtime.GOMAXPROCS(<span class="number">0</span>)  <span class="comment">//0，表示使用最大cpu数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) &lt; workers &#123;</span><br><span class="line">		workers = <span class="built_in">len</span>(headers)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一些必要的变量</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		inputs = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">		done   = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, workers)</span><br><span class="line">		errors = <span class="built_in">make</span>([]error, <span class="built_in">len</span>(headers))</span><br><span class="line">		abort  = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;  <span class="comment">//所有worker全马力运转</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">			<span class="keyword">for</span> index := <span class="keyword">range</span> inputs &#123; <span class="comment">//接收到传来的数字（最下面代码注释），然后开始执行</span></span><br><span class="line">				errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)</span><br><span class="line">				done &lt;- index</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	errorsOut := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="built_in">len</span>(headers)) <span class="comment">//用于在select接收存储到的错误</span></span><br><span class="line">	...  <span class="comment">//此处是select，接收到chan信息后的处理逻辑，虽然代码有点长，但不复杂，在此就不列出了</span></span><br><span class="line">	     <span class="comment">//同时，此处也为input不停的传入数字1，2，3...，直到len(headers)</span></span><br><span class="line">	<span class="keyword">return</span> abort, errorsOut</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有空的话，建议好好读读，写的蛮好的，通过goroutine和channel将整个过程做的清晰明了<br>可以看出，真正验证头部，是在<code>ethash.verifyHeaderWorker()</code>这个方法中执行的，其中主要是调用共识引擎的<code>verifyHeader()接口</code>实现的，这个前面已经讲过，在此就不详述了。</p>
<h3 id="VerifyUncles"><a href="#VerifyUncles" class="headerlink" title="VerifyUncles()"></a>VerifyUncles()</h3><p>什么是叔块，直接看图：</p>
<img src="/articles/231042d1/1.png" class="" title="叔块">
<p>用来校验当前块的叔块，和校验块头部其实很类似，直接看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">VerifyUncles</span><span class="params">(chain consensus.ChainReader, block *types.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ModeFullFake，不执行</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 目前一个块最多可以有两个叔块</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(block.Uncles()) &gt; maxUncles &#123;</span><br><span class="line">		<span class="keyword">return</span> errTooManyUncles</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 汇总叔块和祖先,祖先是指当前块的前8个块</span></span><br><span class="line">	<span class="comment">// ancestors 存放祖先块的hash</span></span><br><span class="line">	<span class="comment">// uncles 存放每个主块的uncles块的hash</span></span><br><span class="line">	uncles, ancestors := mapset.NewSet(), <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash]*types.Header)</span><br><span class="line"></span><br><span class="line">	number, parent := block.NumberU64()<span class="number">-1</span>, block.ParentHash() <span class="comment">//父块块号和hash</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;  <span class="comment">//这一坨，一目了然</span></span><br><span class="line">		ancestor := chain.GetBlock(parent, number)</span><br><span class="line">		<span class="keyword">if</span> ancestor == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ancestors[ancestor.Hash()] = ancestor.Header()</span><br><span class="line">		<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> ancestor.Uncles() &#123;</span><br><span class="line">			uncles.Add(uncle.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		parent, number = ancestor.ParentHash(), number<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ancestors[block.Hash()] = block.Header()  <span class="comment">//祖先中总共8个</span></span><br><span class="line">	uncles.Add(block.Hash())  <span class="comment">//这个貌似有点怪，但不影响，uncles主要就是用来保证hash不重复的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前块的叔块hash也加入到uncles中做重复过滤</span></span><br><span class="line">	<span class="comment">// 使用verifyHeader来进一步校验块</span></span><br><span class="line">	<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> block.Uncles() &#123;</span><br><span class="line">		<span class="comment">//hash重复性检测</span></span><br><span class="line">		hash := uncle.Hash()</span><br><span class="line">		<span class="keyword">if</span> uncles.Contains(hash) &#123;</span><br><span class="line">			<span class="keyword">return</span> errDuplicateUncle</span><br><span class="line">		&#125;</span><br><span class="line">		uncles.Add(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检测有效性</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[hash] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errUncleIsAncestor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//叔块应该指向当前块的父块的父块</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[uncle.ParentHash] == <span class="literal">nil</span> || uncle.ParentHash == block.ParentHash() &#123;</span><br><span class="line">			<span class="keyword">return</span> errDanglingUncle</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个方法前面讲过，详细检测块</span></span><br><span class="line">		<span class="keyword">if</span> err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], <span class="literal">true</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重要总结"><a href="#重要总结" class="headerlink" title="重要总结"></a>重要总结</h4><p>这块我们可以得知以下几个重要信息：</p>
<ol>
<li><code>当前块的父块的父块</code>是<code>当前块叔块的父块</code></li>
<li>一个块有两个叔块</li>
<li>将该块的前8个块及其叔块信息分别汇总，是为了更好的确保当前块叔块的正确性，防止有重复等问题，确保叔块和正常块不会交叉混淆，这也是避免有人恶意操作吧。</li>
</ol>
<h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare()"></a>Prepare()</h3><p>在pow算法中，这个接口主要是用来填充块头部中的难度值的，目前并没有别的作用。<br>难度的计算前面已经讲解过了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Prepare</span><span class="params">(chain consensus.ChainReader, header *types.Header)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	header.Difficulty = ethash.CalcDifficulty(chain, header.Time.Uint64(), parent) <span class="comment">//计算并填充难度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize()"></a>Finalize()</h3><p>非常重要的一个方法，对确认的块进行奖励，通俗的讲，就是分配奖励给<code>区块账户</code>和<code>叔块账户</code>。<br>需要注意的是，两个<code>叔块</code>是被一个<code>区块</code>引用的，也就是说，该方法最终会把这个区块记录在db中，从而生成一个新的区块。<br>这里会涉及到很多经济哲理问题，需要自己来意会，来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Finalize</span><span class="params">(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt)</span> <span class="params">(*types.Block, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 区块账户和叔块账户的奖励规则</span></span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	<span class="comment">// 根据保存的db state生成该块的root hash，然后记录在db中，这就是该区块的hash</span></span><br><span class="line">	<span class="comment">// EIP158硬分叉，参考：//https://github.com/ethereum/EIPs/issues/158</span></span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回该新块</span></span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, uncles, receipts), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的奖励实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulateRewards</span><span class="params">(config *params.ChainConfig, state *state.StateDB, header *types.Header, uncles []*types.Header)</span></span> &#123;</span><br><span class="line">	blockReward := FrontierBlockReward  <span class="comment">// 基本奖励，5个eth奖励</span></span><br><span class="line">	<span class="keyword">if</span> config.IsByzantium(header.Number) &#123;  <span class="comment">//拜占庭阶段，3个eth奖励</span></span><br><span class="line">		blockReward = ByzantiumBlockReward</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.IsConstantinople(header.Number) &#123; <span class="comment">//康斯坦丁堡阶段，2个eth奖励</span></span><br><span class="line">		blockReward = ConstantinopleBlockReward</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 叔块的奖励逻辑</span></span><br><span class="line">	reward := <span class="built_in">new</span>(big.Int).Set(blockReward)</span><br><span class="line">	r := <span class="built_in">new</span>(big.Int)</span><br><span class="line">	<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">		<span class="comment">//公式：((uncle.Number+8)-heater.Number)*blockReward/8</span></span><br><span class="line">		<span class="comment">//可以看出，叔块块号越大，叔块的奖励越大</span></span><br><span class="line">		r.Add(uncle.Number, big8)</span><br><span class="line">		r.Sub(r, header.Number)</span><br><span class="line">		r.Mul(r, blockReward)</span><br><span class="line">		r.Div(r, big8)</span><br><span class="line">		state.AddBalance(uncle.Coinbase, r) <span class="comment">//叔块添加到db</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//从这里看出，每个区块中，每添加一个叔块，就会增加额外的1/32的奖励</span></span><br><span class="line">		r.Div(blockReward, big32)</span><br><span class="line">		reward.Add(reward, r)</span><br><span class="line">	&#125;</span><br><span class="line">	state.AddBalance(header.Coinbase, reward) <span class="comment">//区块账户，奖励加入db</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><ol>
<li>当前<code>康斯坦丁堡阶段</code>，一个块默认会给3个eth的奖励，</li>
<li>该块每添加一个叔块，额外给予默认奖励1/32的奖励（一个块最多两个叔块）</li>
<li>奖励结束后，就会被永久记录在链中</li>
</ol>
<h3 id="SealHash"><a href="#SealHash" class="headerlink" title="SealHash()"></a>SealHash()</h3><p>该方法是返回被seal前的一个块头部的hash值，Seal到底是要干嘛，还不清楚，但不影响看这个方法细节，直接上代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">SealHash</span><span class="params">(header *types.Header)</span> <span class="params">(hash common.Hash)</span></span> &#123;</span><br><span class="line">	hasher := sha3.NewKeccak256()</span><br><span class="line"></span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra,</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这明显是把一个块头部先rlp序列化，然后再生成一个hash，貌似目的是要生成一个块头部的hash,生成以后，这个块也就被确定了</p>
<h3 id="VerifySeal"><a href="#VerifySeal" class="headerlink" title="VerifySeal()"></a>VerifySeal()</h3><p>VerifySeal()函数基于跟Seal()完全一样的算法原理，通过验证区块的某些属性(Header.Nonce，Header.MixDigest等)是否正确，来确定该区块是否已经经过Seal操作。<br>会涉及到使用缓存来验证块的合法性或者使用dag来验证，使用dag是为了使得验证更快一些。<br>看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">VerifySeal</span><span class="params">(chain consensus.ChainReader, header *types.Header)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ethash.verifySeal(chain, header, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回的子方法<code>verifySeal</code>来处理，那就进去看看这个方法，看里面的注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于fulldag，true表示使用DAG，false使用传统的缓存机制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">verifySeal</span><span class="params">(chain consensus.ChainReader, header *types.Header, fulldag <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fake模式，最简化处理，伪验证</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		time.Sleep(ethash.fakeDelay)</span><br><span class="line">		<span class="keyword">if</span> ethash.fakeFail == header.Number.Uint64() &#123;</span><br><span class="line">			<span class="keyword">return</span> errInvalidPoW</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// shanred模式的处理，这个暂时不考虑</span></span><br><span class="line">	<span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.shared.verifySeal(chain, header, fulldag)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确保难度值大于0</span></span><br><span class="line">	<span class="keyword">if</span> header.Difficulty.Sign() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidDifficulty</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前块号</span></span><br><span class="line">	number := header.Number.Uint64()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		digest []<span class="keyword">byte</span></span><br><span class="line">		result []<span class="keyword">byte</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> fulldag &#123; <span class="comment">//使用DAG,结合db,生成数据集</span></span><br><span class="line">		dataset := ethash.dataset(number, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> dataset.generated() &#123;</span><br><span class="line">			digest, result = hashimotoFull(dataset.dataset, ethash.SealHash(header).Bytes(), header.Nonce.Uint64())</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 数据集finalizer中未映射。 确保数据集保持活动状态，直到调用hashimotoFull为止，因此在使用时不会取消映射。</span></span><br><span class="line">			runtime.KeepAlive(dataset)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//使用缓存</span></span><br><span class="line">			fulldag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果使用普通验证或者是DAG还没准备好，则执行其中内容</span></span><br><span class="line">	<span class="keyword">if</span> !fulldag &#123;</span><br><span class="line">		cache := ethash.cache(number)</span><br><span class="line"></span><br><span class="line">		size := datasetSize(number)</span><br><span class="line">		<span class="keyword">if</span> ethash.config.PowMode == ModeTest &#123;</span><br><span class="line">			size = <span class="number">32</span> * <span class="number">1024</span> <span class="comment">//测试环境指定固定大小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用hash计算算法，这就是hash碰撞的核心地方，参考：https://blog.csdn.net/ddffr/article/details/78773961</span></span><br><span class="line">		digest, result = hashimotoLight(size, cache.cache, ethash.SealHash(header).Bytes(), header.Nonce.Uint64())</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缓存在finalizer中未映射。 确保缓存在调用hashimotoLight之前保持活动状态，因此在使用时不会取消映射。</span></span><br><span class="line">		runtime.KeepAlive(cache)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 验证计算结果是否满足</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(header.MixDigest[:], digest) &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidMixDigest</span><br><span class="line">	&#125;</span><br><span class="line">	target := <span class="built_in">new</span>(big.Int).Div(two256, header.Difficulty)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>(big.Int).SetBytes(result).Cmp(target) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errInvalidPoW</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面会涉及到很复杂的hash计算方式，本文只是大体梳理一下整体的运行情况，只是针对引擎接口的实现来描述，其中涉及到的其余ethash方法后续再描述。</p>
<h3 id="Seal"><a href="#Seal" class="headerlink" title="Seal()"></a>Seal()</h3><p>它实现了工作量证明，Seal函数尝试找出一个满足区块难度的nonce值。<br>人们常说的挖矿，其实就是调用的它，找到满足条件的块，它就是整个挖矿过程的核心。<br>这个方法涉及的比较复杂，是另外在文件<code>sealer.go</code>中实现的。<br>这个方法看似长，其实就是利用goroutine接受和传递，</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Seal</span><span class="params">(chain consensus.ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//fack模式则忽略挖矿</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// shared模式处理方式，暂时没研究这个模式是干嘛的，不影响</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 标准模式</span></span><br><span class="line">	abort := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	ethash.lock.Lock()</span><br><span class="line">	threads := ethash.threads  <span class="comment">//这就是有多少个矿工在挖矿</span></span><br><span class="line">	<span class="keyword">if</span> ethash.rand == <span class="literal">nil</span> &#123;</span><br><span class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ethash.lock.Unlock()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">//得到一个随机数</span></span><br><span class="line">	&#125;</span><br><span class="line">	ethash.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> threads == <span class="number">0</span> &#123;</span><br><span class="line">		threads = runtime.NumCPU() <span class="comment">//若没有设置矿工数，则使用cpu数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> threads &lt; <span class="number">0</span> &#123;</span><br><span class="line">		threads = <span class="number">0</span> <span class="comment">// 本地挖矿将被阻止</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将任务推向远程</span></span><br><span class="line">	<span class="keyword">if</span> ethash.workCh != <span class="literal">nil</span> &#123;</span><br><span class="line">		ethash.workCh &lt;- &amp;sealTask&#123;block: block, results: results&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pend   sync.WaitGroup <span class="comment">//类似栅栏模式，线程等待</span></span><br><span class="line">		locals = <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Block)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line">		pend.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, nonce <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()</span><br><span class="line">			ethash.mine(block, id, nonce, abort, locals) <span class="comment">//开始挖矿，进入hash碰撞模式</span></span><br><span class="line">		&#125;(i, <span class="keyword">uint64</span>(ethash.rand.Int63()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取挖矿返回的结果，select接收，挖矿停止，或者找到合适的nonce</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> result *types.Block</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="built_in">close</span>(abort) <span class="comment">//关闭所有的channel</span></span><br><span class="line">		<span class="keyword">case</span> result = &lt;-locals:</span><br><span class="line">			<span class="comment">// 只要有一个矿工挖到合适的块，则停止其余所有。</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> results &lt;- result:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ethash.update:</span><br><span class="line">			<span class="comment">// 用户若更新了矿工数（新增或者减少），则停止所有矿工，然后重新挖</span></span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">			<span class="keyword">if</span> err := ethash.Seal(chain, block, results, stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Failed to restart sealing after update&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 等待所有矿工结束</span></span><br><span class="line">		pend.Wait()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码解释了挖矿前的操作以及挖完矿后的接收方式，其中我们发现挖矿的细节是在<code>mine()</code>方法中，这个是ethash的方法之一，这个方法细节会在新的文章中讲解。在此只是了解整个流程。多个线程的开启就是多个groutine开启的过程。</p>
<h3 id="Apis"><a href="#Apis" class="headerlink" title="Apis()"></a>Apis()</h3><p>这个就是对外提供RPC接口服务，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">APIs</span><span class="params">(chain consensus.ChainReader)</span> []<span class="title">rpc</span>.<span class="title">API</span></span> &#123;</span><br><span class="line">	<span class="comment">//为了和旧版本的兼容，加入两个命名空间，都一样</span></span><br><span class="line">	<span class="keyword">return</span> []rpc.API&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			Namespace: <span class="string">&quot;eth&quot;</span>,</span><br><span class="line">			Version:   <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">			Service:   &amp;API&#123;ethash&#125;,</span><br><span class="line">			Public:    <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			Namespace: <span class="string">&quot;ethash&quot;</span>,</span><br><span class="line">			Version:   <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">			Service:   &amp;API&#123;ethash&#125;,</span><br><span class="line">			Public:    <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hashrate"><a href="#Hashrate" class="headerlink" title="Hashrate()"></a>Hashrate()</h3><p>这个是pow算法专有的接口，并不是共识算法引擎的，用于获取当前节点的算力。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Hashrate</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="comment">// fake模式使用</span></span><br><span class="line">	<span class="keyword">if</span> ethash.config.PowMode != ModeNormal &amp;&amp; ethash.config.PowMode != ModeTest &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.hashrate.Rate1()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> res = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// fetchRateCh本身是一个chan chan uint64类型</span></span><br><span class="line">	<span class="comment">//此处说明：本地或远程挖矿的算力会记录到ethash.fetchRateCh，然后它会将结果写入到res中，&lt;-res即可取出结果</span></span><br><span class="line">	<span class="keyword">case</span> ethash.fetchRateCh &lt;- res:  <span class="comment">//用来收集本地或者远程的算力</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ethash.exitCh:</span><br><span class="line">		<span class="keyword">return</span> ethash.hashrate.Rate1()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回整个算力</span></span><br><span class="line">	<span class="keyword">return</span> ethash.hashrate.Rate1() + <span class="keyword">float64</span>(&lt;-res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体获取方式还是看上面注释吧，使用了select和channel，若不结合上下文，很难立马想通代码如何实现的。<br>这个方法只是对蒜粒结果的展示处理，真正的处理过程大体是在<code>sealer.go</code>文件中的<code>mine()</code>方法中，每计算一次，算力+1，具体实现小编后续再专门解释。</p>
<h3 id="Close"><a href="#Close" class="headerlink" title="Close()"></a>Close()</h3><p>这个相当于是关闭整个挖矿线程，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	ethash.closeOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//只会触发执行一次</span></span><br><span class="line">		<span class="keyword">if</span> ethash.exitCh == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">		ethash.exitCh &lt;- errc</span><br><span class="line">		err = &lt;-errc</span><br><span class="line">		<span class="built_in">close</span>(ethash.exitCh)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法调用本身是代码逻辑，我们更多要考虑的是以太坊的设计逻辑，比如为什么要这样做，为什么不那样做，了解设计逻辑，才能真正了解以太坊的精华。<br>代码中涉及到了大量的channel、goroutine、select的使用，它让我们体验了golang本身的魄力，也体会到了以太坊开发人员强大的实力。<br>因为时间和精力，今天刚解析完以太坊pow实现共识引擎的整体逻辑，当然<code>Ethash</code>绝不仅仅只靠这几个接口方法就完成了整个共识过程，从上述代码解析中，也发现了<code>Ethash</code>新的一些方法，这些方法是<code>Ethash</code>本身独有的，而很多具体细节的实现也是在这些方法中，小编之后准备研究下<code>Ethash</code>剩余的方法。<br>尽情期待。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第6.1讲-共识模块入口设计</title>
    <url>/articles/3673b530/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要是先梳理一下<code>consensus</code>模块的入口文件<code>consensus.go</code>，这里体现了以太坊共识设计的整个设计思路。为后面进一步分析共识算法做好基础工作。</p>
<a id="more"></a>

<h2 id="模块文件结构"><a href="#模块文件结构" class="headerlink" title="模块文件结构"></a>模块文件结构</h2><p>先来看下<code>consensus</code>模块的文件目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|____misc                <span class="comment">## 貌似是硬分叉相关的处理，还没研究，先这么认为</span></span><br><span class="line">| |____forks.go    </span><br><span class="line">| |____dao.go</span><br><span class="line">|____consensus.go        <span class="comment">## 共识的通用规则设计，pow的入口设计就在这里</span></span><br><span class="line">|____ethash              <span class="comment">## pow共识算法的具体实现</span></span><br><span class="line">| |____sealer.go</span><br><span class="line">| |____algorithm.go</span><br><span class="line">| |____sealer_test.go</span><br><span class="line">| |____ethash_test.go</span><br><span class="line">| |____consensus.go</span><br><span class="line">| |____algorithm_test.go</span><br><span class="line">| |____api.go</span><br><span class="line">| |____ethash.go</span><br><span class="line">| |____consensus_test.go</span><br><span class="line">|____clique             <span class="comment">## poa共识算法的具体实现，这个主要是供私链使用。</span></span><br><span class="line">| |____clique.go</span><br><span class="line">| |____snapshot_test.go</span><br><span class="line">| |____api.go</span><br><span class="line">| |____snapshot.go</span><br><span class="line">|____errors.go</span><br></pre></td></tr></table></figure>
<p>从中可以大概看出，以太坊目前实现了pow和poa两种共识算法。<br>其中poa是是一种POW与POS(proof of stake股权证明)混合的算法，主要是针对私有链使用的，以太坊测试网（Kovan）便是采用PoA算法，貌似将以太坊部署为联盟链也是用的这种共识，具体还没有研究。<br>这里我们主要关注的是pow，poa等以后有空了再来考虑。</p>
<h2 id="consensus-go文件简介"><a href="#consensus-go文件简介" class="headerlink" title="consensus.go文件简介"></a><code>consensus.go</code>文件简介</h2><p>这个文件中，主要分为3部分：</p>
<ol>
<li>pow算法入口</li>
<li>共识通用引擎接口</li>
<li>读取链信息的部分接口</li>
</ol>
<h2 id="Pow算法入口"><a href="#Pow算法入口" class="headerlink" title="Pow算法入口"></a>Pow算法入口</h2><p>这是对pow的一个封装，<br>先来看代码结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PoW <span class="keyword">interface</span> &#123;</span><br><span class="line">	Engine</span><br><span class="line">	Hashrate() <span class="keyword">float64</span> <span class="comment">//返回当前节点的算力</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看出，pow算法，只要满足<code>Engine接口</code>，就可以完成自己对整个共识过程。这也给了我们一个思路，如果我们要自己实现共识，同样需要继承了<code>Engine</code>。</p>
<h2 id="共识通用引擎接口Engine"><a href="#共识通用引擎接口Engine" class="headerlink" title="共识通用引擎接口Engine"></a>共识通用引擎接口Engine</h2><p>这也是整个共识的核心，一个通用的共识引擎接口，如果要在不改变以太坊整体运转的前提下，设计新的共识规则，那就必须要实现以下的接口，具体的内容都在注释中表明了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前挖矿矿工的以太坊地址</span></span><br><span class="line">    Author(header *types.Header) (common.Address, error)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验块头部信息是否符合共识规则，是否封印</span></span><br><span class="line">	VerifyHeader(chain ChainReader, header *types.Header, seal <span class="keyword">bool</span>) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量校验块头部，这个方法返回一个退出信号用于终止操作，用于异步校验。</span></span><br><span class="line">    VerifyHeaders(chain ChainReader, headers []*types.Header, seals []<span class="keyword">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> error)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 较验叔块是否满足规则</span></span><br><span class="line">	VerifyUncles(chain ChainReader, block *types.Block) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VerifySeal()函数基于跟Seal()完全一样的算法原理，通过验证区块的某些属性(Header.Nonce，Header.MixDigest等)是否正确，来确定该区块是否已经经过Seal操作。</span></span><br><span class="line">	VerifySeal(chain ChainReader, header *types.Header) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于初始化区块头的共识字段根据共识引擎。这些改变都是内联执行的。</span></span><br><span class="line">	Prepare(chain ChainReader, header *types.Header) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 完成所有的状态修改，并最终组装成块。</span></span><br><span class="line">	<span class="comment">// 区块头和状态数据库在最终确认的时候可以被更新使之符合共识规则。</span></span><br><span class="line">	<span class="comment">// receipts表示返回显示交易结果</span></span><br><span class="line">	Finalize(chain ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction,</span><br><span class="line">		uncles []*types.Header, receipts []*types.Receipt) (*types.Block, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Seal()函数可对一个调用过Finalize()的区块进行授权或封印，并将封印过程产生的一些值赋予区块中剩余尚未赋值的成员(Header.Nonce, Header.MixDigest)。Seal()成功时返回的区块全部成员齐整，可视为一个正常区块，可被广播到整个网络中，也可以被插入区块链等。</span></span><br><span class="line">	Seal(chain ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回前一个块的hash</span></span><br><span class="line">	SealHash(header *types.Header) common.Hash</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算下一个块的难度</span></span><br><span class="line">	CalcDifficulty(chain ChainReader, time <span class="keyword">uint64</span>, parent *types.Header) *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回由共识引擎提供的RPC APIs </span></span><br><span class="line">	APIs(chain ChainReader) []rpc.API</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭共识，就是关闭挖矿的线程相关</span></span><br><span class="line">	Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们大致了解了共识需要实现的规则，先不做详细探讨，心里先有个底，具体内容会在后续文章中进一步分析</p>
<h2 id="读取链信息的部分接口"><a href="#读取链信息的部分接口" class="headerlink" title="读取链信息的部分接口"></a>读取链信息的部分接口</h2><p>共识毕竟是要涉及到链相关内容的操作的，在这个共识入口处，以太坊提供了一些访问本地链中<code>块</code>或者<code>块头部</code>的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 获取本地链的配置信息</span></span><br><span class="line">	Config() *params.ChainConfig</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回本地链当前块</span></span><br><span class="line">	CurrentHeader() *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据输入内容（块hash和块号），从链中返回一个块的头部信息</span></span><br><span class="line">	GetHeader(hash common.Hash, number <span class="keyword">uint64</span>) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过块号从db中返回块</span></span><br><span class="line">	GetHeaderByNumber(number <span class="keyword">uint64</span>) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过块hash返回块</span></span><br><span class="line">	GetHeaderByHash(hash common.Hash) *types.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据输入内容（块hash和块号），从db中返回一个块</span></span><br><span class="line">	GetBlock(hash common.Hash, number <span class="keyword">uint64</span>) *types.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>consensus.go</code>这个文件告诉了我们，要实现一个公式算法需要实现特定引擎，为我们设计自己共识算法提供了一个比较好的思路。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.5讲-rpc 订阅模块解读</title>
    <url>/articles/eafc7a8a/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以太坊的rpc是拥有订阅功能的，这里大概介绍一下这个订阅功能</p>
<a id="more"></a>
<h2 id="订阅方法的规则"><a href="#订阅方法的规则" class="headerlink" title="订阅方法的规则"></a>订阅方法的规则</h2><p>rpc注册service的时候，也可以注册订阅。<br>这个过程请参考：<a href="/articles/6fa9e36">以太坊源码解读-第5.4讲-http rpc server相关源码详解</a><br>其中主要就是判断一个结构体的某个方法是属于订阅方法还是普通方法。<br>可在源码<code>rpc-&gt;utils.go-&gt;isPubSub(methodType reflect.Type)</code>这里找到。<br>订阅方法的规则如下（必须满足以下<code>5</code>点要求）：</p>
<ol>
<li>方法参数个数必须<code>&gt;1</code>个</li>
<li>方法返回参数个数必须<code>=2</code>个</li>
<li>方法第一个参数必须是<code>context</code></li>
<li>方法第一个返回参数必须是<code>Subscription</code>类型的</li>
<li>方法第二个返回参数必须是<code>error</code>类型的</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.4讲-http rpc server相关源码详解</title>
    <url>/articles/6fa9e36/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章<a href="/articles/5e9143bf">以太坊源码解读-第5.3讲-http rpc的启动流程分析</a>的基础上，我们继续深入探索以太坊的rpc机制.<br>在<a href="/articles/e10014d8">以太坊源码解读-第5.2讲-rpc源码解读</a>中，小编也介绍过rpc的实现，但涉及的有点广，可能并不太容易理解，为此，本文将结合http rpc的注册流程来讲解一下rpc的实现。</p>
<a id="more"></a>
<p>我们已经得知，http rpc的调用流程方式是：<br><code>创建server：rpc.NewServer()</code>-&gt;<code>注册service：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code>-&gt;<code>停止监听：n.httpListener.Close()</code>-&gt;<code>服务停止：n.httpHandler.Stop()</code><br>下面我们一步步来了解每个过程是如何进行的。</p>
<p><code>ps</code>：先前我么已经得知，rpc总共有4类，这里小编由于时间和精力，只介绍<code>http rpc</code>的调用细节。<br><code>pps</code>：注意server和service的区别，下文中很多地方将会涉及到。</p>
<h2 id="第一步：创建server"><a href="#第一步：创建server" class="headerlink" title="第一步：创建server"></a>第一步：创建server</h2><p>进入到这个<br>先来看一下创建server（<code>rpc-&gt;server.go</code>）的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">  <span class="comment">//实例化一个server</span></span><br><span class="line">	server := &amp;Server&#123;</span><br><span class="line">		services: <span class="built_in">make</span>(serviceRegistry),</span><br><span class="line">		codecs:   set.New(),</span><br><span class="line">		run:      <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先注册一个RPC Service，该services是一个空的</span></span><br><span class="line">  <span class="comment">//将server加入到RPCService中</span></span><br><span class="line">  rpcService := &amp;RPCService&#123;server&#125;</span><br><span class="line">  <span class="comment">//此处MetadataApi=“rpc”</span></span><br><span class="line">	server.RegisterName(MetadataApi, rpcService)</span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，可以得知以下几个重要信息：</p>
<ol>
<li>创建的server是被加入到<code>RPCService</code>中的。这个<code>RPCService</code>结构体如下：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCService <span class="keyword">struct</span> &#123;</span><br><span class="line">	server *Server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>返回的是一个server</li>
<li>可以大胆想象，之后所有的service注册后，都会被添加到第一个<code>RPCService</code>中的server，也就是说，<code>RPCService</code>管理着其余所有的<code>service</code></li>
</ol>
<h3 id="第一步：Server相关结构体"><a href="#第一步：Server相关结构体" class="headerlink" title="第一步：Server相关结构体"></a>第一步：Server相关结构体</h3><p>创建过程中，涉及到了Server相关结构，很重要，很有必要掌握。<br>在<code>rpc-&gt;types.go</code>中，对<code>server</code>和<code>service</code>的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//service使用传入的名称作为key来区分</span></span><br><span class="line"><span class="keyword">type</span> serviceRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*service </span><br><span class="line"></span><br><span class="line"><span class="comment">//用于标准化注册进来的服务</span></span><br><span class="line"><span class="comment">//这是以太坊每个功能模块提供的服务，都是在模块的api.service中</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span>        <span class="comment">// service的名称</span></span><br><span class="line">	typ           reflect.Type  <span class="comment">// 类型，反射的</span></span><br><span class="line">	callbacks     callbacks     <span class="comment">// 回调方法的集合</span></span><br><span class="line">	subscriptions subscriptions <span class="comment">// 订阅/发布集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry  <span class="comment">//用来存储service</span></span><br><span class="line">	run      <span class="keyword">int32</span>  <span class="comment">//用来控制server是否可运行，1为运行，非1为不可运行</span></span><br><span class="line">	codecsMu sync.  <span class="comment">//用来保护多线程访问codecs的锁</span></span><br><span class="line">	codecs   *set.Set  <span class="comment">//用来存储所有的编码解码器，其实就是所有的连接。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，每一个<code>service</code>都会被装填到<code>server</code>中（也就是注册，具体注册细节后面会专门讲到），了解过geth启动流程后，会明白，这里的<code>service</code>表示的是每个以太坊功能模块api.service中的东西。这个<code>api</code>在rpc中是有定义的(同样是在types.go中)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> API <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="keyword">string</span>      <span class="comment">// 在该命名空间下，service的方法被公开</span></span><br><span class="line">	Version   <span class="keyword">string</span>      <span class="comment">// 给dapp展示的api版本号</span></span><br><span class="line">	Service   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 这个就是要被注册到server中的service</span></span><br><span class="line">	Public    <span class="keyword">bool</span>        <span class="comment">// 在公共使用中，指示方法是否为安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>service</code>中的callbacks和subscriptions其实都是callbacks，这个是rpc回调用到的。结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]*callback      <span class="comment">// 回调方法的集合，可以看出是一个map</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback  <span class="comment">// 订阅的集合，也可以看出是一个map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">	rcvr        reflect.Value  <span class="comment">// 反射出方法的值</span></span><br><span class="line">	method      reflect.Method <span class="comment">// 反射出方法本身</span></span><br><span class="line">	argTypes    []reflect.Type <span class="comment">// 输入的参数</span></span><br><span class="line">	hasCtx      <span class="keyword">bool</span>           <span class="comment">// 检测第一个参数是否为context，</span></span><br><span class="line">	errPos      <span class="keyword">int</span>            <span class="comment">// 返回错误的索引err，无法返回则为-1</span></span><br><span class="line">	isSubscribe <span class="keyword">bool</span>           <span class="comment">// 该callback是否为订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二步：注册service"><a href="#第二步：注册service" class="headerlink" title="第二步：注册service"></a>第二步：注册service</h2><ol>
<li>前面创建<code>server</code>时候，我们已经发现其注册了一个<code>RPCService</code>，并且将<code>server</code>填充到了<code>RPCService</code>中。创建返回的结果是该<code>server</code>，之后的<code>service</code>都是在该<code>server</code>下注册的，也就是说，<code>RPCService</code>管理着之后的所有<code>service</code>。</li>
<li>前面我们也知道了，http rpc会调用<code>rpc-&gt;server.go</code>中的<code>RegisterName()</code>方法来进行注册。</li>
<li>接下来我们就进一步分析整个注册流程。</li>
</ol>
<h3 id="RegisterName"><a href="#RegisterName" class="headerlink" title="RegisterName()"></a><code>RegisterName()</code></h3><p>先来看一下<code>rpc-&gt;server.go</code>注册的源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RegisterName 注册服务</span></span><br><span class="line"><span class="comment">//传入的rcvr可以是任意的，传入后都会被标准化处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.services = <span class="built_in">make</span>(serviceRegistry)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册进来的rcvr都被标准化为service</span></span><br><span class="line">	svc := <span class="built_in">new</span>(service)</span><br><span class="line">	svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, svc.typ.String())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断传进来的服务类型首字母是否为大写</span></span><br><span class="line">	<span class="keyword">if</span> !isExported(reflect.Indirect(rcvrVal).Type().Name()) &#123;</span><br><span class="line">		fmt.Println(reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s is not exported&quot;</span>, reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到服务的回调方法和订阅</span></span><br><span class="line">	methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据name判断，若services中已经有了该service，则直接更新方法和订阅</span></span><br><span class="line">	<span class="keyword">if</span> regsvc, present := s.services[name]; present &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(methods) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> methods &#123;</span><br><span class="line">			<span class="comment">//使用首字母小写的方法名作为key来保存该service的最新的方法</span></span><br><span class="line">			regsvc.callbacks[formatName(m.method.Name)] = m</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> subscriptions &#123;</span><br><span class="line">			<span class="comment">//使用首字母小写的订阅名作为key来保存该service的最新的订阅</span></span><br><span class="line">			regsvc.subscriptions[formatName(s.method.Name)] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//更新完后，则退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	svc.name = name</span><br><span class="line">	svc.callbacks, svc.subscriptions = methods, subscriptions</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(svc.subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将service保存在server中</span></span><br><span class="line">	s.services[svc.name] = svc</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册阶段，会反射解析传入的service，有可能是普通的rpc，也有可能是订阅，根据各自的规则进行判断，比如订阅规则，可参考<a href="/articles/eafc7a8a">以太坊源码解读-第5.5讲-rpc 订阅模块解读</a>.<br>从上面代码也可知道，真正解析service的是<code>suitableCallbacks()</code>方法，它会将rpc普通方法和订阅解析出来。</p>
<h2 id="第三步：启动http监听"><a href="#第三步：启动http监听" class="headerlink" title="第三步：启动http监听"></a>第三步：启动http监听</h2><p>服务器注册完毕后，就该启动网络监听了。<br>在<code>rpc-&gt;http.go</code>中，<code>NewHTTPServer()</code>方法启动监听。<br>再来看看<code>http rpc</code>是怎样启动网络监听的：<code>go rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code><br>异步，开了个goroutine。<br>那就看看<code>NewHTTPServer()</code>的源码是什么：<br><code>ps</code>：大概看了下最新的代码<code>2018.11.09</code>的，结构稍微发生了点变化，但依旧用到了<code>NewHTTPServer()</code>，虽然该方法一直被标注为Deprecated，然并卵。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小编看的代码是两个月前的，貌似和最新版的的有些差距</span></span><br><span class="line"><span class="comment">//最新版本的代码在现有基础上，又加入了延时等操作，但不影响整体阅读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPServer</span><span class="params">(cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, srv *Server)</span> *<span class="title">http</span>.<span class="title">Server</span></span> &#123;</span><br><span class="line">	handler := newCorsHandler(srv, cors)  <span class="comment">//主要是浏览器读取时候的些问题设置</span></span><br><span class="line">	handler = newVHostHandler(vhosts, handler) <span class="comment">//host的设置</span></span><br><span class="line">	<span class="keyword">return</span> &amp;http.Server&#123;Handler: handler&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四、五步：停止监听"><a href="#第四、五步：停止监听" class="headerlink" title="第四、五步：停止监听"></a>第四、五步：停止监听</h2><p>这本身就是http内部的工作机制，<br>net.Listener.Close()<br>server.stop（）这个可以看源码去，不复杂，就不解释了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，rpc server端的启动就结束了，应该还好理解吧</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.3讲-http rpc的启动流程分析</title>
    <url>/articles/5e9143bf/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可先了解下这两节：<br><a href="/articles/25c7447">以太坊源码解读-第5.1讲-rpc官翻及个人理解</a><br><a href="/articles/e10014d8">以太坊源码解读-第5.2讲-rpc源码解读</a><br>以太坊中，总共有四种rpc服务，分别是<code>InProc</code>、<code>IPC</code>、<code>Http</code>、<code>Ws(websockets)</code>，本文是通过介绍<code>Http rpc</code>的整个过程来了解以太坊rpc的情况。</p>
<a id="more"></a>

<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><h3 id="http的配置"><a href="#http的配置" class="headerlink" title="http的配置"></a>http的配置</h3><ol>
<li><p>先按如下顺序来找到这么个入口：<br><code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)-&gt;makeConfigNode(ctx)</code><br>这个主要是完成以太坊的启动配置过程，这块的大意是，对<code>Eth模块</code>、<code>Shh模块</code>、<code>Node模块</code>、<code>Dashboard模块</code>进行配置，先给他们提供默认配置，然后检查是否有用户自定义的<code>toml</code>配置文件，若有，则覆盖默认配置，在此选择用默认配置。</p>
</li>
<li><p>先要说明一下，http相关配置是在<code>Node模块</code>中进行的，最后其余所有的模块都是注册到<code>Node模块中</code>，<code>Node</code>结构大体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  config   *Config          <span class="comment">// http相关主要就是在该Config中配置的</span></span><br><span class="line">  services     <span class="keyword">map</span>[reflect.Type]Service <span class="comment">// 当前正在运行的服务（模块），以太坊把每个模块的功能都统一成service，然后注册到node.services中</span></span><br><span class="line">  rpcAPIs       []rpc.API   <span class="comment">// 所有模块的rpcAPIs都放在其中统一管理</span></span><br><span class="line">  <span class="comment">//http相关其余配置</span></span><br><span class="line">  httpEndpoint  <span class="keyword">string</span>       <span class="comment">// HTTP endpoint (interface + port) to listen at (empty = HTTP disabled)</span></span><br><span class="line">  httpWhitelist []<span class="keyword">string</span>     <span class="comment">// HTTP RPC modules to allow through this endpoint</span></span><br><span class="line">  httpListener  net.Listener <span class="comment">// HTTP RPC listener socket to server API requests</span></span><br><span class="line">  httpHandler   *rpc.Server  <span class="comment">// HTTP RPC request handler to process the API requests</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/articles/5e9143bf/1.png" class="" title="geth启动过程">
</li>
<li><p>这里我们主要关心http的配置，直接看对<code>Node模块</code>配置情况：<code>defaultNodeConfig</code>以及<code>defaultNodeConfig-&gt;node.DefaultConfig</code>，其中有对http的基本配置，具体解释看下面代码注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultNodeConfig</span><span class="params">()</span> <span class="title">node</span>.<span class="title">Config</span></span> &#123;</span><br><span class="line">	cfg := node.DefaultConfig</span><br><span class="line">	cfg.Name = clientIdentifier</span><br><span class="line">	cfg.Version = params.VersionWithCommit(gitCommit)</span><br><span class="line">  cfg.HTTPModules = <span class="built_in">append</span>(cfg.HTTPModules, <span class="string">&quot;eth&quot;</span>, <span class="string">&quot;shh&quot;</span>)</span><br><span class="line">  <span class="comment">//在已有的modules基础上，再加上eth shh两个模块</span></span><br><span class="line">	cfg.WSModules = <span class="built_in">append</span>(cfg.WSModules, <span class="string">&quot;eth&quot;</span>, <span class="string">&quot;shh&quot;</span>)</span><br><span class="line">	cfg.IPCPath = <span class="string">&quot;geth.ipc&quot;</span></span><br><span class="line">	<span class="keyword">return</span> cfg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultConfig = Config&#123;</span><br><span class="line">  <span class="comment">// 节点信息默认的存放位置，mac、windows、others三个平台</span></span><br><span class="line">  DataDir:          DefaultDataDir(),</span><br><span class="line">  <span class="comment">// HTTP RPC server的默认端口，8545</span></span><br><span class="line">  HTTPPort:         DefaultHTTPPort,</span><br><span class="line">  <span class="comment">// 默认rpcapi接口提供方式，标示，其实就是api.namespace</span></span><br><span class="line">  HTTPModules:      []<span class="keyword">string</span>&#123;<span class="string">&quot;net&quot;</span>, <span class="string">&quot;web3&quot;</span>&#125;,</span><br><span class="line">  <span class="comment">// 虚拟主机地址</span></span><br><span class="line">  HTTPVirtualHosts: []<span class="keyword">string</span>&#123;<span class="string">&quot;localhost&quot;</span>&#125;,</span><br><span class="line">  <span class="comment">// 下面websockets和p2p相关，暂不考虑</span></span><br><span class="line">	WSPort:           DefaultWSPort,</span><br><span class="line">	WSModules:        []<span class="keyword">string</span>&#123;<span class="string">&quot;net&quot;</span>, <span class="string">&quot;web3&quot;</span>&#125;,</span><br><span class="line">	P2P: p2p.Config&#123;</span><br><span class="line">		ListenAddr: <span class="string">&quot;:30303&quot;</span>,</span><br><span class="line">		MaxPeers:   <span class="number">25</span>,</span><br><span class="line">		NAT:        nat.Any(),</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此步我们可以看出，http modules默认总共有<code>net</code>、<code>web3</code>、<code>eth</code>、<code>shh</code>四类的rpcapi，标示我们有4种方式调用api接口</p>
</li>
<li><p>http的进一步配置<br><code>makeConfigNode(ctx)-&gt;utils.SetNodeConfig(ctx, &amp;cfg.Node)-&gt;setHTTP(ctx, cfg)</code>，在其中可以发现，其余默认的一些配置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setHTTP</span><span class="params">(ctx *cli.Context, cfg *node.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalBool(RPCEnabledFlag.Name) &amp;&amp; cfg.HTTPHost == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		cfg.HTTPHost = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">		<span class="keyword">if</span> ctx.GlobalIsSet(RPCListenAddrFlag.Name) &#123;</span><br><span class="line">			cfg.HTTPHost = ctx.GlobalString(RPCListenAddrFlag.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCPortFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPPort = ctx.GlobalInt(RPCPortFlag.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCCORSDomainFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPCors = splitAndTrim(ctx.GlobalString(RPCCORSDomainFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCApiFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPModules = splitAndTrim(ctx.GlobalString(RPCApiFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ctx.GlobalIsSet(RPCVirtualHostsFlag.Name) &#123;</span><br><span class="line">		cfg.HTTPVirtualHosts = splitAndTrim(ctx.GlobalString(RPCVirtualHostsFlag.Name))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册<br>返回到<code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)</code>，其余配置好的模块（或者叫做服务）,都会被注册到<code>Node</code>中.<br>前面提到过，会有四个功能模块：<code>Eth模块</code>、<code>Shh模块</code>、<code>Node模块</code>、<code>Dashboard模块</code><br>这里提示一下，每个服务都会实现node中的下面这个接口：<br><code>node-&gt;service</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;   </span><br><span class="line">    Protocols() []p2p.Protocol  </span><br><span class="line">    APIs() []rpc.API  </span><br><span class="line">    Start(server *p2p.Server) error  </span><br><span class="line">    Stop() error  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结<br><code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)</code>主要做了两件事：</p>
</li>
<li><p>配置模块</p>
</li>
<li><p>注册模块到node</p>
</li>
</ol>
<h3 id="启动http-rpc过程"><a href="#启动http-rpc过程" class="headerlink" title="启动http rpc过程"></a>启动http rpc过程</h3><ol>
<li>前往：<br><code>cmd-&gt;geth-&gt;main.go-&gt;app.Run(os.Args)-&gt;geth-&gt;makeFullNode(ctx)-&gt;startNode(ctx, node)-&gt;utils.StartNode(stack)-&gt;stack.Start()-&gt;n.startRPC(services)</code>中，找到：<br><code>n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts);</code>，这一行就是用来启动http rpc的，看看它所需要的4个参数：</li>
<li>n.httpEndpoint，默认值为127.0.0.1</li>
<li>apis，默认值为所有的服务的api</li>
<li>n.config.HTTPModules，rpcapi的标示，前面提到过，默认给出：[“eth”,”shh”,”net”,”web3”]</li>
<li>n.config.HTTPCors 跨域资源共享，通过浏览器访问的化，需要设置它，</li>
<li>n.config.HTTPVirtualHosts 防攻击的设置，官方有解释，可以去看看，限制访问范围，默认：localhost</li>
<li>startHTTP还是很重要的，这里列出源码和注释：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化http以及启动http rpc服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// endpoint必须有</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 白名单其实就是modules，默认给出：[&quot;eth&quot;,&quot;shh&quot;,&quot;net&quot;,&quot;web3&quot;]</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个rpc server，并且注册服务，要求满足白名单条件</span></span><br><span class="line">	handler := rpc.NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			n.log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;service&quot;</span>, api.Service, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//启动 rpc</span></span><br><span class="line">	<span class="keyword">go</span> rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>总结<br>这个rpc启动流程：<br><code>创建：rpc.NewServer()</code>-&gt;<code>注册：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code></li>
</ol>
<h3 id="http-rpc-stop"><a href="#http-rpc-stop" class="headerlink" title="http rpc stop"></a>http rpc stop</h3><p>既然有启动，就有停止，这是停止的执行步骤：<br>在<code>node-&gt;node.go</code>中，和上面的<code>startHTTP</code>在同一目录中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stopHTTP terminates the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">stopHTTP</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.httpListener != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.httpListener.Close()</span><br><span class="line">		n.httpListener = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		n.log.Info(<span class="string">&quot;HTTP endpoint closed&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, n.httpEndpoint))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.httpHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.httpHandler.Stop()</span><br><span class="line">		n.httpHandler = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再次来梳理一下http rpc注册流程：<br><code>创建：rpc.NewServer()</code>-&gt;<code>注册：handler.RegisterName(api.Namespace, api.Service)</code>-&gt;<code>启动监听：rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)</code>-&gt;<code>停止监听：n.httpListener.Close()</code>-&gt;<code>服务停止：n.httpHandler.Stop()</code><br>原本打算把具体的rpc流程也顺带讲一下，但混在一起会乱，就先不提了。<br>本文梳理后，可以很清晰的了解到，以太坊是如何启动一项rpc服务的，为我们后来进一步研究rpc做了一些充分的准备。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊crypto模块的概览</title>
    <url>/articles/66d6f92e/</url>
    <content><![CDATA[<p>小编只敢说概览，密码学这片海洋，只是沾了沾脚。。。了解一下这个模块，对以太坊账户以及验证机制心里也就有个底了。了解后，有个好处就是，可以把它用在自己想用的地方。</p>
<a id="more"></a>

<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>以太坊中，对于数据的安全操作，都在以太坊官方的<code>crypto</code>代码中（要和golang官方提供的<code>crypto</code>区分），大致可以分为2部分：</p>
<ol>
<li>散列(sha3-Keccak算法)<br>对块的验证、pow中的hash碰撞、签名等等，都是使用<code>Keccak算法</code>来生成hash的，严格意义上讲，Keccak算法和标准的sha3算法并不一样，因此，这个安全散列算法应该称为Keccak算法。</li>
<li>签名（secp256k1算法）<br>该算法是一种椭圆曲线数字签名算法(ECDSA)，在比特币中已经得以应用，在以太坊中，是通过它来进行密钥生成、签名、验证、公钥账户地址转换）。在整个以太坊生态中，有举足轻重的作用。</li>
</ol>
<h2 id="Keccak算法"><a href="#Keccak算法" class="headerlink" title="Keccak算法"></a>Keccak算法</h2><ol>
<li>2015年以前,sha3的标准就是keccak，但后来，sha3标准修改了其中的“海绵算法”，导致之后两者没有太大关系。因此，为了更明确的区分，需要知道以太坊生成hash用的是<code>keccak安全散列算法</code>。</li>
<li>需要知道，该算法生成的散列长度是<code>32字节</code>，也就是<code>256位</code></li>
</ol>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>请参考这篇文章，原先转载的，里面很通俗的讲了keccak的原理：<a href="http://www.wjblog.top/articles/d7792efc">http://www.wjblog.top/articles/d7792efc</a></p>
<h3 id="以太坊中Keccak的操作"><a href="#以太坊中Keccak的操作" class="headerlink" title="以太坊中Keccak的操作"></a>以太坊中Keccak的操作</h3><p>下面是以太坊提供的一个单元测试用例：<br>其中：<br><code>abc</code>为用来生成hash的原文<br><code>4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45</code>为<code>abc</code>生成的hash<br>程序的大意就是，将<code>abc</code>生成hash，然后和预先设置的<code>abc</code>的hash做比较，看结果是否一致。<br>真正调用到<code>Keccak</code>的地方，只有这么一处：<code>Keccak256Hash(in)</code>，传入原文，返回hash结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestKeccak256Hash</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//原文转为字节数组</span></span><br><span class="line">	msg := []<span class="keyword">byte</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	<span class="comment">//将16进制的hash结果，转为2进制。用于稍后和原文生成的hash做比较</span></span><br><span class="line">	exp, _ := hex.DecodeString(<span class="string">&quot;4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45&quot;</span>)</span><br><span class="line">	<span class="comment">//Keccak256Hash(in)，原文生成hash</span></span><br><span class="line">	checkhash(t, <span class="string">&quot;Sha3-256-array&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(in []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123; h := Keccak256Hash(in); <span class="keyword">return</span> h[:] &#125;, msg, exp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkhash</span><span class="params">(t *testing.T, name <span class="keyword">string</span>, f <span class="keyword">func</span>([]<span class="keyword">byte</span>)</span> []<span class="title">byte</span>, <span class="title">msg</span>, <span class="title">exp</span> []<span class="title">byte</span>)</span> &#123;</span><br><span class="line">	sum := f(msg)</span><br><span class="line">	<span class="comment">//判断二者是否一致</span></span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(exp, sum) &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;hash %s mismatch: want: %x have: %x&quot;</span>, name, exp, sum)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="secp256k1签名"><a href="#secp256k1签名" class="headerlink" title="secp256k1签名"></a>secp256k1签名</h2><ol>
<li>这个签名算法需要比较深的密码学背景才能吃透，我根据自己掌握的密码学基础讲一下为什么选择椭圆曲线的算法作为以太坊密钥生成算法，<br>在密码学中，会有一个安全等级的划分。</li>
<li>通常，需要<code>2^n</code>次才能破解的算法，我们称为该算法拥有<code>n位安全等级</code>，通常分为四个等级：80位、128位、192位和256位四个等级，<br>这个模块比较复杂,如果要细度源码,需要对密码学有比较深入的理解,但是使用起来其实比较简单.不同算法为了保证某安全等级，所要使用的密钥长度如下：<table><tr><th>算法家族</th><th>密码体制</th><th colspan="4">安全级别（位）</th></tr><tr><td></td><td></td><td>80</td><td>128</td><td>192</td><td>256</td></tr><tr><td>离散分解<br>离散对数<br>椭圆曲线</td><td>RSA<br>DH、DSA、Elgamal<br>ECDH、ECDSA</td><td>1024位<br>1024位<br>160位</td><td>3072位<br>3072位<br>256位</td><td>7680位<br>7680位<br>384位</td><td>15360位<br>15360位<br>512位</td></tr><tr><td>对称密钥</td><td>AES、3DES</td><td>80位</td><td>128位</td><td>192位</td><td>256位</td></tr></table>
从对称与否、密钥长度和对应安全级别参考，综合考虑下来，椭圆曲线是不二之选。这是我个人的想法，不一定符合以太坊官方的考虑规则。</li>
<li>该算法主要就是密钥生成、签名,验证,以及公钥与以太坊地址转换</li>
<li>密钥长度是<code>256位</code>，需要切记。</li>
<li><code>2018-11-13补充</code>：常见的非对称加密算法除了椭圆加密算法之外，还有著名的RSA。椭圆加密相比RSA的区别是：<ol>
<li>椭圆加密的密钥更短</li>
<li>椭圆加密计算更快而安全性相当</li>
<li>RSA的私钥和公钥是何以互换加解密的，但椭圆加密只能私钥加密公钥解密。</li>
</ol>
</li>
<li>公钥、私钥<ol>
<li>私钥<br> 以太坊的私钥是一个32字节的数，取值范围从1~0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140。这个数可以由伪随机算法(PRNG)产生。其实0也是一个合法的私钥，只不过这是一个特殊私钥，以太坊的创世区块就是这个私钥生成的</li>
<li>公钥<br> 以太坊的非压缩公钥是一个65字节的数，这个是继承至比特币的。但以太坊只使用了其中64个字节，有一个字节这64个字节中，32字节表示椭圆曲线的X坐标，32字节表示椭圆曲线的Y坐标。这个XY坐标是私钥通过ECDSA-secp256k1推导出来的。所以说，椭圆曲线算法的公钥是通过私钥计算出来的。而反过来，用公钥推导私钥，以现有计算机的计算几乎是不可能的，这也是以太坊和比特币存在的基础。如果哪天计算机技术出现大飞跃，比如量子计算机普及，现有链上所有账户的私钥都会曝光。当然，区块链技术本身也会一定会持续演进的。</li>
</ol>
</li>
</ol>
<h3 id="公钥、私钥生成"><a href="#公钥、私钥生成" class="headerlink" title="公钥、私钥生成"></a>公钥、私钥生成</h3><p>crypto提供了随机生成私钥的方法，私钥是可以推导出公钥的：<br>私钥随机生成的随机数，使用golang自己的 crypto/rand.reader生成的<br>通过对以太坊中<code>cmd/geth/accountcmd.go</code>的源码分析（accountCreate方法中调用的keystore.StoreKey），发现就是通过下面这段代码来生成私钥地址的</p>
<p><code>备注：</code>私钥本质上就是一个 256 个二进制位的随机数字（2^256 ~ 10^77，目前可见宇宙中估计只含有 10^80 个原子）<br><em>这里遗留一个问题是，为什么这样生成不会出现重复的私钥？暂时还不明白。</em></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGenerateKey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	privateKey, _ := GenerateKey()</span><br><span class="line">	publicKey := privateKey.Public()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;privateKey:%v,\npublicKey:%x\v&quot;</span>, privateKey, publicKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="签名、验证"><a href="#签名、验证" class="headerlink" title="签名、验证"></a>签名、验证</h3><h4 id="1-签名"><a href="#1-签名" class="headerlink" title="1. 签名"></a>1. 签名</h4><p>secp256k1的私钥地址长度是<code>32字节256位</code>,公钥地址长度是65字节。<br>其中，需要注意的是，被签名的必须是32字节的hash；二签名后的数据，长度和公钥一样长。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16进制，256位的私钥，这个可以理解为是secp256k1的私钥，为方便测试，预先生成</span></span><br><span class="line"><span class="keyword">var</span> testPrivHex = <span class="string">&quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line">	key, _ := HexToECDSA(testPrivHex)</span><br><span class="line">	<span class="comment">//使用keccak生成原文&quot;foo&quot;的hash</span></span><br><span class="line">	msg := Keccak256([]<span class="keyword">byte</span>(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用密钥对原文对hash进行签名，该msg必须是32位的hash</span></span><br><span class="line">    <span class="comment">//生成的sign</span></span><br><span class="line">	sig, err := Sign(msg, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Sign error: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>为了方便，将上一步骤的代码也加入了下方，形成签名-&gt;验证两个环节<br>该过程主要就是从签名文件中拿到公钥，转换成以太坊地址，然后和测试提供的地址比较，是否一致。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个是测试用的账户地址，验证时候使用</span></span><br><span class="line"><span class="keyword">var</span> testAddrHex = <span class="string">&quot;970e8128ab834e8eac17ab8e3812f010678cf791&quot;</span></span><br><span class="line"><span class="comment">//一个256位的随机数，16进制，这个随机数是如何生成的，暂时还没研究，也是密码学里真随机和伪随机的概念</span></span><br><span class="line"><span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line"><span class="keyword">var</span> testPrivHex = <span class="string">&quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVerify</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">//根据这个随机数来生成密钥</span></span><br><span class="line">	key, _ := HexToECDSA(testPrivHex)</span><br><span class="line">	addr := common.HexToAddress(testAddrHex)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用keccak生成原文&quot;foo&quot;的hash</span></span><br><span class="line">	msg := Keccak256([]<span class="keyword">byte</span>(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用密钥对原文对hash进行签名，该msg必须是32位的hash</span></span><br><span class="line">	sig, err := Sign(msg, key)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;签名结果：%v\n&quot;</span>, sig)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Sign error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据签名和原文内容，提取出二进制公钥</span></span><br><span class="line">	recoveredPub, err := Ecrecover(msg, sig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;ECRecover error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将2机制公钥转换成16进制（65字节）的公钥序列</span></span><br><span class="line">	pubKey := ToECDSAPub(recoveredPub)</span><br><span class="line">	<span class="comment">//将公钥序列转换成账户地址，其实就是取公钥hash处理后的后20位作为地址</span></span><br><span class="line">	recoveredAddr := PubkeyToAddress(*pubKey)</span><br><span class="line">	<span class="comment">//验证生成的公钥地址和测试提供的地址是否一致</span></span><br><span class="line">	<span class="keyword">if</span> addr != recoveredAddr &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;Address mismatch: want: %x have: %x&quot;</span>, addr, recoveredAddr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公钥与地址的转换"><a href="#公钥与地址的转换" class="headerlink" title="公钥与地址的转换"></a>公钥与地址的转换</h3><p>上一步骤中已经提到了，我们说的以太坊账户地址并不是公钥地址，而是取的<code>公钥地址hash运算</code>后的后20位作为账户。<br>具体可以深入到代码中去理解。大概位置是：crypto.go中的PubkeyToAddress函数，调用的<code>common.BytesToAddress(Keccak256(pubBytes[1:])[12:])</code></p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs集群客户端操作</title>
    <url>/articles/ccf3d056/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讲的是ipfs集群客户端的操作，这种操作分为两类，一类是通过命令行来控制，另一类是通过restful api来操作，后者对于开发者来说，会有很大帮助。<br>操作本文内容前，需要先完成前两篇文章中的内容：<br><a href="/articles/7987f3ac">ipfs私有环境搭建</a><br><a href="/articles/ba940e6d">ipfs集群搭建</a></p>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li><code>ipfs-cluster-ctl</code>的使用，请参考：<a href="https://cluster.ipfs.io/documentation/ipfs-cluster-ctl/">https://cluster.ipfs.io/documentation/ipfs-cluster-ctl/</a></li>
<li>默认情况下<code>ipfs-cluster-ctl</code>的使用，需要保证<code>service.json</code>中的设置为：<code>api.restapi.http_listen_multiaddress: /ip4/127.0.0.1/tcp/9094</code></li>
<li>可以选择其中一台安装有ipfs-cluster-server的机器来安装ipfs-cluster-cli</li>
</ol>
<h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><ol>
<li><p>查看集群当前节点中的节点信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl peers ls </span><br></pre></td></tr></table></figure>
<img src="/articles/ccf3d056/1.png" class="" title="当前节点信息"></li>
<li><p>查看集群节点关系图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl health graph</span><br></pre></td></tr></table></figure>
<img src="/articles/ccf3d056/1.png" class="" title="集群拓扑信息">
</li>
<li><p>（补充）删除节点中的某个节点（集群节点）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl peers rm 集群节点</span><br></pre></td></tr></table></figure>
<h2 id="IPFS集群数据同步"><a href="#IPFS集群数据同步" class="headerlink" title="IPFS集群数据同步"></a>IPFS集群数据同步</h2><p>正常情况下，有被搜索过的数据才会被ipfs节点保存，要想让数据同步，需要集群的干预。<br>以上传一个<code>test.txt</code>文件为例，里面内容为:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure>
<h3 id="1-ipfs节点node1上传文件test-txt"><a href="#1-ipfs节点node1上传文件test-txt" class="headerlink" title="1. ipfs节点node1上传文件test.txt"></a>1. ipfs节点node1上传文件test.txt</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs add -r /<span class="built_in">export</span>/test.txt</span><br></pre></td></tr></table></figure>
<p>获得该文件的hash：QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</p>
</li>
</ol>
<h3 id="2-根据文件hash将数据同步到集群"><a href="#2-根据文件hash将数据同步到集群" class="headerlink" title="2. 根据文件hash将数据同步到集群"></a>2. 根据文件hash将数据同步到集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全网的ipfs节点repo 都存在该hash.</span></span><br><span class="line">ipfs-cluster-ctl pin add QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc :</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kzZ : PINNED | 2018-10-25T16:24:04Z</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kyZ : PINNED | 2018-10-25T16:24:04Z</span><br></pre></td></tr></table></figure>
<h3 id="3-通过pin检测ipfs节点是否有某hash对应的文件"><a href="#3-通过pin检测ipfs节点是否有某hash对应的文件" class="headerlink" title="3. 通过pin检测ipfs节点是否有某hash对应的文件"></a>3. 通过pin检测ipfs节点是否有某hash对应的文件</h3><p>前面步骤中，得到了上传文件的hash。<br>在另一个节点，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs pin ls QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<p>若返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc recursive</span><br></pre></td></tr></table></figure>
<p>则说明，该数据在该节点上</p>
<h3 id="4-检测集群同步数据状态"><a href="#4-检测集群同步数据状态" class="headerlink" title="4. 检测集群同步数据状态"></a>4. 检测集群同步数据状态</h3><p>可查看集群中文件的同步状态，此命令在某一节点删除文件后有延迟，延迟时间尚不确定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl status</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc :</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kzZ : PINNED | 2018-10-25T16:24:04Z</span><br><span class="line">    &gt; iZt4ne720rsobv353yq8kyZ : PINNED | 2018-10-25T16:24:04Z</span><br></pre></td></tr></table></figure>
<h3 id="5-跟踪集群中文件的同步状态"><a href="#5-跟踪集群中文件的同步状态" class="headerlink" title="5. 跟踪集群中文件的同步状态"></a>5. 跟踪集群中文件的同步状态</h3><p>和上面的命令<code>ipfs-cluster-ctl status</code>稍微有所不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl sync</span><br></pre></td></tr></table></figure>
<h3 id="6-集群取消同步某个hash文件"><a href="#6-集群取消同步某个hash文件" class="headerlink" title="6. 集群取消同步某个hash文件"></a>6. 集群取消同步某个hash文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-ctl pin rm QmcxC7pxf96yiUyxzkUPoewMMtJst2cFAKQq8CMKXuCSdc</span><br></pre></td></tr></table></figure>
<h2 id="http-rest-api说明以及测试"><a href="#http-rest-api说明以及测试" class="headerlink" title="http rest api说明以及测试"></a>http rest api说明以及测试</h2><h3 id="rest-api"><a href="#rest-api" class="headerlink" title="rest api"></a>rest api</h3><p>参考官方提供的说明：<a href="https://cluster.ipfs.io/developer/api/">https://cluster.ipfs.io/developer/api/</a><br>通过它，可以很方便的使用开发操作</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="bash">http://192.168.3.100:9094/id
http://192.168.3.100:9094/version
```·</code></pre>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>storate</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs集群搭建</title>
    <url>/articles/ba940e6d/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是讲ipfs私有集群的搭建，本文是在上一篇文章<a href="/articles/7987f3ac">ipfs私有环境搭建</a>的基础上进一步搭建的。文中涉及到小编项目隐私的内容，已经做了脱敏处理。</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ipfs集群同步，同时要对集群管理，在已有环境的基础上，还需要再加入如下项目:<br><code>https://github.com/ipfs/ipfs-cluster</code><br>其中分为两个部分</p>
<ol>
<li><code>ipfs-cluster-service</code>：集群服务端<br>下载地址：<code>https://dist.ipfs.io/ipfs-cluster-service/v0.6.0/ipfs-cluster-service_v0.6.0_linux-amd64.tar.gz</code></li>
<li><code>ipfs-cluster-ctl</code>：集群客户端<br>下载地址：<code>https://dist.ipfs.io/ipfs-cluster-ctl/v0.6.0/ipfs-cluster-ctl_v0.6.0_linux-amd64.tar.gz</code></li>
</ol>
<h2 id="集群配置要求"><a href="#集群配置要求" class="headerlink" title="集群配置要求"></a>集群配置要求</h2><ol>
<li>每个ipfs节点都要安装<code>ipfs-cluster-service</code></li>
<li>其中一个或者某几个节点安装<code>ipfs-cluster-ctl</code>来和前端交互</li>
<li>该安装过程略，都是可执行程序，加个环境变量就可以</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>分别配置<code>ipfs-cluster-service</code>和<code>ipfs-cluster-ctl</code></p>
<h3 id="ipfs-cluster-service"><a href="#ipfs-cluster-service" class="headerlink" title="ipfs-cluster-service"></a>ipfs-cluster-service</h3><ol>
<li>每个ipfs节点都要执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipfs-cluster-service init</span><br></pre></td></tr></table></figure>
此时会在<code>/home/wj/</code>中生成一个新目录：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── peerstore     #  存储当前连接集群节点地址</span><br><span class="line">├── raft          #  是ipfs的协议共识机制</span><br><span class="line">│   ├── raft.db</span><br><span class="line">│   └── snapshots</span><br><span class="line">└── service.json  #  集群service端配置文件</span><br></pre></td></tr></table></figure></li>
<li><code>service.json</code>说明<ol>
<li>该文件是集群server端核心配置文件</li>
<li>在该目录下生成的service.json中的<code>cluster.id</code>，表示集群当前节点的id，不是ipfs的节点id，注意区分。</li>
<li>在centos7中，是在此处生成：<code>/root/.ipfs-cluster/service.json</code></li>
</ol>
</li>
<li>选择一个管理节点<br>管理节点的作用是，集群中，以该节点作为主节点<br>还是上面的<code>service.json</code>，<br>在此选择node1节点作为集群的管理节点：<code>cluster.id: QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN</code><br><code>&quot;secret&quot;: &quot;2437f6e6a0b223e4ae0896efc68271939d000003151c5eeb1bad48d2a666584b&quot;</code></li>
<li>修改管理节点ip连接：<br><code>ps</code>:其余每个节点也要做类似操作，将ip改成自己所在节点的<code>地址</code>，不能是<code>域名</code><br>有的文章中将<code>service.json</code>中，下面的地址改成127.0.0.1之外的ip，但是经过测试，后面集群同步会有问题，且效率低下，因此，如无必要或者对这些不熟悉，不建议修改，默认值即可。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ip问题，以下为默认值，不建议修改</span></span><br><span class="line"><span class="comment"># 对外开放api，若有需要，可以修改此处ip</span></span><br><span class="line"><span class="attr">api.restapi.http_listen_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/9094</span></span><br><span class="line"><span class="comment"># 节点连接ipfs</span></span><br><span class="line"><span class="attr">ipfs_connector.ipfshttp.node_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/5001</span></span><br><span class="line"><span class="comment"># 节点监听</span></span><br><span class="line"><span class="attr">ipfs_connector.ipfshttp.proxy_listen_multiaddress:</span> <span class="string">/ip4/127.0.0.1/tcp/9095</span></span><br></pre></td></tr></table></figure>
<code>2018.10.26补充</code>：经过多次尝试，以上几个ip设置的都是默认的127.0.0.1,这样可以增加安全性，公网rest api无法直接访问其中的端口。若想要完全开放，只要将ip全改为<code>0.0.0.0</code>即可。<br><code>2018.10.27补充</code>：为了方便开发和测试，将node2节点此处的相关ip都设置成<code>0.0.0.0</code>。</li>
</ol>
<h3 id="ipfs-cluster-ctl"><a href="#ipfs-cluster-ctl" class="headerlink" title="ipfs-cluster-ctl"></a>ipfs-cluster-ctl</h3><p>安装好即可，不用额外处理，具体可看下一个笔记，客户端管理集群</p>
<h2 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h2><h3 id="启动管理节点"><a href="#启动管理节点" class="headerlink" title="启动管理节点"></a>启动管理节点</h3><p>启动管理节点的ipfs-cluster-serivce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ipfs-cluster-service daemon &amp;</span><br></pre></td></tr></table></figure>
<p>此时日志会有该管理节点地址，记录下，下一步用到：<br><code>/ip4/192.168.3.100/tcp/9096/ipfs/QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN</code></p>
<h3 id="其余节点启动并加入管理节点之中"><a href="#其余节点启动并加入管理节点之中" class="headerlink" title="其余节点启动并加入管理节点之中"></a>其余节点启动并加入管理节点之中</h3><p>其余每个节点都执行启动，都要和管理节点连通，注意，只能用ip地址，<code>不能用域名</code>，无法识别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ipfs-cluster-service daemon --bootstrap /ip4/192.168.3.100/tcp/9096/ipfs/QmXr7xVQmdVW45RPBnor2M3G600000PyktuZz5QLpN59QN &amp;</span><br></pre></td></tr></table></figure>
<h2 id="ipfs节点内容测试"><a href="#ipfs节点内容测试" class="headerlink" title="ipfs节点内容测试"></a>ipfs节点内容测试</h2><p>其中<code>QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2</code>，为原先上传的一张图片</p>
<pre><code>http://192.168.3.101:8080/ipfs/QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2/

http://192.168.3.100:8080/ipfs/QmbvBDKPhdHMVDthaafapqsis9g4YorjRp3bTLc4v7ZMp2/
```·</code></pre>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>storate</tag>
      </tags>
  </entry>
  <entry>
    <title>ipfs私有环境搭建</title>
    <url>/articles/7987f3ac/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讲的是ipfs私有环境的配置，使用两个节点。</p>
<a id="more"></a>

<h2 id="ubuntu相关"><a href="#ubuntu相关" class="headerlink" title="ubuntu相关"></a>ubuntu相关</h2><h3 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h3><ol>
<li>服务器1（节点1）:<a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x33;&#x2e;&#x31;&#48;&#48;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x33;&#x2e;&#x31;&#48;&#48;</a><ol>
<li>ipfs第一节点</li>
<li>密码已修改******</li>
</ol>
</li>
<li>服务器2（节点2）:<a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#51;&#x2e;&#49;&#x30;&#x31;">&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#51;&#x2e;&#49;&#x30;&#x31;</a><ol>
<li>ipfs第二节点</li>
<li>密码已修改******</li>
</ol>
</li>
<li>hosts文件：<br>虽然hosts中配置如下内容，但经测试发现，还是得用ip，用域名会产生异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.3.100 node1</span><br><span class="line">192.168.3.101 node2</span><br></pre></td></tr></table></figure>
<h3 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h3></li>
<li><code>~/app/</code> ：为方便管理，手动安装的软件统一放在此处<ol>
<li><code>~/app/golang/go</code>：go安装目录</li>
<li><code>~/app/golang/gopath</code>：gopath位置</li>
</ol>
</li>
<li>docker镜像相关映射目录，均放在<code>~/docker</code>中<ol>
<li><code>~/docker/ipfs</code>：ipfs相关</li>
</ol>
</li>
<li><code>/usr/local/bin</code>：部分执行文件直接放于此处<ol>
<li><code>/usr/local/bindocker-compose</code>:不解释</li>
</ol>
</li>
</ol>
<h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>其余基本配置和安装，此处略</p>
<h2 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h2><p>其余基本的依赖安装、服务启动相关，此处不描述</p>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><ol>
<li>更新apt<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get  update</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  docker</span><br></pre></td></tr></table></figure></li>
<li>安装docker.io<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker.io</span><br></pre></td></tr></table></figure></li>
<li>安装docker-registry<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  docker-registry</span><br></pre></td></tr></table></figure></li>
<li>此时docker已经启动，若未启动，执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="ipfs启动"><a href="#ipfs启动" class="headerlink" title="ipfs启动"></a>ipfs启动</h3>此时会同时初始化<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name ipfs -v ~/docker/ipfs/<span class="built_in">export</span>:/<span class="built_in">export</span> -v ~/docker/ipfs/data:/data/ipfs -p 4001:4001 -p 8080:8080 -p 5001:5001 ipfs/go-ipfs:latest</span><br></pre></td></tr></table></figure>
<h2 id="ipfs私有环境配置"><a href="#ipfs私有环境配置" class="headerlink" title="ipfs私有环境配置"></a>ipfs私有环境配置</h2></li>
</ol>
<h3 id="每个节点均执行以下步骤"><a href="#每个节点均执行以下步骤" class="headerlink" title="每个节点均执行以下步骤"></a>每个节点均执行以下步骤</h3><h4 id="生成共享key"><a href="#生成共享key" class="headerlink" title="生成共享key"></a>生成共享key</h4><p>私有网络，需要拥有相同key的节点在一起</p>
<ol>
<li>下载go相关依赖包：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen</span><br></pre></td></tr></table></figure></li>
<li>生成key<br><code>ipfs/data</code>中<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/docker/ipfs/data/swarm.key</span><br></pre></td></tr></table></figure></li>
<li>复制到另一个节点<br>需要保证每个节点都有相同的swarm.key，类似于网络许可证<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp ~/docker/ipfs/data/swarm.key 192.168.3.101:~/docker/ipfs/data/</span><br></pre></td></tr></table></figure>
<h4 id="删掉默认的ipfs可以发现的网络"><a href="#删掉默认的ipfs可以发现的网络" class="headerlink" title="删掉默认的ipfs可以发现的网络"></a>删掉默认的ipfs可以发现的网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs  ipfs bootstrap rm --all</span><br></pre></td></tr></table></figure>
<h4 id="重新启动发现"><a href="#重新启动发现" class="headerlink" title="重新启动发现"></a>重新启动发现</h4>docker镜像启动后，默认就会启动该服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs daemon</span><br></pre></td></tr></table></figure>
<h4 id="配置http-head"><a href="#配置http-head" class="headerlink" title="配置http head"></a>配置http head</h4>为了方便外部访问，比如5001的webui访问，需要修改配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /home/wj/docker/ipfs/data/config</span><br><span class="line">补全如下内容：</span><br><span class="line">  <span class="string">&quot;API&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;HTTPHeaders&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Server&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;go-ipfs/0.4.17&quot;</span></span><br><span class="line">      ]</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Methods&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
重启：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker restart ipfs</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>如此，就有一个节点生成了，此时已经是启动可发现状态</li>
<li>node1节点id：<code>QmNdi6ExJ9Rcpggf41uB7TYuHhPUBExg2fbV8V7TCXFj8Z</code></li>
<li>node2节点id：<br><code>QmSBQvCgomiMCdGULVdehLZFKXLpNRNyo67ZRk43g8mQpC</code></li>
</ol>
<h3 id="将其中一个节点加入到另一个节点"><a href="#将其中一个节点加入到另一个节点" class="headerlink" title="将其中一个节点加入到另一个节点"></a>将其中一个节点加入到另一个节点</h3><ol>
<li>若有多个节点，则选择其中一个节点做标准，然后加入到其它每个节点中，也就是说，若有A、B、C、D、E、F五个节点，选择节点A为标准，将节点A加入到B、C、D、E、F中。</li>
<li><code>ps</code>：因目前docker-compose还未使用，暂时直接添加ip，后面再用hosts文件来设置域名。</li>
<li>比如将节点2加入到节点1中<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs bootstrap add /ip4/192.168.3.100/tcp/4001/ipfs/QmNdi6ExJ9Rcpggf41uB7TYuHhPUBExg2fbV8V7TCXFj8Z</span><br></pre></td></tr></table></figure>
检查是否加入<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> ipfs ipfs swarm peers</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>目的：将一张图片加入到ipfs节点</li>
<li>因为使用的是docker，从外部映射的文件夹到ipfs中，也就是说，要将待上传图片test.jpg放在<code>/home/wj/docker/ipfs/export</code></li>
<li>然后执行：<pre><code class="bash">sudo docker exec ipfs ipfs add -r /export/test.jpg
```·</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>ipfs</category>
        <category>ipfs应用</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>evm架构梳理</title>
    <url>/articles/414c120c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间在看evm，不是说evm偏底层就不该了解。它是支撑整个ethereum运行等基石，把握了它才能把握了以太坊的整个设计方向。</p>
<a id="more"></a>
<p>小编这段时间研究后，只能说，真的是长见识了。。<br>小编把evm的代码抽离出来了，还没写完，等后面完的差不多了，就会提交到github<br>目前源码还没看完，只知道一个新建合约在evm中的整个流程</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>先上图，精心绘制的</p>
<img src="/articles/414c120c/1.png" class="" title="evm整体架构">

<h2 id="evm文件结构图"><a href="#evm文件结构图" class="headerlink" title="evm文件结构图"></a>evm文件结构图</h2><p>.<br>|____memory.go                    //数据内存管理，指令涉及到内存操作的部分<br>|____memory_table.go              //内存的读取等操作<br>|____opcodes.go                   //指令符号定义等<br>|____analysis.go<br>|____gas_table_test.go            //gas价格测试<br>|____gas_table.go                 //gas汇总<br>|____evm.go                       //evm创建字节码合约，调用合约的入口<br>|____gas.go                       //用于设定每个指令的gas费用<br>|____logger.go                    //日志<br>|____logger_test.go               //日志测试<br>|____int_pool_verifier_empty.go   //注意文件里面，顶部的+build符号，这是用来验证整数池是否正常的（初始化）<br>|____int_pool_verifier.go         //同上，这个过程是需要手动编译用的<br>|____interface.go                 //数据物理存储，调用的外部接口，指令sstore执行后保存会用到<br>|____analysis_test.go<br>|____instructions.go              //每条指令具体执行的函数<br>|____gen_structlog.go<br>|____contracts.go                 //预编译合约<br>|____contracts_test.go            //预编译合约测试<br>|____noop.go<br>|____instructions_test.go         //指令测试<br>|____opt_test.go                  //指令执行测试<br>|____doc.go<br>|____stack.go                     //栈，指令操作<br>|____stack_table.go               //栈验证的一些方法<br>|____common.go                    //一些公用的工具<br>|____interpreter.go               //解析指令，就是从合约字节编码中获取<br>|____intpool.go                   //整数池<br>|____jump_table.go                //指令执行方法的具体实现<br>|____contract.go                  //字节码合约，外部传入的编码被映射到其中<br>|____errors.go                    //错误管理</p>
<h2 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h2><p>其实图中已经讲的很详细，<br>看源码的话，建议从evm的create入手，看看创建一个字节码合约要经历哪些步骤。<br>另外一定要知道intpool、stack、memory的作用，另外，指令的定义，执行等，也一定要了解。否则很难明白这个evm在做什么。</p>
<h2 id="一些有意义的内容"><a href="#一些有意义的内容" class="headerlink" title="一些有意义的内容"></a>一些有意义的内容</h2><p>从源码中，小编了解到了一些内容：</p>
<ol>
<li>栈道深度是1024</li>
<li>一条指令不能超过8个字节，也就是64位</li>
<li>总共有7个硬分叉，在/go-ethereum/params/config.go中可以看出，难道是7次硬分叉？，其中<code>HomesteadBlock</code>、<code>ByzantiumBlock</code>、<code>ConstantinopleBlock</code>属于ethereum的3个里程碑，第4个还没出现，还在开发中 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsHomestead</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.HomesteadBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IsDAO returns whether num is either equal to the DAO fork block or greater.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsDAOFork</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.DAOForkBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsEIP150</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP150Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsEIP155</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP155Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsEIP158</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.EIP158Block, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsByzantium</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.ByzantiumBlock, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChainConfig)</span> <span class="title">IsConstantinople</span><span class="params">(num *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isForked(c.ConstantinopleBlock, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>忘了。。。。。。</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列5- abi编码（暂不更新本文）</title>
    <url>/articles/6065d2dc/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>abi是什么？<br>前面我们认识到的是智能合约直接在EVM上的表示方式，但是，比如我想用java端程序去访问智能合约的某个方法，难道让java开发人员琢磨透汇编和二进制的表示，再去对接？<br>这明显是不可能的，为此abi产生了。这是一个通用可读的json格式的数据，任何别的客户端开发人员或者别的以太坊节点只要指定要调用的方法，通过abi将其解析为字节码并传递给evm，evm来计算处理该字节码并返回结果给前端。<br>这个应该解释清楚了吧？</p>
<a id="more"></a>
<p>abi就起到这么一个作用，类似于传统的客户端和服务器端地址好交互规则，比如json格式的数据，然后进行交互。</p>
<p><code>忽略后面所写内容，暂不考虑</code></p>
<h2 id="先来看个案例"><a href="#先来看个案例" class="headerlink" title="先来看个案例"></a>先来看个案例</h2><p>我们创建一个合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span>(<span class="params">uint256 _a</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span>(<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行方法<code>setA(1)</code>，然后该方法会被解析成：<code>0xee919d500000000000000000000000000000000000000000000000000000000000000001</code>,总共36个字节，其中前4个字节取的是<code>setA(uint256)</code>经过keccak256运算生成的hash的前<code>4</code>个字节，剩下1为一个32字节的数据(uint256类型的数据，当然是32字节)<br><code>0xee919d500000000000000000000000000000000000000000000000000000000000000001</code>会被传到智能合约（比如solidity或别的可以接受的程序），它会将这些输入字节解释为方法调用，并为setA(1)执行适当的汇编代码。<br>流程如下：</p>
<img src="/articles/6065d2dc/1.png" class="" title="方法执行的整个流程">

<h2 id="外部方法调用"><a href="#外部方法调用" class="headerlink" title="外部方法调用"></a>外部方法调用</h2><p>编译好的合约是怎样处理输入源的？先来这么一个合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setA</span>(<span class="params">uint256 _a</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>本文暂停更新，待进一步搞懂后再继续更新</code></p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>快速实现以太坊免费空投token合约（揭开此类代币的假面）</title>
    <url>/articles/ebac0719/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在imtoken或者metamask中，输入一个智能合约，立马就会发收到空投币。<br>很激动是不是？不花手续费就能拿到币。然并卵，这只是套路，一切都是忽悠。。<br><code>小编的这句话是重点，一定要记住:</code>这种币是彻头彻尾的假币，在实际底层区块链地址上，根本没有这个币。<br>我们从ethscanner或者imtoken上看到的以为到账的数字，只是程序的玩笑，亲眼见到的未必是真的。。</p>
<p>先来看看这个功能是怎么实现的？作为娱乐和恶搞，这个还是蛮有意思的。。。。</p>
<a id="more"></a>

<h2 id="主要开发环境搭建"><a href="#主要开发环境搭建" class="headerlink" title="主要开发环境搭建"></a>主要开发环境搭建</h2><p>这不是本文的重点，就只大概解释一下</p>
<h3 id="开发工具：truffle"><a href="#开发工具：truffle" class="headerlink" title="开发工具：truffle"></a>开发工具：truffle</h3><p>小编有专门的系列博客来讲如何使用该工具，大家可以搜搜。小编实在Intellij idea下部署的该开发工具。<br>请自行初始化好该项目。</p>
<h3 id="钱包：Metamask"><a href="#钱包：Metamask" class="headerlink" title="钱包：Metamask"></a>钱包：Metamask</h3><p>这个是安装在google的插件，具体如何使用，请使用伟大的google。记得将Metamsk切换到Ropsten测试网络环境</p>
<h3 id="以太坊测试网：infura"><a href="#以太坊测试网：infura" class="headerlink" title="以太坊测试网：infura"></a>以太坊测试网：infura</h3><p>以太坊公链测试项目，一点也不显示。好的一点是，有专门的机构提供测试网络，我们一般是使用infura进行以太坊相关测试的。<br>具体怎么操作，还请google。<br>生成自己的账户，并记住<code>助记词</code>,后面要用</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>imtoken和metamask在用户输入合约地址时候，会调用合约的<code>balanceof()</code>方法，然后我们在这里做文章就行。<br>这就是原理。<br><code>还是记住，还是要记住，这个原理仅仅可以娱乐</code></p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>这里会列出实现的每个流程，小编只会在重要的地方多讲下</p>
<h3 id="truffle项目中引入依赖包"><a href="#truffle项目中引入依赖包" class="headerlink" title="truffle项目中引入依赖包"></a>truffle项目中引入依赖包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install openzeppelin-solidity   <span class="comment">//里面有很多按照官方规范实现的比较权威的合约案例和标准</span></span><br><span class="line">npm install truffle-hdwallet-provider   <span class="comment">//可以用来提供私钥签名</span></span><br></pre></td></tr></table></figure>
<h3 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h3><p>先上代码，后面来解释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;openzeppelin-solidity/contracts/token/ERC20/PausableToken.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract FreeAirToken is PausableToken &#123;</span><br><span class="line"></span><br><span class="line">    string public name;</span><br><span class="line">    string public symbol;</span><br><span class="line">    uint256 public airdropNum;</span><br><span class="line">    uint256 public constant decimals = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    string public version = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">    uint256 public currentSupply;</span><br><span class="line"></span><br><span class="line">    event Mint(uint256 currentSupply, address to, uint256 amount);</span><br><span class="line"></span><br><span class="line">    <span class="title">constructor</span>(<span class="params">address _owner, string _name, string _symbol, uint256 _totalSupply, address _admin, uint256 _airdropNum</span>) <span class="title">public</span> &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        name = _name;</span><br><span class="line">        symbol = _symbol;</span><br><span class="line">        totalSupply_ = _totalSupply * <span class="number">10</span> ** decimals;</span><br><span class="line">        currentSupply = <span class="number">0</span>;</span><br><span class="line">        airdropNum = _airdropNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        balances[_owner] = airdropNum * <span class="number">10</span> ** decimals;   <span class="comment">//看着貌似是写入自己地址了，但别忘了这是view方法，数据是没有真正存在磁盘中！！</span></span><br><span class="line">        <span class="keyword">return</span> balances[_owner];  <span class="comment">//呵呵，返回的这个数据只是方法内存临时返回的结果，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，整个ERC20合约token就是这么简单，上面合约的大意是：重写了erc20标准方法中的<code>balanceOf()</code>,这就是空投实现的秘密，因此,任何只要调用该方法的账户，都会显示你这个账户有真么多token，注意只是显示！！！。</p>
<h3 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h3><p>根目录使用truffle编译</p>
<h3 id="合约发布"><a href="#合约发布" class="headerlink" title="合约发布"></a>合约发布</h3><p>接着就要发布合约到测试网络了。</p>
<ol>
<li>在truffle项目根目录新建文件:<code>token_config.js</code>,输入如下内容：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&quot;HelloToken&quot;</span>,</span><br><span class="line">        symbol: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        totalSupply: <span class="number">1e7</span>, <span class="comment">//总发行量</span></span><br><span class="line">        owner: <span class="string">&quot;0x7c54124fBd7e21C822A3827572FC31c5b1663711&quot;</span>,</span><br><span class="line">        admin: <span class="string">&quot;0xc99d160ad804Ee5B7ac9552bEF3B25f53E659d79&quot;</span>, </span><br><span class="line">        airdropNum: <span class="number">1000</span>  <span class="comment">//空投，每个账户能拿到的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure></li>
<li>先在migrations/2_deploy_contracts.js文件中，做如下修改：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> FreeAirToken = artifacts.require(<span class="string">&quot;./FreeAirToken.sol&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../token_config.js&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">    deployer.deploy(FreeAirToken, config.owner,config.name, config.symbol, config.totalSupply, config.admin,config.airdropNum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在根根目录的truffle.js中配置发布网络：<br>因为我们是要发布在infura中，发布人是需要用私钥签名的，因此，这里需要提供Metamask的助记词。<br>记者写上自己的gas，不要太少。目前市场gasLimit已经达到800w。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HDWalletProvider = <span class="built_in">require</span>(<span class="string">&quot;truffle-hdwallet-provider&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> mnemonic = <span class="string">&quot;unaware myth decade hour tragic hazard ship desert orchard will cream reform&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    networks: &#123;</span><br><span class="line">        ropsten: &#123;</span><br><span class="line">            provider: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line">                HDWalletProvider(mnemonic, <span class="string">&quot;https://ropsten.infura.io/xxxxxxxx&quot;</span>) <span class="comment">//这里输入自己申请的infura测试网地址，记得用ropsten</span></span><br><span class="line">            &#125;,</span><br><span class="line">            network_id: <span class="number">3</span>,</span><br><span class="line">            gas: <span class="number">4712388</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>发布合约：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truffle migrate</span><br></pre></td></tr></table></figure></li>
<li>记着合约的地址：<br>就是小编上面列出来的信息里的这一行，这就是这个token合约的地址：<br>FreeAirToken: 0xd1cc0f89502c289b1d74c3d5d9ecf22d1b45d716</li>
</ol>
<p>接下来我们进入测试阶段</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>直接看测试结果:</p>
<img src="/articles/ebac0719/1.png" class="" title="空投领token">
<img src="/articles/ebac0719/2.png" class="" title="空投领token">
<p>ok，呵呵，账户多了token了，眼睛也是会欺骗人的。。。从底层来看，你账户依然一分没有，只是这些页面调用了小编说的那个方法而已，那个方法本身是不会真把token转给你的。</p>
<h2 id="为何说这个空投币是无效的？"><a href="#为何说这个空投币是无效的？" class="headerlink" title="为何说这个空投币是无效的？"></a>为何说这个空投币是无效的？</h2><p>合约中，我们设置了每个调用balanceOf的人，都能拿到1000个币，但是，这个balanceOf方法是view级别的，按照规范，这里面是不能进行磁盘存储类操作的，<br>因此，只是内存中返回了我们一个<code>假的1000</code>,真正地址上是没有这个1000的。<br>这也是别的平台调用调用这个balanceof方法会显示你有1000个币的原因</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记着天下没有免费的午餐，不要贪。。。空投币，没有靠谱项目方的，都是假的，不要轻易相信自己的眼睛。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>综合</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列4-动态数据处理</title>
    <url>/articles/639ef287/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是讲Solidity以及EVM对动态数据的复杂的数据类型的处理方式，了解了这些基本情况，对我们编写经济的合约或者设计新的vm，都有极大的帮助。<br>动态数据分为这三大类：</p>
<ol>
<li>映射(Mappings)：mapping(bytes32 =&gt; uint256)， mapping(address =&gt; string)等等</li>
<li>数组(Arrays)：[]uint256，[]byte等等</li>
<li>字节数组(Byte arrays)：只有两种类型：string，bytes<a id="more"></a>
本文参考的是Howard是量子链的大神的文章，末尾处有文章出处，根据小编的理解，做了大量的调整和补充。<br>指令集可参考：<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，里面有详细的汇总和解释<br>讲之前，小编先要给大家脑补一点：<br>把EVM理解为一个键-值(key-value)数据库，而每个key都限制为32字节。<br>另外，本文所有合约都是在Remix上编译的</li>
</ol>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>带有映射的一个简单合约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      items[<span class="number">0xc0fefe</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器开启<code>optimize</code>编译该合约。<br>映射存储相关字节码：<code>62c0fefe600090815260205260427f79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c55</code><br>对应的汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>       <span class="comment">//62 0xc0fefe，  将0xc0fefe压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>            <span class="comment">//60 0x0，       将0x0压入栈，此时栈中数据stack[c0x0fefe，0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>                <span class="comment">//90，           从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 c0x0fefe]</span></span><br><span class="line"><span class="symbol">DUP2</span>                 <span class="comment">//81，           栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 c0x0fefe 0x0]</span></span><br><span class="line"><span class="symbol">MSTORE</span>               <span class="comment">//52，           先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x20</span>           <span class="comment">//60 0x20，      将0x20压入栈，此时栈中数据stack[0x0 0x20]</span></span><br><span class="line"><span class="symbol">MSTORE</span>               <span class="comment">//52，           先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x42</span>           <span class="comment">//60 0x42，      将0x20压入栈，此时栈中数据stack[0x42]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH32</span> <span class="number">0x7982</span>...     <span class="comment">//60 0x7982...， 将0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C压入栈，此时栈中数据stack[0x42 0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;</span></span><br><span class="line"><span class="symbol">SSTORE</span>               <span class="comment">//55，           栈顶推出两位，将数值0x42存储在存储器的0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C的位置上。此时栈为空stack[]，内存数据memory&#123;&#x27;0x0位置存储c0x0fefe&#x27;，&#x27;0x20位置存储0x0&#x27;&#125;，此处发现这个内存貌似没什么用处。。。</span></span><br></pre></td></tr></table></figure>
<p>上面的指令是不是很诡异？还记得我们前面说的，evm看成是个k-v数据库，k有32字节。<br><code>0x7982...（32字节）</code>其实就是<code>0xc0fefe</code>使用<code>keccak256</code>哈希运算后的结果，用它来作为key。因为编译期间我们使用了<code>optimize</code>，Solidity会预先帮我们把<code>0xc0fefe</code>哈希生成<code>0x7982...（32字节）</code><br>也就是说，上面的两条<code>MSTORE</code>指令貌似并没什么卵用，这块Solidity的优化器要是能进一步完善下，没准就又可以省下几个gas了。<br><code>MSTORE</code>指令是进行内存操作，很便宜，操作一次3gas。</p>
<p>其实，Solidity编译器之所以可以预先将<code>0xc0fefe</code>哈希生成<code>0x7982...（32字节）</code>，是因为直接数组中设置的的常量，但如果改成是变量，那又会变成什么样子？我们继续往下分析。<br>也不是说上面的两个<code>MSTORE</code>没用，等看完小编后面写的内容，就知道若Solidity编译器的hash生成失效，汇编会用这两个内存值来进行汇编层次的hash运算。在上面的汇编代码中，只能说是Solidity优化不彻底。</p>
<p><code>ps:keccak256是一种hash计算标准，老权威了。。。</code></p>
<h2 id="汇编代码中的keccak256"><a href="#汇编代码中的keccak256" class="headerlink" title="汇编代码中的keccak256"></a>汇编代码中的<code>keccak256</code></h2><p>改造一下上面的合约，将<code>0xc0fefe</code>提到外部变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    uint256 i = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      items[i] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器开启<code>optimize</code>编译该合约。<br>映射存储相关字节码：<code>600154600090815260208190526040902060429055</code><br>对应的汇编指令：<br><code>ps:0xc0fefe存储在存储器0x1地址的汇编过程，小编这里就不列出来了，以下都是该过程完成后的操作</code></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>    <span class="comment">//60 0x1， 将0x0压入栈，此时栈中数据stack[0x1]</span></span><br><span class="line"><span class="symbol">SLOAD</span>        <span class="comment">//54，     取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处返回`0xc0fefe`，push到栈中。此时栈中数据stack[0xc0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>    <span class="comment">//60 0x0， 将0x0压入栈，此时栈中数据stack[0xc0fefe 0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0xc0fefe]</span></span><br><span class="line"><span class="symbol">DUP2</span>         <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0xc0fefe 0x0]</span></span><br><span class="line"><span class="symbol">MSTORE</span>       <span class="comment">//52，     先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储0xc0fefe&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x20</span>   <span class="comment">//60 0x20，将0x20压入栈，此时栈中数据stack[0x0 0x20]</span></span><br><span class="line"><span class="symbol">DUP2</span>         <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0x20 0x0]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0x0 0x20]</span></span><br><span class="line"><span class="symbol">MSTORE</span>       <span class="comment">//52，     先后pop出两个元素x,y，内存中将y存在x对应地址。此时栈中数据stack[0x0]，内存数据memory&#123;&#x27;0x0位置存储0xc0fefe&#x27;,&#x27;0x0位置存储0x20&#x27;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x40</span>   <span class="comment">//60 0x40，将0x20压入栈，此时栈中数据stack[0x0 0x40]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x40 0x0]</span></span><br><span class="line"><span class="symbol">KECCAK256</span>    <span class="comment">//20，     该过程在evm中是`SHA3操作`，pop出栈中两个元素偏离值m和大小n，结合内存中的两个数据x,y生成为32字节的hash，然后压入栈。此时栈中数据stack[0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]，内存数据memory&#123;&#125;</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x42</span>   <span class="comment">//60 0x42，将0x20压入栈，此时栈中数据stack[0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C 0x42]</span></span><br><span class="line"><span class="symbol">SWAP1</span>        <span class="comment">//90，     从栈顶起，将前两个数据交换。此时栈中数据stack[0x42 0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C]</span></span><br><span class="line"><span class="symbol">SSTORE</span>       <span class="comment">//55，     栈顶推出两位，将数值0x42存储在存储器的0x79826054EE948A209FF4A6C9064D7398508D2C1909A392F899D301C6D232187C地址。此时栈中数据stack[]</span></span><br></pre></td></tr></table></figure>
<p>这下应该知道<code>MSTORE</code>两次操作的目的了吧？<br>KECCAK256主要是操作栈和内存中的数据，成本大体为：</p>
<ol>
<li><p>操作一次KECCAK256需要支付30gas</p>
</li>
<li><p>每个32字节，需要支付6gas</p>
<p>小编这么理解KECCAK256从栈中的两个数据，这个过程的费用已经包含在30gas中，而内存中两个32字节的数据操作是需要手续费，每个6gas，总共费用为：30+6x2=42gas。<br>知道优化的重要性了吧？</p>
<p>are you ok？</p>
</li>
</ol>
<h2 id="映射大数值和打包问题"><a href="#映射大数值和打包问题" class="headerlink" title="映射大数值和打包问题"></a>映射大数值和打包问题</h2><p>只要记着，映射是按照32字节来处理，也就是说，当一个数据小于32字节的时候，按32字节处理，当大于32字节的时候，以32字节为单位递增。而且地址是连续的。<br>对于打包问题，可以这么说，以映射的设计方式，是不存在打包问题的。原因同上。<br>这个不复杂，请自行验证吧。</p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>动态数组是什么东西？这里就不用问小编了吧？<br>动态数组在Solidity中主要包含两大类：</p>
<ol>
<li>数组(Arrays)：[]uint256，[]byte等等</li>
<li>字节数组(Byte arrays)：只有两种类型：string，bytes</li>
</ol>
<p>需要知道的是，在Solidity中，数组是更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x290d...e563</span><br><span class="line">0x290d...e564</span><br><span class="line">0x290d...e565</span><br><span class="line">0x290d...e566</span><br></pre></td></tr></table></figure>
<p>动态数组拥有这样一些信息：</p>
<ol>
<li>length表示一共有多少个元素</li>
<li>边界检查。当读取或写入时索引值大于length就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小时，自动清除未使用的存储槽</li>
<li>字节数组bytes和string的特殊优化让短数组(小于32字节)存储更加高效</li>
</ol>
<h3 id="一个简单的动态数组"><a href="#一个简单的动态数组" class="headerlink" title="一个简单的动态数组"></a>一个简单的动态数组</h3><p>合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      chunks.push(<span class="number">0xAA</span>);</span><br><span class="line">      chunks.push(<span class="number">0xBB</span>);</span><br><span class="line">      chunks.push(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化器优化后的Solidity进行编译，汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>       stack[<span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>       stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>] store&#123;<span class="number">0x0</span>地址存入<span class="number">0x1</span>&#125;</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0x0</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">MSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span>] memory&#123;<span class="number">0x0</span>地址存入<span class="number">0x0</span>&#125;  此memory无效</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xAA</span>      stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0xAA</span>]</span><br><span class="line"><span class="symbol">PUSH32</span> <span class="number">0x290</span>... stack[<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="symbol">SWAP3</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xAA</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>] </span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x1&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x1&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">DUP5</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0x2</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x2&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xBB</span>      stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x1</span> <span class="number">0xBB</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP4</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x1</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0xBB</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span>] store&#123;<span class="string">&#x27;0x0地址存入0x2&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">DUP3</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SLOAD</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x1</span>]</span><br><span class="line"><span class="symbol">DUP2</span>            stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x1</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span> <span class="number">0x3</span>]</span><br><span class="line"><span class="symbol">SWAP1</span>           stack[<span class="number">0x0</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x3</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="symbol">SWAP3</span>           stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x3</span> <span class="number">0x0</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span>]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0xCC</span>      stack[<span class="number">0x2</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0xCC</span>]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>&#125;</span><br><span class="line"><span class="symbol">SWAP2</span>           stack[<span class="number">0xCC</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563</span> <span class="number">0x2</span>]</span><br><span class="line"><span class="keyword">ADD</span>             stack[<span class="number">0xCC</span> <span class="number">0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E565</span>]</span><br><span class="line"><span class="symbol">SSTORE</span>          stack[]  store&#123;<span class="string">&#x27;0x0地址存入0x3&#x27;</span>,<span class="string">&#x27;0xAA地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E563&#x27;</span>,<span class="string">&#x27;0xBB地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E564&#x27;</span>,<span class="string">&#x27;0xCC地址存入0x290DECD9548B62A8D60345A988386FC84BA6BC95484008F6362F93160EF3E565&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>哈哈，是不是crazy？小编把每步执行后，栈stack、内存memory、存储器storage中数据状态记录下了。<br>不想看上面代码的，小编直接来解释吧：</p>
<ol>
<li>内存memory没毛用，只是浪费gas。</li>
<li>总共执行了6次<code>SSTORE</code>指令，总共执行了3次<code>SLOAD</code>指令。小编按先后顺序解释下这几个命令具体干啥了<ol>
<li>第1次执行<code>SLOAD</code><br>去地址0x0读取当前数组长度，返回0</li>
<li>第1次执行<code>SSTORE</code><br>在地址0x0记录当前数组长度为1</li>
<li>第2次执行<code>SSTORE</code><br>在一个hash地址记录数据0xAA</li>
<li>第2次执行<code>SLOAD</code><br>去地址0x0读取当前数组长度，返回1</li>
<li>第3次执行<code>SSTORE</code><br>在地址0x0记录当前数组长度为2</li>
<li>第4次执行<code>SSTORE</code><br>在一个hash地址记录数据0xBB</li>
<li>第3次执行<code>SLOAD</code><br>去地址0x0读取当前数组长度，返回2</li>
<li>第5次执行<code>SSTORE</code><br>在地址0x0记录当前数组长度为3</li>
<li>第6次执行<code>SSTORE</code><br>在一个hash地址记录数据0xCC</li>
</ol>
</li>
</ol>
<p>看出来了吧，数组长度，每加入一个数据，则更新一次。两种数据都需要<code>sstore</code><br>所以说，相比较于动态数组，反而映射更加节省gas。</p>
<h2 id="动态数组打包"><a href="#动态数组打包" class="headerlink" title="动态数组打包"></a>动态数组打包</h2><p>这个小编就不详细讲了，前面<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>介绍了一些打包情况，<br>简单说就是，Solidity尽量优先填充满一个32字节的槽，尽量减少sstore的使用。<br>但是需要知道的是，由于数组需要进行边界检查和一些别的因素，动态数组中，每对一个数据存储，都需要执行一次<code>sstore</code>。就是说如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        s.length = <span class="number">4</span>;  <span class="comment">//执行1次sstore，第1个槽</span></span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;   <span class="comment">//执行2次sstore，第2个槽</span></span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;   <span class="comment">//执行3次sstore，第2个槽</span></span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;   <span class="comment">//执行4次sstore，第3个槽</span></span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;   <span class="comment">//执行5次sstore，第3个槽</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，用了3个槽，执行了5次<code>sstore</code>。占用的槽少了，但sstore次数一点不会少。</p>
<h2 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h2><p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度不大于31字节，第32个字节存储有效编码的长度（看了下面的实例就懂了）。长一点的字节数组跟正常数组的表示方式差不多。<br><code>string</code>和<code>bytes</code>的情况都一样，这里就只演示<code>bytes</code>了。<br>字节数组赋值短的数据和长的数据，会有什么情况？一个个来试试</p>
<h3 id="字节数组赋值短数据"><a href="#字节数组赋值短数据" class="headerlink" title="字节数组赋值短数据"></a>字节数组赋值短数据</h3><p>先看合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">        s.push(<span class="number">0xAA</span>);</span><br><span class="line">        s.push(<span class="number">0xBB</span>);</span><br><span class="line">        s.push(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化器编译后，指令就不展示了，一大坨。直接看看在数据在存储器中的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:   0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006</span><br></pre></td></tr></table></figure>
<p><code>value</code>最后面的06表示的是存储器此处的编码长度，而s的真实长度(长度问题在下面总结中描述原因)是：<code>编码长度/2=3</code>。<br>另外，也看出value中，数据是从左往右存储的。</p>
<h3 id="字节数组赋值长数据"><a href="#字节数组赋值长数据" class="headerlink" title="字节数组赋值长数据"></a>字节数组赋值长数据</h3><p>先看合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">       s.length = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接来看在存储器中是如何存储的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:   0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000101</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line"></span><br><span class="line">key:   0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566</span><br><span class="line">value: 0x0000000000000000000000000000000000000000000000000000000000000004</span><br></pre></td></tr></table></figure>
<p>可以看出，总共5个地址，也就是在四个槽里存了数据（一个key表示一个地址）：</p>
<ol>
<li>第1个0x0地址存储的是数据编码长度。数据的实际长度(长度问题在下面总结中描述原因)：<code>长度=（编码长度-1）/2</code>,也就是0x101 - 1）/2=128</li>
<li>第2到第5的4个槽，分别存放了数组里的四个数据</li>
<li>看key的 最后一位，这几个地址都是连续的</li>
</ol>
<h3 id="长字节短字节的总结"><a href="#长字节短字节的总结" class="headerlink" title="长字节短字节的总结"></a>长字节短字节的总结</h3><ol>
<li>字节数组的汇编代码相当多。除了正常的边界检查和数组恢复大小等，它还需要对长度进行编码/解码，以及注意长字节数组和短字节数组之间的转换。</li>
<li><code>为什么要编码长度？</code><br>因为编码之后，可以很容易的测试出来字节数组是长还是短。注意对于长数组而言编码长度总是奇数，而短数组的编码长度总是偶数。汇编代码只需要查看一下最后一位是否为0，为0就是偶数（短数组），非0就是奇数（长数组）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>相比较于动态数组，反而映射更加节省gas。</li>
<li>使用数组的复杂度超过了想象，</li>
<li>这一节，小编感觉已经很吃力了。。。</li>
<li>其实，走到这里，反而问题越来越多，为什么选择256？为什么这么复杂？越来越底层，小编感觉有点吃不消了，毕竟后面跟cpu等硬件兼容性考虑，实在不是小编的长项。只能点到为止了。小编也看了下qtum对evm的见解，想要理解到那种程度，还有好几个境界要走。</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列3-固定长度数据类型的处理</title>
    <url>/articles/8ddcbc00/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是讲Solidity以及EVM对数组、结构体等复杂的数据类型的处理方式，了解了这些基本情况，对我们编写经济的合约或者设计新的vm，都有极大的帮助。</p>
<a id="more"></a>
<p>本文参考的是Howard，是量子链的大神的文章，末尾处有文章出处，根据小编的理解，做了大量的调整和补充。<br>指令集可参考：<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，里面有详细的汇总和解释<br>另外，本文所有合约都是在Remix上编译的</p>
<h2 id="SLOAD和STORE指令的一些整理"><a href="#SLOAD和STORE指令的一些整理" class="headerlink" title="SLOAD和STORE指令的一些整理"></a>SLOAD和STORE指令的一些整理</h2><p>通过前一篇文章<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>我们了解到：</p>
<ol>
<li>合约的数据，在EVM中，是使用一个个的32字节的槽器来存储的</li>
<li>SSTORE和SLOAD指令消耗的手续费是普通指令的很多倍，并且在合约整个过程中，基本都是这两条指令来主导。</li>
</ol>
<p>结合前面，再做一些新的补充：</p>
<ol>
<li>合约中，声明变量时候，并没有在存储器中开辟空间，只是依次给出对应在存储器上的位置，不收手续费。只有真正往对应地址赋值的时候，才会计算手续费。</li>
<li><code>SLOAD</code>指令读取某个地址上的数据，若该地址没有被初始化（也就是未赋值或使用），则返回0x0</li>
<li>Solidity并没有非常智能，即使某个地址没有赋值，它也会去<code>SLOAD</code>来获取0x0，花费了gas。汇编角度看，完全可以直接用0x0取代此时<code>SLOAD</code>所扮演的角色。</li>
<li><code>若数据类型为uint256，即使存入的只是个位数的值，编译器也会为每个数据存入各自一个槽。</code></li>
</ol>
<h2 id="结构体的存储"><a href="#结构体的存储" class="headerlink" title="结构体的存储"></a>结构体的存储</h2><p>含有结构体的合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) <span class="title">public</span>&#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说一下这些变量在存储器槽的存储方式：t.a存在0x0位置、t.b存在0x01位置、t.c存在0x2位置。。。<br>编译，使用<code>optimize</code>设置</p>
<p>看看相应的字节码：<code>62c0fefe600555</code><br>再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5，   将0x5压入栈，此时栈中数据stack[0xc0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，       两数出栈，将0xc0fefe存储0x5地址之中</span></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，合约结构体中其余声明的变量，并没有被写入到存储器中，也就是说，只有<code>t.f</code>才会收取手续费</p>
<h2 id="固定长度数组"><a href="#固定长度数组" class="headerlink" title="固定长度数组"></a>固定长度数组</h2><p>含有固定长度数组的合约代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span>&#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，使用<code>optimize</code>设置。</p>
<p>看看相应的字节码：<code>62c0fefe600555</code><br>再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5，   将0x5压入栈，此时栈中数据stack[0xc0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，       两数出栈，将0xc0fefe存储0x5地址之中</span></span><br></pre></td></tr></table></figure>
<p>哈哈，和上面结构体的汇编是一模一样。</p>
<h2 id="数组边界检查"><a href="#数组边界检查" class="headerlink" title="数组边界检查"></a>数组边界检查</h2><p>上面我们看到结构体和数组存储布局以及指令都是一样的，但是如果我们编译时候去掉<code>optimize</code>配置，两者指令差距是蛮大的。<br>在数组中，Solidity会进行数组边界检查<br>先看看相应的字节码：<code>62c0fefe60006005600681101515602357fe5b0181905550</code><br>再看看汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH3</span> <span class="number">0xC0FEFE</span>  <span class="comment">//62 c0fefe，将0xC0FEFE压入栈，此时栈中数据stack[c0x0fefe]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>       <span class="comment">//60 0x0， 将0x0压入栈，此时栈中数据stack[c0x0fefe 0x0]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x5</span>       <span class="comment">//60 0x5， 将0x5压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x6</span>       <span class="comment">//60 0x6， 将0x6压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5 0x6]</span></span><br><span class="line"><span class="symbol">DUP2</span>            <span class="comment">//81，     从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[c0x0fefe 0x0 0x5 0x6 0x5]</span></span><br><span class="line"><span class="symbol">LT</span>              <span class="comment">//10，     栈中pop出栈顶元素x，与栈中新的栈顶元素y比较，栈顶修改为新的运算结果（x&lt;y，则y=1否则y=0）。此时栈中数据stack[c0x0fefe 0x0 0x5 1]</span></span><br><span class="line"><span class="symbol">ISZERO</span>          <span class="comment">//15，     判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。此时栈中数据stack[c0x0fefe 0x0 0x5 0]</span></span><br><span class="line"><span class="symbol">ISZERO</span>          <span class="comment">//15，     判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。此时栈中数据stack[c0x0fefe 0x0 0x5 1]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x23</span>      <span class="comment">//60 0x23，将0x23压入栈，此时栈中数据stack[c0x0fefe 0x0 0x5 1 23]</span></span><br><span class="line"><span class="symbol">JUMPI</span>           <span class="comment">//57，     栈中先后pop出两个值x,y，x表示跳转到第几个JUMPDEST，而y表示一个标记（若为0，则跳到下一个JUMPDEST）,若y不为0，则由x决定跳到第几个。此时栈中数据stack[c0x0fefe 0x0 0x5] </span></span><br><span class="line"><span class="symbol">INVALID</span>         <span class="comment">//无，      程序停止执行</span></span><br><span class="line"><span class="symbol">JUMPDEST</span>        <span class="comment">//5b，     JUMPI可跳到此处，继续执行后面的命令。此时栈中数据stack[c0x0fefe 0x0 0x5]</span></span><br><span class="line"><span class="keyword">ADD</span>             <span class="comment">//01，     stack[c0x0fefe 0x5]</span></span><br><span class="line"><span class="symbol">DUP2</span>            <span class="comment">//81，     stack[c0x0fefe 0x5 c0x0fefe]</span></span><br><span class="line"><span class="symbol">SWAP1</span>           <span class="comment">//90，     stack[c0x0fefe c0x0fefe 0x5]</span></span><br><span class="line"><span class="symbol">SSTORE</span>          <span class="comment">//55，     栈顶推出两位，将数值c0x0fefe存储在存储器的0x5的位置上。此时栈中数据stack[c0x0fefe],存储器数据store&#123;`c0x0fefe数值存在0x5地址`&#125;</span></span><br><span class="line"><span class="keyword">POP</span>             <span class="comment">//50，     丢弃栈顶数据。此时栈中数据stack[]，存储器数据store&#123;`c0x0fefe数值存在0x5地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从中可以看出，汇编中做了很多的判断，确保数据没有越界，若越界，程序则会退出。<code>JUMPI</code>和<code>JUMPDEST</code>作用小编是大概猜的，问题应该不大，等后面看了源码再来修改。<br>不过，明显感觉到编译器处理的优点啰嗦，也就是手Solidity还是有待提高的。</p>
<h2 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h2><p>上一篇文章：<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>中，对这一部分已经做了很详细的解释，很多位操作的技巧，终归一句话，Solidity编译器使用优化器（<code>optimize</code>）尽可能的将两个小规模的数打包到一个32字节的槽中，以便减少燃料费的使用。</p>
<h2 id="干扰优化器（optimize）"><a href="#干扰优化器（optimize）" class="headerlink" title="干扰优化器（optimize）"></a>干扰优化器（<code>optimize</code>）</h2><p>这次干扰的做法是，我们将变量放在不同的方法下赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    uint64 b;</span><br><span class="line">    uint64 c;</span><br><span class="line">    uint64 d;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      setAB();</span><br><span class="line">      setCD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setAB</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setCD</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>optimize</code>优化编译，生成的关键<code>armasm</code>汇编指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">tag1:</span>                                            <span class="comment">//结构体</span></span><br><span class="line">  JUMP [in]  setAB()                             <span class="comment">//跳转到tag5的setAB()方法</span></span><br><span class="line"><span class="symbol">tag4:</span></span><br><span class="line">  JUMP [in]  setCD()</span><br><span class="line"><span class="symbol">tag5:</span>                                            <span class="comment">//跳转到tag7的setAB()方法</span></span><br><span class="line">  JUMPDEST   <span class="meta">function</span> setAB() internal &#123;\n ...</span><br><span class="line">  ...                                            <span class="comment">//处理A，B</span></span><br><span class="line">  SSTORE                                         <span class="comment">//将A，B保存在本地</span></span><br><span class="line">  JUMP [out]                                     <span class="comment">//跳回到调用A，B的地方</span></span><br><span class="line"><span class="symbol">tag7:</span>                                            <span class="comment">//setCD()函数</span></span><br><span class="line">  JUMPDEST   <span class="meta">function</span> setCD() internal &#123;\n ...   </span><br><span class="line">  ...                                            <span class="comment">//保存C，D</span></span><br><span class="line">  SSTORE                                         <span class="comment">//将C，D保存在本地</span></span><br><span class="line">  JUMP [out]                                     <span class="comment">//跳回到调用C，D的地方</span></span><br></pre></td></tr></table></figure>
<p><code>ps：每个tag代表一个不同的模块</code><br>指令非常的长，小编只列出一些。这里我们主要能看到里面有两个<code>sstore</code>就行。<br>要知道，正常的优化中4个变量a、b、c、d加起来总共是32个字节，根据我们对<a href="/articles/4b0172c1"><code>《以太坊vm系列2-基础篇》</code></a>中<code>打包</code>的理解，应该是一次性写入存储器中的，也就是只调用一次<code>sstore</code>。<br>但是，这里<code>sstroe</code>却调用了两次。也就是说说，Solidity目前并不能优化垮方法的变量。</p>
<p>也就是说，为了减少<code>sstore</code>方法的调用，降低成本，我们目前最合适的做法就是将变量的赋值都写在同一个方法中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0xaaaa</span>;</span><br><span class="line">b = <span class="number">0xbbbb</span>;</span><br><span class="line">c = <span class="number">0xcccc</span>;</span><br><span class="line">d = <span class="number">0xdddd</span>;</span><br></pre></td></tr></table></figure>
<h2 id="再次干扰优化器（optimize）"><a href="#再次干扰优化器（optimize）" class="headerlink" title="再次干扰优化器（optimize）"></a>再次干扰优化器（<code>optimize</code>）</h2><p>这次的干扰我们的做法是，为定长数组中的每个变量赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>optimize</code>优化编译，生成的关键<code>armasm</code>汇编指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存数组到存储器</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure>
<p>ok，这里出现意外了，只调用了一次<code>SSTORE</code>。小编是参考的<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">Howard原文</a>，可能是Solidity的优化器升级的缘故，其中提到的调用4次<code>sstore</code>的情况并没有发生。<br>这次干扰在此算是被优化器抵御了。<br>好吧，这是一件好事，说明Solidity也在不断进步。也不影响我们继续探索，这里我们去掉<code>optimize</code>优化，重新编译下代码，再来看指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[0]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[1]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[2]到存储器</span></span><br><span class="line"><span class="symbol">SLOAD</span></span><br><span class="line"><span class="symbol">SSTORE</span>      <span class="comment">//保存numbers[3]到存储器</span></span><br></pre></td></tr></table></figure>
<p>呵呵，看出来了吧，优化和不优化，手续费差异蛮大的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Solidity会尽可能的打包将数据存在一个32字节的槽中</li>
<li>Solidity不能对跨方法对赋值进行优化。</li>
<li>相信Solidity会越走越好。</li>
</ol>
<blockquote>
<p>量子链-Howard英文原文：<a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a><br>xuli中文翻译：<a href="https://lilymoana.github.io/evm_part2.html">https://lilymoana.github.io/evm_part2.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列2-基础篇</title>
    <url>/articles/4b0172c1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vm这东西，要想自己搞任何链，这都是绕不开的一道坎。<br>对于写智能合约也一样很重要，要知道自己写下的每一个字符都是真金白银，合理的规划，会让你极大的减少不必要的开支。</p>
<a id="more"></a>
<p>原本想根据黄皮书来逐步了解vm的理念，时间和精力有限，打算结合一些现有的网络资料，编辑整理出自己对vm的理解。Howard是量子链的大神，有幸在以太坊线下沙龙中听了他的演讲，一个字：非常强。回来翻了下他的相关文章，发现他有很完整的以太坊vm讲解的文章，都是英文^^。。。<br>小编准备结合他的文章来以自己的方式了解到底vm是怎样运行的。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个合约写出来，传到vm后是如何处理的？燃料手续费是怎么样一个逻辑？为什么任意别的语言也可以开发合约？想要开发自己的公链，别的模块怎么和vm对接？等等。。。<br>带着种种问题，我们没有理由不去了解vm到底是怎么一回事。<br>好，我们一步步的来揭开这层神秘的面纱</p>
<h2 id="解析只有一个变量的合约"><a href="#解析只有一个变量的合约" class="headerlink" title="解析只有一个变量的合约"></a>解析只有一个变量的合约</h2><p>solidity编写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Remix编译（不要说不知道这是什么工具。。。）该合约，<br>我们获取了EVM字节码：<br>上面整个合约编辑后的字节码，16进制表示，evm中就是以这个来运行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6080604052348015600f57600080fd5b50600160008190555060358060256000396000f3006080604052600080fd00a165627a7a72305820c2f00be46981ed7116a7d8162fd0cb5c04c4571aa49f5fccbea4b90a5fe8f9290029</span><br></pre></td></tr></table></figure>
<p>·······································<br><code>2019-01-17 ps:</code><br>这部分内容可以不看，只是半年后的不同状况的补充，建议等了解本文全局后在看此处<br>新版本solidity编译后的字节码结果不太一样，可能对细节做了优化，先记录下来<br>6080604052348015600f57600080fd5b50600160005560358060226000396000f3006080604052600080fd00a165627a7a723058201504b6af3b58ab847e989f2345b4448a1d53d6107652ed711770c90cdb7d60890029<br>此时的<code>a=1</code>的字节码为：<code>6001600055</code>，指令优化，比原先减少了一半，此时指令为：<br>60 01<br>60 00<br>55<br>简洁明了，出栈后，直接把01存储在00位置，比原先简单多了<br>········································</p>
<p>上面的一坨信息，看的就头大，但不要急，我们先从合约中的简单的存储变量赋值来入手：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这个过程的字节码是：<code>6001600081905550</code>（先不用考虑怎么得来的），我们通过查看<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>，把它拆成一行一条指令</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">60</span> <span class="number">01</span> <span class="comment">//60是PUSH1指令，因此后面要跟另一个16进制数</span></span><br><span class="line"><span class="number">60</span> <span class="number">00</span> <span class="comment">//同理</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>为了更清晰的了解上面的内容，我们用<a href="/articles/715e1612">以太坊vm系列1-指令集汇总</a>中查出的结果重新描述一下汇编代码：<br><code>stack[]表示栈，store&#123;&#125;表示存储器</code>(后续均使用此表示)</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">01</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">00</span>  <span class="comment">//60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>      <span class="comment">//81    ，从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>     <span class="comment">//90    ，从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>    <span class="comment">//55    ，栈顶推出两位，将数值0x01存储在存储器的0x0的位置上。此时栈中数据stack[0x1],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>       <span class="comment">//50    ，丢弃栈顶数据。此时栈中数据stack[],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面分析中可知：Solidity是将<code>uint256 a</code>保存在<code>0x0</code>的位置上。</p>
<p>仔细观察，会发现<code>DUP2</code>、<code>SWAP1</code>    、<code>POP</code>命令都是多余的，去掉后，会更清晰，并且运行结果也一样：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">01</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">00</span>  <span class="comment">//60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1，0x0]</span></span><br><span class="line"><span class="symbol">SSTORE</span>    <span class="comment">//55    ，将数值0x01存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x1],存储器数据store&#123;`0x1数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="解析有两个变量的合约"><a href="#解析有两个变量的合约" class="headerlink" title="解析有两个变量的合约"></a>解析有两个变量的合约</h2><p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，<code>b=2</code>的过程的EVM字节码（a=1前面已解析）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6002600181905550</span><br></pre></td></tr></table></figure>
<p>对应的汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>  <span class="comment">//60 0x2，该过程可以用0x2表示,它是push(0x2)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x2]</span></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>  <span class="comment">//60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x2 0x1]</span></span><br><span class="line"><span class="symbol">DUP2</span>       <span class="comment">//81，   从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2 0x1 0x2]</span></span><br><span class="line"><span class="symbol">SWAP1</span>      <span class="comment">//90，   从栈顶起，将前两个数据交换。此时栈中数据stack[0x2 0x2 0x1]</span></span><br><span class="line"><span class="symbol">SSTORE</span>     <span class="comment">//55，   将数值0x02存储在存储器的0x1的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x2],存储器数据store&#123;`0x02数值存在0x1地址`&#125;</span></span><br><span class="line"><span class="keyword">POP</span>        <span class="comment">//50，   丢弃栈顶数据。此时栈中数据stack[],存储器数据store&#123;`0x1数值存在0x0地址`,`0x2数值存在0x1地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>可知，最终：<br>store{<code>0x1数值存在0x0地址</code>,<code>0x2数值存在0x1地址</code>}，也就是说a存在0x0地址，b存在0x1地址</p>
<h2 id="存储打包（合约初步优化）"><a href="#存储打包（合约初步优化）" class="headerlink" title="存储打包（合约初步优化）"></a>存储打包（合约初步优化）</h2><p>上面案例中，我们将每个数据都保存在了一个地址，其实每个地址可以看作是一个槽，一个槽可以放下32字节的。要是每个16字节的变量分别都放在32字节的不同槽中，会很浪费空间的，并且存储在不同的槽每次都需要很高的手续费，要知道手续费可不是闹着玩的。<br>Solidity提供的优化方案：尽量将小一点的两个数据打包并存储在同一个槽中。<br>把合约改为如下样子，a和b都使用uint128，也就是16个字节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128 a;</span><br><span class="line">    uint128 b;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，<code>a=1;b=2;</code>对应EVM字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">60016000806101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff1602179055506002600060106101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550</span><br></pre></td></tr></table></figure>
<p>对应汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">a<span class="number">=1</span>:</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                 <span class="comment">//60 0x1，    该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                 <span class="comment">//60 0x0，    该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>                                      <span class="comment">//80，        从栈顶起，将栈中第1个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH2</span> <span class="number">0x100</span>                               <span class="comment">//61 0x100    占用2个字节，将值256压入栈。此时栈中数据stack[0x1 0x0 0x0 0x100]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                       <span class="comment">//0a          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算出结果为1，然后1字节存储到栈中。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                     <span class="comment">//54          取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处db中不存在对应数据，返回0x0，push到栈中。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...  将16字节值0xFF...推入栈中。此时栈中数据stack[0x1 0x0 0x1 0x0 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02          栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x1 0x0 0x1 0x0 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                       <span class="comment">//19          栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x1 0x0 0x1 0x0 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x1 0x0 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90          从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x0 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP4</span>                                      <span class="comment">//83          从栈顶起，将栈中第4个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...  将16字节值0xFF...推入栈中。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x1 0x0 0x0 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02          栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x1 0x0 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                        <span class="comment">//17          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x1 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90          从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x1 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                    <span class="comment">//55          栈顶开始，前两项。将数据0x1保存在0x0地址,此时store&#123;`0x1数值存在0x0地址`&#125;。此时栈中数据stack[0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>                                       <span class="comment">//50          栈中数据推出。此时栈中数据stack[]。</span></span><br><span class="line"></span><br><span class="line">b<span class="number">=2</span>:</span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                 <span class="comment">//60 0x2，     该过程可以用0x2表示,它是push(0x2)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                 <span class="comment">//60 0x0，     该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x2,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x10</span>                                <span class="comment">//60 0x10，    将数值0x10压入栈中。此时栈中数据stack[0x2,0x0,0x10]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH2</span> <span class="number">0x100</span>                               <span class="comment">//60 0x100，   将数值0x100压入栈中。此时栈中数据stack[0x2,0x0,0x10,0x100]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                       <span class="comment">//0a           从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81           从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                     <span class="comment">//54           取出栈顶元素，转为hash长度（表示在db中的地址），在db中读取出对应值为1，将其压入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP2</span>                                      <span class="comment">//81           从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...   将16字节值0xFF...推入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0x100000000000000000000000000000000,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02           栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                       <span class="comment">//19           栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1,0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16           栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x2,0x0,0x100000000000000000000000000000000,0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90           从栈顶起，将前两个数据交换。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP4</span>                                      <span class="comment">//83           从栈顶起，将栈中第4个元素复制并加入栈顶。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH16</span> <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span> <span class="comment">//6f 0xFF...   将16字节值0xFF...推入栈中。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                       <span class="comment">//16           栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x2,0x0,0x1,0x100000000000000000000000000000000,0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MUL</span>                                       <span class="comment">//02           栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x2,0x0,0x1,0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                        <span class="comment">//17           栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x2,0x0,0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                     <span class="comment">//90           从栈顶起，将前两个数据交换。此时栈中数据stack[0x2,0x200000000000000000000000000000000,0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                    <span class="comment">//55           栈顶开始，前两项。将数据0x200000000000000000000000000000000保存在0x0地址,此时store&#123;`0x200000000000000000000000000000000数值存在0x0地址`,`0x1数值存在0x0地址`&#125;。此时栈中数据stack[0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">POP</span>                                       <span class="comment">//50           栈中数据推出。此时栈中数据stack[]。</span></span><br></pre></td></tr></table></figure>
<p>一路把这些蛋疼的指令整理后，会发现<code>a=1</code>和<code>b=2</code>都存在了同一个地址，完整的存储形式是这样子：<code>[0x0000000000000000000000000000000200000000000000000000000000000001]</code>,低16个字节存1，高16个字节存2，倒数第二行的<code>SSTORE</code>的指令应该是进行了或操作。<br>指令分析完了，有什么用呢？先看看各指令手续费情况：</p>
<ol>
<li><code>sstore</code>指令第一次写入一个新位置需要花费20000 gas</li>
<li><code>sstore</code>指令后续写入一个已存在的位置需要花费5000 gas</li>
<li><code>sload</code>指令的成本是200 gas</li>
<li><code>其余</code>大多数的指令成本是3～10 gas</li>
</ol>
<p>知道手续费成本后，我们就明白，将两个变量写入同一个槽中，按照上面指令：<code>sstore</code>指令使用2次，费用25000gas；<code>sload</code>指令使用2次，费用1000gas；整体大概用了26000的gas。这比分别写在不同槽中，节省了将近15000gas。<br>这里不知道大家是否发现，<code>SLOAD</code>命令，我们明明知道这个0x0地址没有值，结果肯定是值0x0，却还要用指令去读取，无辜花费了手续费,这是Solidity语言的不足之处。此处若直接用值0x0替代<code>SLOAD</code>，将会剩下不少手续费，期待后面Solidity语言的优化吧。</p>
<h2 id="合约进一步优化"><a href="#合约进一步优化" class="headerlink" title="合约进一步优化"></a>合约进一步优化</h2><p>从上面的指令中进一步研究发现，如果能将<code>a=1</code>和<code>b=2</code>这两个128位的数只调用一次<code>sstroe</code>存储指令就将其存储，还可以再节省5000gas。<br>Solidity中提供了这样一个方式来实现此目的，即在编译命令中加入<code>--optimize</code>，如：<code>solc --bin --asm --optimize test.sol</code>。<br>小编使用的是<code>Remix</code>，如下图操作选中<code>optimize</code>即可:</p>
<img src="/articles/4b0172c1/1.png" class="" title="Remix启用optimize">
<p>（合约源码紧接上一部分的）编译后，<code>a=1;b=2;</code>对应EVM字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055</span><br></pre></td></tr></table></figure>
<p>对应汇编指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x0</span>                                   <span class="comment">//60 0x0，      该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">DUP1</span>                                        <span class="comment">//80，          从栈顶起，将栈中第1个元素复制并加入栈顶。此时栈中数据stack[0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SLOAD</span>                                       <span class="comment">//54，          取出栈顶元素，转为hash长度（表示在db中的地址），在db中是否存在对应值,并读取出,此处db中不存在对应数据，返回0x0，push到栈中。此时栈中数据stack[0x0 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH17</span> <span class="number">0x200000000000000000000000000000000</span>  <span class="comment">//70 0x200...， 将17字节值0x200...推入栈中。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000]        </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x80</span>                                  <span class="comment">//60 80，       将值0x80压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x80]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                   <span class="comment">//60 0x2，      将值0x2压入栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x80 0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                         <span class="comment">//0a，          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0x1 0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SUB</span>                                         <span class="comment">//03，          栈中推出栈顶元素，减去新的栈顶元素，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x0 0x200000000000000000000000000000000 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOT</span>                                         <span class="comment">//19，          栈顶数据取反，但实际运算还需要转为补码。此时栈中数据stack[0x0 0x0  0x200000000000000000000000000000000 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                       <span class="comment">//90，          从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0x0 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 0x200000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP2</span>                                       <span class="comment">//91，          栈顶元素和它下面的第2项进行交换，此时栈中数据stack[0x0 0x200000000000000000000000000000000 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                         <span class="comment">//16，          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x0 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                          <span class="comment">//17，          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x1</span>                                   <span class="comment">//60 0x1，      将值0x1压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x80</span>                                  <span class="comment">//60 80，       将值0x80压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x80]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">PUSH1</span> <span class="number">0x2</span>                                   <span class="comment">//60 0x2，      将值0x2压入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x80 0x2]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXP</span>                                         <span class="comment">//0a，          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算结果进栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0x1 0x100000000000000000000000000000000]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SUB</span>                                         <span class="comment">//03，          栈中推出栈顶元素，减去新的栈顶元素，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span>                                         <span class="comment">//16，          栈中取出前两个数据进行与运算，结果推入栈。此时栈中数据stack[0x0 0x200000000000000000000000000000000 0x1]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">OR</span>                                          <span class="comment">//17，          栈中pop出栈顶元素，与栈中新的栈顶元素或运算，栈顶修改为新的运算结果。此时栈中数据stack[0x0 0x200000000000000000000000000000001]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SWAP1</span>                                       <span class="comment">//90，          从栈顶起，将前两个数据交换。此时栈中数据stack[0x200000000000000000000000000000001 0x0]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SSTORE</span>                                      <span class="comment">//55，          栈顶开始，前两项。将数值0x200000000000000000000000000000001存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[],存储器数据store&#123;`0x200000000000000000000000000000001数值存在0x0地址`&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面指令中可以看出，Solidity使用了一系列的运算，生成<code>0x200000000000000000000000000000001</code>,然后一次性将其写入存储器中，正好32个字节。</p>
<h2 id="关于Gas的考虑"><a href="#关于Gas的考虑" class="headerlink" title="关于Gas的考虑"></a>关于Gas的考虑</h2><p>关于上面合约中<code>a=1;b=2</code>的字节码，仔细观察：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055</span><br></pre></td></tr></table></figure>
<p>我们发现字节码中直接使用了<code>200000000000000000000000000000000</code>,而不是用指令<code>exp(0x2, 0x81)</code>来计算，原因很简单，因为前者便宜，我们来看看对于手续费的标准：</p>
<ol>
<li>一笔交易的每个零字节的数据或代码费用为<code>4 gas</code></li>
<li>一笔交易的每个非零字节的数据或代码的费用为<code>68 gas</code></li>
</ol>
<p>根据这个标准，我们来计算一下<code>200000000000000000000000000000000</code>的费用：</p>
<ol>
<li>一个非0数<code>2</code>，费用为<code>68gas</code></li>
<li>32个<code>0</code>，费用为<code>32*4=128gas</code></li>
<li>公共gas费用：<code>128+68=196gas</code></li>
</ol>
<p>再来计算一下使用<code>exp(0x2, 0x81)</code>费用：</p>
<ol>
<li><code>exp(0x2, 0x81)</code>的字节码为：<code>608160020a</code>,即指令：<code>PUSH 0x81 PUSH 0x02 EXP</code></li>
<li>其中代码：<code>60</code>、<code>60</code>、<code>0a</code>总共3个，费用为<code>3*68=204gas</code></li>
<li>非0数：81、02,费用为<code>2*68=136gas</code></li>
<li>总共gas费用<code>204+136=340gas</code></li>
</ol>
<p>看，虽然后者字节码短，但是费用却要高很多。因此Solidity的字节码会生成为前者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>EVM的编译器实际上不会为字节码的大小、速度或内存高效性进行优化。相反，它会为gas的使用进行优化，这间接鼓励了计算的排序，让以太坊区块链可以更高效一点。<br>我们也看到了EVM一些奇特的地方：</p>
<ol>
<li>EVM是一个256位的机器。以32字节来处理数据是最自然的</li>
<li>持久存储是相当昂贵的</li>
<li>Solidity编译器会为了减少gas的使用而做出相应的优化选择</li>
<li>指令中涉及的位操作，小编也没有深究，也没有太多精力去深究，简单说一句是：位操作主要是用来优化汇编操作的，由Solidity的编译器来处理。</li>
</ol>
<p>Gas成本的设置有一点武断，也许未来会改变。当成本改变的时候，编译器也会做出不同的优化选择。</p>
<blockquote>
<p>量子链-Howard英文原文：<a href="https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30">https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30</a><br>xuli中文翻译：<a href="https://lilymoana.github.io/evm_part1.html">https://lilymoana.github.io/evm_part1.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊vm系列1-指令集汇总</title>
    <url>/articles/715e1612/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>EVM的重要性不言而喻，为方便后面进一步研究和探索，小编在此先列出其中涉及到的汇编指令。</p>
<a id="more"></a>
<p>这些指令在以太坊的源码中的位置：<code>src/github.com/ethereum/go-ethereum/core/vm/opcodes.go</code>,不太直观</p>
<h2 id="指令级"><a href="#指令级" class="headerlink" title="指令级"></a>指令级</h2><p><code>当前ethereum-go版本：1.8.4</code><br>指令的功能以及每个指令的费用，小编后面会根据使用情况，逐步补充的，一下子去写，量太大了</p>
<table style="border-collapse:collapse;border-spacing:0;border:none;border-color:#aaa"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">16进制</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">指令</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#f38630;text-align:center">功能描述</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x00</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">STOP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">停止</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x01</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">ADD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">两数相加</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x02</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MUL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">两数相乘</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x03</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SUB</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈中推出栈顶元素，减去新的栈顶元素，<br>栈顶修改为新的运算结果。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x04</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DIV</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">两个无符号数相除</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x05</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SDIV</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x06</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x07</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x08</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ADDMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x09</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">MULMOD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x0a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EXP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，依次取出2个元素，第一个元素为底数，<br>第二个元素为指数，计算结果进栈。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x0b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SIGNEXTEND</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈中pop出栈顶元素x，<br>与栈中新的栈顶元素y比较，<br>栈顶修改为新的运算结果（x</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">GT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SLT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SGT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">ISZERO</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">判断栈顶元素若大于0，则栈顶元素改为0，否则改为1。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">AND</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">与运算</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x17</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">OR</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈中推出栈顶元素，与新的栈顶元素或运算，<br>栈顶修改为新的运算结果。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x18</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">XOR</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x19</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">NOT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶数据取反，但实际运算还需要转为补码</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x1a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">BYTE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x20</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SHA3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">该过程在evm中是`SHA3操作`，<br>pop出栈中两个元素偏离值m和大小n，<br>结合内存中的两个数据x,y生成为32字节的hash，<br>然后压入栈。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x30</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ADDRESS</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x31</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">BALANCE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x32</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">ORIGIN</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x33</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLER</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x34</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALLVALUE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x35</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLDATALOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x36</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALLDATASIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x37</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLDATACOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x38</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CODESIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x39</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CODECOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x3a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">GASPRICE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x3b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">EXTCODESIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x3c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">EXTCODECOPY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x40</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">BLOCKHASH</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x41</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">COINBASE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x42</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">TIMESTAMP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x43</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">NUMBER</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x44</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DIFFICULTY</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x45</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">GASLIMIT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x50</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">POP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">丢弃栈顶元素</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x51</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MLOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x52</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">MSTORE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">先后pop出两个元素x,y，内存中将y存在地址x</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x53</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MSTORE8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x54</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SLOAD</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x55</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SSTORE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">将某数据存储到某个数据槽（地址），一个槽32字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x56</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">JUMP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x57</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPI</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈中先后pop出两个值x,y，x表示跳转到第几个JUMPDEST，<br>而y表示一个标记（若为0，则跳到下一个JUMPDEST）,<br>若y不为0，则由x决定跳到第几个。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x58</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PC</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x59</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">MSIZE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x5a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">GAS</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x5b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPDEST</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">JUMPI可跳到此处，继续执行后面的命令。<br>该指令只起一个flag作用，帮助跳转</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x60</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据1个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x61</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据2个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x62</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据3个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x63</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据4个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据5个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x65</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据6个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x66</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据7个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x67</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据8个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x68</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据9个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x69</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据10个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据11个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据12个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据13个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据14个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x6e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据15个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x6f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据16个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x70</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH17</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据17个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x71</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH18</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据18个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x72</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH19</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据19个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x73</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH20</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据20个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x74</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH21</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据21个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x75</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH22</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据22个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x76</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH23</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据23个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x77</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH24</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据24个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x78</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH25</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据25个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x79</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH26</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据26个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH27</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据27个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH28</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据28个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH29</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据29个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH30</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据30个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x7e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">PUSH31</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">二进制数据推送到栈顶，数据31个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x7f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH32</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">二进制数据推送到栈顶，数据32个字节</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x80</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第1个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x81</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第2个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x82</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第3个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x83</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第4个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x84</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第5个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x85</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第6个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x86</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第7个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x87</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第8个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x88</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第9个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x89</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第10个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第11个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第12个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第13个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第14个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x8e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">从栈顶起，将栈中第15个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x8f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">DUP16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">从栈顶起，将栈中第16个元素复制并加入栈顶</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x90</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第1项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x91</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第2项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x92</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第3项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x93</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第4项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x94</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第5项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x95</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第6项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x96</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第7项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x97</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第8项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x98</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第9项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x99</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP10</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第10项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9a</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP11</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第11项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9b</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP12</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第12项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9c</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP13</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第13项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9d</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP14</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第14项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0x9e</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SWAP15</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">栈顶元素和它下面的第15项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0x9f</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP16</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">栈顶元素和它下面的第16项进行交换</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xa1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LOG1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xa3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">LOG3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xa4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">LOG4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xb0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">PUSH</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xb1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DUP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xb2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">SWAP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CREATE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xf1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">CALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">CALLCODE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xf3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">RETURN</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xf4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">DELEGATECALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">0xfa</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center">STATICCALL</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xfd</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">REVERT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">0xfe</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">INVALID</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#FCFBE3;text-align:center;vertical-align:top">退出运行，该程序异常</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">0xff</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center">SELFDESTRUCT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:inherit;color:#333;background-color:#fff;text-align:center"></td></tr></table>

<blockquote>
<p>bytom：<a href="https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go">https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go</a><br>hayeah：<a href="https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go">https://github.com/Bytom/bytom/blob/master/protocol/vm/ops.go</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>POS权益证明解析</title>
    <url>/articles/fd535b82/</url>
    <content><![CDATA[<h2 id="POS-权益证明"><a href="#POS-权益证明" class="headerlink" title="POS-权益证明"></a>POS-权益证明</h2><p>全称是<code>Proof of Stake</code>,可以这么理解：拥有币越多并且持有币时间越长的人，越容易获得记账权。</p>
<a id="more"></a>
<p>POS是预先生成块合法的块，然后判断生成这些块的账户，谁的token最多，那就认为谁的块会被记录在主链中。为了方便理解，小编大概画一张图：</p>
<img src="/articles/fd535b82/1.png" class="" title="每一次生产块的pos流程">

<p>上图很形象的解释了pos机制，具体如下描述</p>
<ol>
<li>持有币的人首先选择是否参与生产块</li>
<li>所有参与者生成合法块，并将各自的块加入<code>待提议队列S</code></li>
<li>队列S中的每个块，根据块生产者持有的token数，将生产者地址以对应次数加入到<code>待胜选队列Q</code>中，比如生产者C有3个Token，则在队列Q中加入3次生产者C的地址。</li>
<li>从队列Q中随机选一个地址作为最终胜利者，它对应的块会被追加到主链中（可以看出，队列Q中，拥有token越多的生产者，越容易被认为是最中块的生产者）<br><code>注意，这第3步开始可以设置一个固定间隔时间来操作，比如每隔3秒，这样一来，就可以每3秒钟生产一个块了</code></li>
</ol>
<p>大体上就是这样一个流程，应该算是讲清楚了吧。这里小编有一个关于实现POS机制的源码，有兴趣的同学可以参考一下：<br><a href="https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pos">https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pos</a></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>上面一长串的介绍，详细大家对pos已经有了很深的了解，当然，真实的公链实现要远比上面复杂，但核心基本都一样。<br>POS的优点：节能：不需要挖矿，不会大量耗费电力和能源。其余优点暂不表态。<br>从上面原理和实现机制中，我们会发现，持币越多的人，被选中的概率越大，这也会导致一个中心化的问题。有的公链会使用PoW+PoS的双重机制来解决这个问题，通过PoW挖矿发行加密货币，使用PoS维护网络稳定。但小编认为这并不是权宜之计。</p>
<blockquote>
<p>参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识机制</tag>
      </tags>
  </entry>
  <entry>
    <title>POW共识机制解析</title>
    <url>/articles/131cedbf/</url>
    <content><![CDATA[<h2 id="POW-工作量证明机制"><a href="#POW-工作量证明机制" class="headerlink" title="POW-工作量证明机制"></a>POW-工作量证明机制</h2><p>全称是<code>Proof of Work</code>,比特币的诞生，使得这个共识机制得到了更多人的认识，在小编跟很多道友的接触中，明显能感到，他们更加认可这个共识，它是一个真正公平公正的共识机制。</p>
<a id="more"></a>
<p>这个共识机制的原理，其实一句话就可以解释：<code>通过大量的计算，找到一个满意的结果</code>，而专业的说法是：<code>大量Hash碰撞，找到一个符合要求的hash值</code><br>这个是pow算法的基本实现代码：<a href="https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pow">https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/pow</a></p>
<h2 id="比特币的共识"><a href="#比特币的共识" class="headerlink" title="比特币的共识"></a>比特币的共识</h2><p>小编认为，很有必要大致了解一下比特币的pow是如何实现的。<br>里面主要是三个概念：<code>difficulty</code>、<code>Target</code>、<code>Nonce</code>。</p>
<h3 id="difficulty"><a href="#difficulty" class="headerlink" title="difficulty"></a>difficulty</h3><p>也就是难度值，这个值保证了不管全网算力有多大，都能在10分钟左右生成一个块。这个值是在每个完整节点中独立自动发生的，每2016个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新2016个区块的花费时长与期望时长（期望时长为20160分钟即两周，是按每10分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。<br>公式如下：<code>新难度值 = 旧难度值 * ( 过去2016个区块花费时长 / 20160 分钟 )</code></p>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>即目标值。大量的计算是要有目标的，这个公式比特币是这样给出的：<br><code>目标值 = 最大目标值 / difficulty 其中最大目标值为一个恒定值：0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code><br>目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。</p>
<h3 id="Nonce"><a href="#Nonce" class="headerlink" title="Nonce"></a>Nonce</h3><p>Nonce值是用来参与hash运算的，它存在于区块头中，通过不停的变换这个值，寻找一个满足条件的哈希值，也就是前导0个数在一定范围内的hash值，前导0越多，难度越大。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>求出满足要求的hash值后，全网广播，其余节点验证该值是否符合要求，若符合，则成功加入主链。</p>
<h2 id="优点和不足"><a href="#优点和不足" class="headerlink" title="优点和不足"></a>优点和不足</h2><p>这个通过上面分析已经很清楚了，优点：参与人可以公平竞争；不足：资源消耗巨大，效率低（比特币tps=6）。</p>
<blockquote>
<p>参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识机制</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链术语汇总</title>
    <url>/articles/b35eb8c3/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>区块链对于很多人来说，还是很陌生的，很多名词让人望而却步，小编整理汇总了一些目前常见的词汇，并将它们用尽量通俗的语言解释。若有新的词汇，也会不定期更新。</p>
<a id="more"></a>
<p>本文参考了<a href="http://liyuechun.org/2017/08/11/Blockchain-Glossary-From-A-Z/">区块链专业术语最全词汇表：从 A - Z</a>，但其中有些词汇的讲解还是过于专业，小编结合自身经历，重新描述了这些词汇，并结合当前区块链发展状况，新增了一些别的词汇</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p><code>51%Attack 51%攻击</code><br>可以这么理解，当某人掌控了超过一半的某区块链能力时，他就控制了整个区块链。也就是说，原本去中心化的区块链变成了一个中心化的区块链，这是很可怕的。</p>
<p><code>Address地址</code><br>就是你用来接收数字资产的地址，可以理解成是你银行卡的账户</p>
<p><code>ASIC 专用集成电路</code><br>这个是加速了比特币被挖完的罪魁祸首，看看下图，纵轴可以理解为算力，横轴为年份，自从ASIC出现后，全网算力明显上升。</p>
<img src="/articles/b35eb8c3/1.jpeg" class="" title="ASIC的出现带来的影响">

<p><code>Bitcoin 比特币</code><br>第一个区块链应用，此公链就是为了发币而生。</p>
<p><code>Block 区块</code><br>一个块中记录了一定容量的信息，信息永久记录并且不可被篡改</p>
<p><code>Blockchain 区块链</code><br>区块串联后形成的一条链（一般是依据时间戳进行串联，当然这是个复杂的过程），也就是我们所说的主链，加入到主链中的块，将成为历史数据。</p>
<p><code>Block explorer 区块链浏览器</code><br>可以通过它查看当前主链状态、信息、各区块的信息，公开透明，也就是完全可视化、透明化、人性化的将整个区块链展示在任何人面前。</p>
<p><code>Block Height 区块高度</code><br>就是当前主链的块数，因为在某个时间段内，产生块的时间是固定的，比如每隔15秒，主链会新增一个块。因此，ICO年代，很多合约是通过块高度来控制发行Token的。</p>
<p><code>Block RewardToken奖励</code><br>给矿工的奖励。块的产生就是共识达成的结晶，而这个块就是矿工来协助产生的，矿工为此付出了带宽、时间、设备等资源，因此需要得到这一奖励。而这个奖励就来自用户转账、交易等操作的手续费。<br>当然，现实中，是远比这一讲解复杂的。</p>
<p><code>Consensus共识</code><br>比如，某个块是否可以被加入到主链，这是需要某一比例的矿工认可，这个过程就是共识的过程。</p>
<p><code>Cryptocurrency 加密货币</code><br>这个应该都熟悉，别称Token、通证、代币、数字货币。</p>
<p><code>Cryptographic Hash Function 加密哈希函数</code><br>这个扩展讲起来会涉及到很多领域的底层技术。简单来说，就是不同的数据经过处理后，会产生一个唯一的固定长度的字符串，这个字符串就是一个哈希值，可以理解为关系型数据库中一张表的主键。</p>
<p><code>Dapp 去中心化应用</code><br>全称：Decentralized Application，自主运行的应用，不需要某中心组织或机构干预。</p>
<p><code>DAO 去中心化自治组织</code><br>公链，以及公链上的DAPP，在没有任何人的干预之下，依旧可以自行组织运营。</p>
<p><code>Difficulty 容易程度</code><br>能够理解为，某个节点生成一个块的困难程度。</p>
<p><code>Digital Signature 数字签名</code><br>这在密码学领域很常见，A用户使用公钥加密某信息，B用户在用私钥揭秘该信息，若能成功解开，则说明信息正确无误。</p>
<p><code>Double Spending 双重支付</code><br>也就是区块链领域中经常涉及到的双花问题，简而言之，就是一笔钱花了两次。双花并不是产生新的币，只是通过某种方式把自己花出去的钱又重新拿回来了。<br>双花攻击是一个让人头疼的问题，而要解决这个问题，主要是考虑一个健壮的共识算法。</p>
<p><code>Ethereum 以太坊</code><br>被称为是第二代区块链技术</p>
<p><code>EVM 以太坊虚拟机</code><br>以太坊的核心</p>
<p><code>Fork 分支</code><br>一条链由于不同的原因，被分成了多个叉，每个叉是一条链</p>
<p><code>Genesis Block 创世区块</code><br>第一个区块，期间会初始化整条链</p>
<p><code>Hard Fork 硬分叉</code><br>区块链发生永久性分歧，在新共识规则发布后，部分没有升级的节点无法验证已经升级的节点生产的区块，通常硬分叉就会发生。</p>
<p><code>Hash collision 哈希碰撞</code><br>这个其实就是挖矿的本质，哈希碰撞主要是在基于POW机制的区块链中才有。原理是：有可能两个不同的原始值在经过哈希运算后得到同样的结果，这样就是哈希碰撞。这个原理不需要去深究。只要知道，碰撞达到某一范围后，就能挖出一个块了。</p>
<p><code>keystore 钱包文件</code><br>里面包含加密后的公钥私钥信息，需要使用自己设置的密码才能解开此文件中的信息，一般钱包导入，转账等操作时候的签名认证时候才需要。</p>
<p><code>Mining 挖矿</code><br>挖矿的过程就是哈希碰撞的过程，也就是共识达成的过程。这块只需要知道，是为了挖出区块链的下一个块</p>
<p><code>Multi-Signature 多重签名</code><br>这样来理解：为完成某一次交易，需要多个不同的用户认可才能成功，这类似于企业里，某份合同生效，需要多个负责任签字才能执行该合同。</p>
<p><code>Node 节点</code><br>可以理解为对接到区块链网络中的用户，一般是指保存有区块链完整数据的用户，并实时对接网络。</p>
<p><code>Oracles 预言机</code><br>通过它可以实现智能合约和外部世界的交流</p>
<p><code>Peer to Peer 点对点</code><br>网络中，双方在没有第三方干预的情况下完成交流。</p>
<p><code>Public Address 公用地址</code><br>这个就是前面提到的<code>Address地址</code>，要记住它不是公钥，而是在公钥的基础上hash处理后的结果。<br>可把它理解为自己的银行卡账号</p>
<p><code>Private Key 私钥</code><br>理解成是你的银行卡密码，不同的是，这个密码只有你自己拥有，而别的地方是无法获取到的，因此你必须牢牢记住自己的这个私钥</p>
<p><code>Proof of Work 工作证明</code><br>一种用于挖矿的工作机制，也是维持区块链正常运转的共识机制。跟电脑性能有关。</p>
<p>Proof of Stake（股权证明）<br>一种用于挖矿的工作机制，也是维持区块链正常运转的共识机制。跟电脑性能无关，此类机制的区块链，也没有挖矿的概念。</p>
<p><code>Scrypt 一种挖矿加密算法</code><br><code>哈希碰撞</code>(这个概念前面有描述)的一种函数，性能好，但是吃内存。这个主要</p>
<p><code>SHA-256 一种挖矿加密算法</code><br><code>哈希碰撞</code>(这个概念前面有描述)的一种函数，需要大量的硬件设备的投入。</p>
<p><code>Smart Contracts 智能合约</code><br>可以理解为是合约发布者定制的一系列的法律法规，发布到链中，所有调用该合约的参与者都需要遵守其中的规则。可以说，代码即规则。发布后的规则，不可以再被修改。</p>
<p><code>Soft Fork 软分叉</code><br>当新共识规则发布后，没有升级的节点会因为不知道新共识规则下，而生产不合法的区块，就会产生临时性分叉。</p>
<p><code>Solidity 开发语言</code><br>用于开发智能合约的开发语言，目前，大多数公链的合约都兼容该语言。</p>
<p><code>Testnet 测试网</code><br>这个就不用解释了吧。。</p>
<p><code>Transaction Free 手续费</code><br>交易或者调用某些合约接口，都会涉及到手续费问题。手续费用来奖励给矿工的，毕竟矿工耗费了那么多精力来给用户生成块。</p>
<p><code>Wallet 钱包</code><br>可以用来存放数字资产，转账交易等。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>委托股权证明原理(DPOS)--翻译及解读</title>
    <url>/articles/bbe43e3f/</url>
    <content><![CDATA[<h2 id="自述"><a href="#自述" class="headerlink" title="自述"></a>自述</h2><p>关于这个共识算法，小编其实有很多想说的，码了一个多小时的见解，考虑良久后，还是不打算把这见解发出来了，一千个人一千个哈姆雷特，<br>数十种共识算法中，它能被众人所知，那它必然是有它的优势。哲学上来说，存在即是合理。</p>
<a id="more"></a>
<p>DPOS最初是石墨烯提出来的，国内外也有几个基于石墨烯的区块链已经落地很久，运转也良好。<br>这个算法小编再三考虑后，还是打算讲一下它的原理，当然，小编不会从头讲。eos白皮书里引用了一个讲解dpos原理的英文论坛地址，小编会将其翻译成中文，并加入自己的见解。<br>虽然国内已经有人翻译过了，但为了自己能更好的走下去，小编还是打算自己再翻译一遍吧。</p>
<p>以下正文</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>英文原文地址：<a href="https://steemit.com/dpos/@dantheman/dpos-consensus-algorithm-this-missing-white-paper">https://steemit.com/dpos/@dantheman/dpos-consensus-algorithm-this-missing-white-paper</a><br>这是EOS白皮书中缺失的关于讲解DPOS原理的部分内容。本文主要是讲DPOS怎样运行以及它的鲁棒性为什么很强。早期也写了<a href="https://bitshares.org/technology/delegated-proof-of-stake-consensus/">一篇关于描述DPOS机制的文章</a>;然而，那篇文章中还包含了许多不是关于共识机制的内容（<code>wj备注：那篇文章写的冗长，看的心累，然并卵，我只需要知道DPOS是什么就行</code>）<br>所有的区块链本质上是由交易驱动的确定性状态机。共识的过程是用来确定被认可的交易顺序以及过滤无效的交易。目前已经有很多共识算法已经可以产生类似的有效交易排序，然而DPOS通过在不同的区块链项目中多年运转，已经证明了它拥有强鲁棒、高安全、高效率等特性。<br>就像所有的其它共识算法一样，块生产者能够引起的最大的危害审查。所有的块在基于<code>确定性的开源状态机逻辑</code>中必须是有效的。</p>
<h2 id="DPOS算法综述"><a href="#DPOS算法综述" class="headerlink" title="DPOS算法综述"></a>DPOS算法综述</h2><p>DPOS算法被分为两部分：<code>选取一组块生产者</code>以及<code>生产调度</code>。选举过程要确保最终是由利益相关者来控制的（<code>小编的理解，也就是token持有者来控制选举过程</code>），因为网络不流畅时候，利益相关者的损失是最大的。人们是如何选举的，对于每时每刻的共识达成来说影响很小。因此，本文主要是聚焦在<code>当块生产者被选出来后共识是如何达成的</code>这一问题上。<br>为了更好的解释这个算法，我想假设三个块生产者：<code>A</code>、<code>B</code>、<code>C</code>，因为共识的达成是需要2/3+1比例数量的生产者来解决期间遇到的所有情况。在这个简化的模型中会假设<code>C</code>是一个打破平衡的生产者。在真实的场景中，一般会有21个或者更多的生产者。就比如工作量证明(POW)，一般规定最长链为被认可的链（<code>小编理解就是，这个规则作为打破平衡的条件，就类似前面提到的生产者C，当A、B各作出一个不同选择而达到平衡时，C必须选择跟A或者跟B，无论结果怎样，都会打包当前的平衡</code>），任何时候，一个诚实的对等节点，看到一条有效的更长的链，自己都会从当前分支切换到最长链上。<br>我将会在任何能够想象到的网络状态下，通过例子展示DPOS是如何运行的。这些例子将会帮助你更清楚的认识，为什么DPOS鲁棒性强并且难以破坏。<br>（<code>注意：以下描述的案例，都是以3个节点为标准的</code>）</p>
<h3 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h3><p>在一般情况下，块生产者轮流每3秒钟生产一个块（<code>小编补充一句，EOS将这一机制压缩到0.5秒了，公信宝还是3秒钟</code>）。假设每轮中，每个生产者都没有错过生产块的机会，那么就会产生一条最长链。在被正常调度轮次之外，块生产者生产的块是无效的。</p>
<img src="/articles/bbe43e3f/1.png" class="" title="每个生产者都是规规矩矩的">

<h3 id="少数分叉"><a href="#少数分叉" class="headerlink" title="少数分叉"></a>少数分叉</h3><p>不超过1/3的节点是恶意的或者是故障的，并且它们有可能会制造少量的分叉。这种情况下（<code>小编备注：这里是假设1/3的节点制造了一条分叉，也就是案例中3个节点中的1个节点</code>），该分叉链每9秒钟产生一个块，而未分叉的2/3的节点所在链（<code>案例中的2个节点</code>），每9秒钟会产生2个块（<code>这块小编按自己的理解翻译的，原文直译过来很晦涩</code>）,如此，拥有2/3节点的链始终比1/3节点的链长（<code>也就是说，拥有2/3节点的链是被认可的诚实链</code>）。</p>
<img src="/articles/bbe43e3f/2.png" class="" title="前两轮中，恶意生产者B搞分叉">

<h3 id="少数离线节点进行多重生产"><a href="#少数离线节点进行多重生产" class="headerlink" title="少数离线节点进行多重生产"></a>少数离线节点进行多重生产</h3><p>少数离线的节点试图产生无限多的分支，但是它们每个分支都会比拥有多数节点的主链短。因为，拥有少量节点的分支，出块的速度始终比拥有多数节点的分支产生块的速度慢。</p>
<img src="/articles/bbe43e3f/3.png" class="" title="离线的节点自己产生多个分叉">

<h3 id="网络碎片化"><a href="#网络碎片化" class="headerlink" title="网络碎片化"></a>网络碎片化</h3><p>网络碎片化（<code>就是各种网络不稳定</code>）完全有可能导致没有一个分支拥有较多的块生产者（<code>就是每个分支都有相差不大的块生产者</code>）。这种情况下，生产者数量最多的那个分支将会被认为是主链。当网络状况恢复正常时，拥有较小数量生产者的分支将会倒向最大的那个分支，明确的共识也将会恢复。</p>
<img src="/articles/bbe43e3f/4.png" class="" title="每个分叉的生产者数都差不多">
<p>完全有可能会有这样一种情况：有3条分支，而其中最长的2条分支的长度是一样的。此时，较短分支中的块生产者切换回这两条较长分支中的任意一条，平衡都会被打破，就是说其中一条变成了最长链（<code>好吧，这块小编按自己的理解解释了，原文翻译过来看的会很心累的</code>）。随后我们将讨论块生产者的洗牌机制，如此将会使得生产块的顺序是随机化的，这样就能保证即使两个分支分别拥有相同数量的块生产者，生产块的步长也是不一样的，最终导致其中一条分支长度比另一条长。</p>
<h3 id="少数在线节点进行多重生产"><a href="#少数在线节点进行多重生产" class="headerlink" title="少数在线节点进行多重生产"></a>少数在线节点进行多重生产</h3><p>在这种情况下，少数节点<code>B</code>同时生产了2个或者更多的块（<code>正常生产者是只能生产一个块的</code>），下一个正常生产者<code>C</code>生产出的一个块，要选择B生产的其中一个块作为父类块（<code>这块小编也是按中文理解重新组织了语义，原文直译不好理解</code>），一旦<code>C</code>选择了其中一个作为父类块，那逻辑上可判断出，<code>C</code>当前所在的链是最长链，<code>B</code>产生的其它块都是短链，如此一来，后面所有的节点都会以最长链为标准。主链上少数的不良生产者即使企图同时生产多个块也不会影响全局，每轮中，即使它们每个能生产的块再多，也最多只有一个能被认可。</p>
<img src="/articles/bbe43e3f/5.png" class="" title="个别节点B生成了多个分叉">

<h3 id="最终不可逆转块（后半部分不知道是什么意思，求教）"><a href="#最终不可逆转块（后半部分不知道是什么意思，求教）" class="headerlink" title="最终不可逆转块（后半部分不知道是什么意思，求教）"></a>最终不可逆转块（后半部分不知道是什么意思，求教）</h3><p>在网络碎片的情况下，很有可能多个分叉同时增长相当长的时间。长远来看，最终还是会有一条最长的链胜出的。但是观察者需要一种准确的手段来知道，一个块绝对是在增长最快的那条链中。这个可以通过<code>2/3+1</code>多数块生产者的确认来决定。<br>在下面图中，块<code>B</code>已经被<code>C</code>和<code>A</code>确认，这代表了<code>2/3+1</code>数量的确认。从中也可以知道，若<code>2/3+1</code>的生产者是诚实的，就不会有其它分叉链会比这条链长。</p>
<img src="/articles/bbe43e3f/6.png" class="" title="2&#x2F;3+1确认机制">
<p>需要注意，这个<code>规则</code>类似于比特币中6个块的确认机制。一些聪明的人会设法促成一系列的事件，使得两个节点出现在不同的最后的不可逆块上，这种极端情况，需要攻击者能够完全的控制网络通信的延迟，同时在几分钟的时间内两次使用这个控制。但是，即便这种事发生，最长分支胜出的规则仍然是适用的。<br>我们评估后认为，这种估计成功的概率几乎为0，经济后果也不足为虑，因此也没必要担心。（<code>然并卵，这一段话小编没看懂是在说什么，讲的太含糊了</code>）</p>
<h3 id="生产者的法定人数不足"><a href="#生产者的法定人数不足" class="headerlink" title="生产者的法定人数不足"></a>生产者的法定人数不足</h3><p>在某些情况下，块生产者的法定人数有可能不足，这种情况下这些生产者也是可以继续出块的（<code>就是说生产者参与人数不是100%</code>）。在这些块中的利益相关者，是可以包括更改投票的交易（<code>小编理解：这句话的意思是，每一次投票也属于一个交易，这个交易信息被包含在这些块利益相关者之中了</code>），这些投票可以选出一组新的生产者，并将块生产者参与率恢复为100%。这样一来，不久之后，短链（<code>假设短链块生产者人数逐步由不足100变为了100%%</code>）终将会超过长的链（<code>假设长链块生产者人数不足100%</code>）。<br>在这一个过程中所有的观察者都会明白，在一条链的块生产者参与率达到67%以前，整个网络状态是不稳定的。在这种状况下进行交易的风险（<code>就是生产者的法定人数不足</code>），类似于在比特币中块的确认不足6个。他们之所以愿意冒这个风险，是因为他们知道存在这样一种可能，最终会在不同的分叉中，各自建立共识。实践检验得知，dpos生产者的法定人数不足时候的问题，相比于比特币中少于3个块的确认问题安全很多。</p>
<h3 id="多数生产者腐败（就是作弊）"><a href="#多数生产者腐败（就是作弊）" class="headerlink" title="多数生产者腐败（就是作弊）"></a>多数生产者腐败（就是作弊）</h3><p>如果大多数生产者作弊，这样就会产生无限数量的分叉，每个分叉看着都像是2/3确认的机制进行的。这种情况下，最终的不可篡改块的算法变成了最长链算法。最长链就是大多数生产者所认可的那条链，而这条链也是诚实节点所认可的链。这种行为不会长时间存在，因为最终会被利益相关者投票替换生产者。</p>
<img src="/articles/bbe43e3f/7.png" class="" title="多数生产者不诚实">

<h2 id="基于交易的股权证明机制（TaPOS）"><a href="#基于交易的股权证明机制（TaPOS）" class="headerlink" title="基于交易的股权证明机制（TaPOS）"></a>基于交易的股权证明机制（TaPOS）</h2><p>当用户对交易进行签名时，他的这个行为是在一定条件下假设的区块链状态中执行的。这个假设是基于最近几个块来预测的。如果最长链的共识发生了改变，潜在的会使得签名者根据先前的假设所认可的交易失效（<code>小编觉得有点拗口，就是说，你先前根据当前链的状态判断自己的交易没问题，但是最终链的共识发生了变化，那你的交易就没能被记录进去，那就失效了</code>）。<br>在TaPOS机制中，所有交易都包含最近一个块的hash，如果在链已有块中没有发现这个块，那这个块所包含的交易都会被认为是无效的（那这个块就被孤立了）。任何人在被孤立的块上进行交易都会发现交易是无效的，并且无法迁移到主链。<br>这个过程的另一个作用是，可以抵御意图通过长期攻击来形成另外一条链的行为。每个利益相关者在每次交易时，都会直接对交易作出确认。随着时间的推移，所有的块都是由所有的利益相关者确认，这也是无法伪造链的原因。</p>
<h2 id="确定的对生产者洗牌（就是说公平的洗牌规则）"><a href="#确定的对生产者洗牌（就是说公平的洗牌规则）" class="headerlink" title="确定的对生产者洗牌（就是说公平的洗牌规则）"></a>确定的对生产者洗牌（<code>就是说公平的洗牌规则</code>）</h2><p>在前面讲的所有例子中，我们展示的都是按顺序调度块生产者。实际上，每N个块之后就会对所有块生产者进行一次洗牌（N表示块生产者的人数）。这种随机方式确保了每个生产者都能公平的参与到块生产中来，全员参与，一个也不会被忽略（<code>这句话小编换了一种说法</code>），并且当形成拥有相同数量的块生产者的多个分叉时，这种僵局总会被打破。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们能够想象到的自然网络异常或者大量生产者作弊的情况下，DPOS的鲁棒性都是很强的。不像别的共识算法，当大多数生产者不合格时，DPOS仍可以正常运转。这种时候，社区会通过选举来替换这些不合格的生产者，直到恢复为100%的参与度为止。我还没有发现别的还有哪个算法在高强度和多种异常变化的条件下依旧能够有如此好的鲁棒性(<code>怎么说吧，小编觉得，要满足市场所需，又要满足安全可靠，DPOS是个合适的选择，就看怎么具体设计了</code>)。<br>总的来说，DPOS引人注目的安全性来自它的选择块生产者和验证高质量节点的算法，使用这样一个投票方式，确保了即使某个人拥有50%的投票权，也不能光靠自己就选出一个生产者。DPOS通过优化确保拥有健壮网络连接的诚实节点都能够100%的参与到投票中来，这使得DPOS能够在平均1.5秒内准确的确认99.9%的交易，同时也可以通过优雅和可检测的方式很容易的实现降级(<code>就是恢复</code>)。<br>别的共识算法在网络条件差的不诚实节点的条件下进行设计，设计的结果结果导致网络性能低、高延迟、高开销，并且如果33%的节点失效，则整个网络将瘫痪。<br>Bitshares三年的成功运行以及Steem的一年运行期间，我们经历了各种各样的网络问题以及软件bug。DPOS在期间成功运转，并且它能比别的区块链处理更多的交易。</p>
<h2 id="小编补充"><a href="#小编补充" class="headerlink" title="小编补充"></a>小编补充</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li>
<li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li>
<li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li>
<li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li>
</ol>
<h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure>
<h3 id="go代码实现"><a href="#go代码实现" class="headerlink" title="go代码实现"></a>go代码实现</h3><p>请参考：<a href="https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/dpos">https://github.com/jason-wj/blockchain-demo/tree/master/src/github.com/jason/blockchain-demo/dpos</a></p>
<blockquote>
<p>除翻译外，剩余内容参考自：<a href="http://liyuechun.org/">http://liyuechun.org/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.2讲-rpc源码解读</title>
    <url>/articles/e10014d8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文我们将分析rpc模块的源码，如果对rpc概念还不是很清楚的同学，建议先看看这篇文章<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC5.1%E8%AE%B2-rpc%E5%AE%98%E7%BF%BB%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3.html"><code>以太坊源码解读-第5.1讲-rpc官翻及个人理解</code></a></p>
<a id="more"></a>
<p>本文后半部分解释有误，本文可对rpc了解大概，然后看之后的内容<br>先来看看该模块下有哪些文件：<br>.<br>|____ipc_unix.go<br>|____ipc_windows.go<br>|____ipc.go<br>|____http.go<br>|____doc.go<br>|____inproc.go<br>|____utils.go<br>|____websocket.go<br>|____errors.go<br>|____server.go<br>|____server_test.go<br>|____client.go<br>|____client_example_test.go<br>|____client_test.go<br>|____subscription.go<br>|____subscription_test.go<br>|____utils_test.go<br>|____http_test.go<br>|____types.go<br>|____types_test.go<br>|____json.go<br>|____json_test.go</p>
<p>文件很多，一眼看去真的很头大，小编借鉴<a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">rpc源码分析-github</a>中提供的一张图片先全局的介绍一下rpc模块中整体的文件结构，这样方便后面的理解：</p>
<img src="/articles/e10014d8/1.png" class="" title="rpc模块文件结构">
<p>图中<code>网络协议channels</code>和<code>Json</code>两部分，其请求和回应的编码和解码都是同时与服务端和客户端打交道的类。<code>网络协议channels</code>主要提供连接和数据传输的功能。 <code>json</code>的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -&gt; Go的对象)。<br>另外需要知道，各种对外的服务都是被注册到server中的。<br><code>ps</code>：要区分server和service的区别，server表示服务实体，service表示被注册到server中的一项服务</p>
<h2 id="types-go源码"><a href="#types-go源码" class="headerlink" title="types.go源码"></a>types.go源码</h2><p>要了解rpc，得先要了解rpc中对各大类的定义，因此我们很有必要先来看下这个文件。</p>
<h3 id="对外开放的API定义"><a href="#对外开放的API定义" class="headerlink" title="对外开放的API定义"></a>对外开放的API定义</h3><p>外部访问rpc的server进行通信是通过调用这个API来实现。<br>分析过geth启动rpc的过程后，就会发现，所有的模块，都会把自己的api放在其中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> API <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="keyword">string</span>      <span class="comment">// 在该命名空间下，service的方法被公开</span></span><br><span class="line">	Version   <span class="keyword">string</span>      <span class="comment">// 给dapp展示的api版本号</span></span><br><span class="line">	Service   <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 带有方法的service实例</span></span><br><span class="line">	Public    <span class="keyword">bool</span>        <span class="comment">// 在公共使用中，指示方法是否为安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service的定义"><a href="#service的定义" class="headerlink" title="service的定义"></a>service的定义</h3><p>service定义了一个用来被注册到server中的服务，需要知道它内部结构是如何的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span>        <span class="comment">// service的名称</span></span><br><span class="line">	typ           reflect.Type  <span class="comment">// 类型，反射的</span></span><br><span class="line">	callbacks     callbacks     <span class="comment">// 回调方法的集合</span></span><br><span class="line">	subscriptions subscriptions <span class="comment">// 订阅/发布集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现callbacks和subscriptions都是集合，它是如下定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]*callback      <span class="comment">// 回调方法的集合，可以看出是一个map</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback  <span class="comment">// 订阅的集合，也可以看出是一个map</span></span><br></pre></td></tr></table></figure>
<p>这两个集合都是map类型的，而它们个体本身其实就是一个callback，它的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">	rcvr        reflect.Value  <span class="comment">// 反射出方法的值</span></span><br><span class="line">	method      reflect.Method <span class="comment">// 反射出方法本身</span></span><br><span class="line">	argTypes    []reflect.Type <span class="comment">// 输入的参数</span></span><br><span class="line">	hasCtx      <span class="keyword">bool</span>           <span class="comment">// 检测第一个参数是否为context，</span></span><br><span class="line">	errPos      <span class="keyword">int</span>            <span class="comment">// 返回错误的索引err，无法返回则为-1</span></span><br><span class="line">	isSubscribe <span class="keyword">bool</span>           <span class="comment">// 该callback是否为订阅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，该callback主要就是使用反射来确定回调本身的。代码注释解释的可能不太好，大意上是那么一回事。。</p>
<h3 id="server的定义"><a href="#server的定义" class="headerlink" title="server的定义"></a>server的定义</h3><p>上面说的service可以理解为一项服务，而server可以理解成是各种服务的容器，service最终是要被注册到server中的，而server的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry  <span class="comment">//用来存储service</span></span><br><span class="line">	run      <span class="keyword">int32</span>  <span class="comment">//用来控制server是否可运行，1为运行，非1为不可运行</span></span><br><span class="line">	codecsMu sync.  <span class="comment">//用来保护多线程访问codecs的锁</span></span><br><span class="line">	codecs   *set.Set  <span class="comment">//用来存储所有的编码解码器，其实就是所有的连接。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的services就是用来存储service集合的，可以看出它是通过serviceRegistry来定义的，而serviceRegistry本身是如下定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> serviceRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*service </span><br></pre></td></tr></table></figure>
<p>呵呵，这下知道了，service在server中是存在map中的</p>
<h3 id="ServerCodec的定义"><a href="#ServerCodec的定义" class="headerlink" title="ServerCodec的定义"></a>ServerCodec的定义</h3><p>server中的方法会用到这个东东，客户端发出的请求，对请求的处理，返回响应等过程，都是通过它来进行的。<br>这个东西很重要，它贯穿了客户端和服务器端的交流，重要的不得了。<br>先来看看它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerCodec <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadRequestHeaders() ([]rpcRequest, <span class="keyword">bool</span>, Error)    <span class="comment">//读取客户端发来的请求</span></span><br><span class="line">	<span class="comment">//根据给定的类型解析请求参数</span></span><br><span class="line">	ParseRequestArguments(argTypes []reflect.Type, params <span class="keyword">interface</span>&#123;&#125;) ([]reflect.Value, Error)</span><br><span class="line">	CreateResponse(id <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//response返回成功</span></span><br><span class="line">	CreateErrorResponse(id <span class="keyword">interface</span>&#123;&#125;, err Error) <span class="keyword">interface</span>&#123;&#125;   <span class="comment">//response返回失败</span></span><br><span class="line">	<span class="comment">//response返回失败，包括一些别的信息</span></span><br><span class="line">	CreateErrorResponseWithInfo(id <span class="keyword">interface</span>&#123;&#125;, err Error, info <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	CreateNotification(id, namespace <span class="keyword">string</span>, event <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 创建发布响应</span></span><br><span class="line">	Write(msg <span class="keyword">interface</span>&#123;&#125;) error  <span class="comment">// 写信息到客户端</span></span><br><span class="line">	Close()  <span class="comment">// 关闭底层的数据流</span></span><br><span class="line">	Closed() &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 当底层连接关闭后，则执行该接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期间涉及到了两个比较重要的结构体：</p>
<ul>
<li>rpcRequest，它里面包含具体的请求信息：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> rpcRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	service  <span class="keyword">string</span></span><br><span class="line">	method   <span class="keyword">string</span></span><br><span class="line">	id       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	isPubSub <span class="keyword">bool</span></span><br><span class="line">	params   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err      Error <span class="comment">// invalid batch element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Error，错误信息结构：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span>  <span class="comment">// 返回错误信息</span></span><br><span class="line">	ErrorCode() <span class="keyword">int</span> <span class="comment">// 返回错误代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BlockNumber的定义"><a href="#BlockNumber的定义" class="headerlink" title="BlockNumber的定义"></a>BlockNumber的定义</h3>这个就是块号的解析，根据输入的byte[]来判断返回的BlockNumber是多少。这个后面大家可以了解下。</li>
</ul>
<h2 id="json-go"><a href="#json-go" class="headerlink" title="json.go"></a>json.go</h2><p>还记得我们前面提到的那个<code>ServerCodec</code>吗，它其实只是一个接口定义，真正其实是该文件中的<code>jsonCodec</code>生成的，<code>jsonCodec</code>实现了<code>ServerCodec</code>的所有接口</p>
<h3 id="jsonCodec结构"><a href="#jsonCodec结构" class="headerlink" title="jsonCodec结构"></a>jsonCodec结构</h3><p>rpc消息的请求和响应，以及序列化和解析都是这个结构来实现的，这</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> jsonCodec <span class="keyword">struct</span> &#123;</span><br><span class="line">	closer sync.Once                 <span class="comment">// close closed channel once</span></span><br><span class="line">	closed <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;          <span class="comment">// closed on Close</span></span><br><span class="line">	decMu  sync.Mutex                <span class="comment">// guards the decoder</span></span><br><span class="line">	decode <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span> // <span class="title">decoder</span> <span class="title">to</span> <span class="title">allow</span> <span class="title">multiple</span> <span class="title">transports</span></span></span><br><span class="line">	encMu  sync.Mutex                <span class="comment">// guards the encoder</span></span><br><span class="line">	encode <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span> // <span class="title">encoder</span> <span class="title">to</span> <span class="title">allow</span> <span class="title">multiple</span> <span class="title">transports</span></span></span><br><span class="line">	rw     io.ReadWriteCloser        <span class="comment">// connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建jsonCodec的重要的两个方法"><a href="#创建jsonCodec的重要的两个方法" class="headerlink" title="创建jsonCodec的重要的两个方法"></a>创建jsonCodec的重要的两个方法</h3><p>可以通过<code>NewCodec()</code>方法和<code>NewJSONCodec()</code>方法来创建jsonCodec，方法本身很简单，小编就不解释了，注意编码和解码就行。</p>
<h3 id="jsonCodec方法"><a href="#jsonCodec方法" class="headerlink" title="jsonCodec方法"></a>jsonCodec方法</h3><p>这些方法都是具体实现了<code>ServerCodec</code>的接口，想了解具体是怎么实现的，可以看看代码去，小编在这就不详述了。</p>
<h2 id="server-go和server-test-go源码"><a href="#server-go和server-test-go源码" class="headerlink" title="server.go和server_test.go源码"></a>server.go和server_test.go源码</h2><p>对上面的定义有了整体把握后，小编结合着server_test.go文件来讲解一下server.go源码。</p>
<h3 id="先来看看server-test-go"><a href="#先来看看server-test-go" class="headerlink" title="先来看看server_test.go"></a>先来看看server_test.go</h3><p>为了方便测试，server_test.go中定义了一个<code>Service</code>，这个<code>Service</code>用来被注册到server中，关于这个Service很有必要知道是如何定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">	S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	String <span class="keyword">string</span></span><br><span class="line">	Int    <span class="keyword">int</span></span><br><span class="line">	Args   *Args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">NoArgsRets</span><span class="params">()</span></span> &#123;&#125;  <span class="comment">//第1个有效的回调方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Echo</span><span class="params">(str <span class="keyword">string</span>, i <span class="keyword">int</span>, args *Args)</span> <span class="title">Result</span></span> &#123; <span class="comment">//第2个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> Result&#123;str, i, args&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">EchoWithCtx</span><span class="params">(ctx context.Context, str <span class="keyword">string</span>, i <span class="keyword">int</span>, args *Args)</span> <span class="title">Result</span></span> &#123;  <span class="comment">//第3个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> Result&#123;str, i, args&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Sleep</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;  <span class="comment">//第4个有效的回调方法</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Rets</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123; <span class="comment">//第5个有效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">InvalidRets1</span><span class="params">()</span> <span class="params">(error, <span class="keyword">string</span>)</span></span> &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">InvalidRets2</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">InvalidRets3</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span></span> &#123; <span class="comment">//无效的回调方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Subscription</span><span class="params">(ctx context.Context)</span> <span class="params">(*Subscription, error)</span></span> &#123; <span class="comment">//一个有效的订阅</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC5.1%E8%AE%B2-rpc%E5%AE%98%E7%BF%BB%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3.html"><code>以太坊源码解读-第5.1讲-rpc官翻及个人理解</code></a>中描述，我们知道上述代码中，<code>Service</code>对应的共有5个有效回调方法（也就是开放的方法），3个无效的回调方法，还有1个有效的订阅方法。在server.services中，是有两个服务的，是不是很好奇，其实在NewServer()时候，就会有一个rpc服务被添加进去的，具体可以看小编后面的介绍。<br>需要知道，首字母为大写的方法名，被认为是对外开放的方法，不要问我为什么，后面代码里就是这么个逻辑。<br>我们通过下面的测试用例来验证有效还是无效：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestServerRegisterName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	server := NewServer()  <span class="comment">//server新实例</span></span><br><span class="line">	service := <span class="built_in">new</span>(Service)  <span class="comment">//具体某服务的实例</span></span><br><span class="line">	<span class="keyword">if</span> err := server.RegisterName(<span class="string">&quot;calc&quot;</span>, service); err != <span class="literal">nil</span> <span class="comment">//根据名称将某服务注册</span></span><br><span class="line">		t.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(server.services) != <span class="number">2</span>  <span class="comment">//是否有两个服务，其中一个是在NewServer)()时候添加的</span></span><br><span class="line">		t.Fatalf(<span class="string">&quot;Expected 2 service entries, got %d&quot;</span>, <span class="built_in">len</span>(server.services))</span><br><span class="line">	svc, ok := server.services[<span class="string">&quot;calc&quot;</span>]  <span class="comment">//获取某服务</span></span><br><span class="line">	<span class="keyword">if</span> !ok </span><br><span class="line">		t.Fatalf(<span class="string">&quot;Expected service calc to be registered&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) != <span class="number">5</span> <span class="comment">//是否有5个有效方法</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;Expected 5 callbacks for service &#x27;calc&#x27;, got %d&quot;</span>, <span class="built_in">len</span>(svc.callbacks))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.subscriptions) != <span class="number">1</span>  <span class="comment">//是否有1个有效订阅方法</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;Expected 1 subscription for service &#x27;calc&#x27;, got %d&quot;</span>, <span class="built_in">len</span>(svc.subscriptions))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后server_test.go中还有3个测试方法是用来测试<code>Service</code>中的每个方法是否正确，其中涉及到了rpc的方方面面。这几个测试方法小编就不列出来了，大家可以去看看，方法本身还是很容易理解的。</p>
<h3 id="server-go介绍"><a href="#server-go介绍" class="headerlink" title="server.go介绍"></a>server.go介绍</h3><p>经过前面这么多的讲解，大家对rpc的server已经有了一些较为深刻的映像了吧？那我们就来看一下server.go中是如何实现server的。</p>
<h4 id="创建一个新server"><a href="#创建一个新server" class="headerlink" title="创建一个新server"></a>创建一个新server</h4><p>需要先创建一个server，这样才能将service注册到该server中，具体是这样创建的，看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123; <span class="comment">//server先实例化</span></span><br><span class="line">		services: <span class="built_in">make</span>(serviceRegistry),  <span class="comment">//开辟存储service的空间</span></span><br><span class="line">		codecs:   set.New(),  <span class="comment">//不解释，看前面</span></span><br><span class="line">		run:      <span class="number">1</span>,  <span class="comment">//1,运行；非1不运行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册一个默认的rpc服务，该服务可以提供server的一些基本信息，具体看前面小编描述的</span></span><br><span class="line">	rpcService := &amp;RPCService&#123;server&#125;  <span class="comment">//利用server生成一个rpcService，</span></span><br><span class="line">	server.RegisterName(MetadataApi, rpcService) <span class="comment">//MetadataApi=“rpc”</span></span><br><span class="line">	<span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里，需要注意的是，初始化一个server，然后利用这个server生成一个rpcService，最后在用server把RPCService注册进去。<br>RPCService的目的是给出server中的一些基本参数信息，目前来说，貌似只能给出拥有的service名称和对应的版本号，而且都是1.0。。。<br>RPCService的定义以及它的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCService <span class="keyword">struct</span> &#123;   <span class="comment">//这个是RPCService的定义结构，很简单吧。。不解释</span></span><br><span class="line">	server *Server  <span class="comment">//可以看出，该server是指针引用进来的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *RPCService)</span> <span class="title">Modules</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">	modules := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> name := <span class="keyword">range</span> s.server.services &#123;</span><br><span class="line">		modules[name] = <span class="string">&quot;1.0&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> modules <span class="comment">//其实只是返回每个service的名称和其版本号。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人感觉，有点鸡肋额，，</p>
<h4 id="server所拥有的方法"><a href="#server所拥有的方法" class="headerlink" title="server所拥有的方法"></a>server所拥有的方法</h4><p>server.go文件中，剩下的内容都是server结构体所对应的方法，都比较重要，我们一个个来介绍</p>
<h5 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h5><p>前面我们一直在用server.RegisterName()来注册一个服务，但这个服务具体是怎么来执行呢？来，上一坨代码你就知道了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.services = <span class="built_in">make</span>(serviceRegistry)  <span class="comment">//开辟存储service的空间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	svc := <span class="built_in">new</span>(service)</span><br><span class="line">	svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, svc.typ.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isExported(reflect.Indirect(rcvrVal).Type().Name()) &#123; <span class="comment">//方法名中，首字母大写的被认为是对外开放的方法</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s is not exported&quot;</span>, reflect.Indirect(rcvrVal).Type().Name())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)  <span class="comment">//将方法和订阅都反射解析出来</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若services中已经有了该service，则直接合并方法和订阅</span></span><br><span class="line">	<span class="keyword">if</span> regsvc, present := s.services[name]; present &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(methods) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> methods &#123;</span><br><span class="line">			regsvc.callbacks[formatName(m.method.Name)] = m</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> subscriptions &#123;</span><br><span class="line">			regsvc.subscriptions[formatName(s.method.Name)] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	svc.name = name</span><br><span class="line">	svc.callbacks, svc.subscriptions = methods, subscriptions</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(svc.callbacks) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(svc.subscriptions) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.services[svc.name] =   <span class="comment">//根据名称存入服务</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现：</p>
<ul>
<li>方法或订阅如果是对外开放的，首先要满足其名称的首字母是大写</li>
<li>调用utils.go中的suitableCallbacks()方法，使用service反射后的结果来判断是属于对外开放的方法还是订阅</li>
<li>如果server中先前已经注册过该服务，则将新传入的service和该服务合并。</li>
</ul>
<h5 id="ServeCodec-方法，异步处理请求"><a href="#ServeCodec-方法，异步处理请求" class="headerlink" title="ServeCodec()方法，异步处理请求"></a>ServeCodec()方法，异步处理请求</h5><p>先来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec, options CodecOption)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> codec.Close()</span><br><span class="line">	s.serveRequest(codec, <span class="literal">false</span>, options) <span class="comment">//具体实现后面再讲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数codec中存储的是客户端发来的请求，经过处理后，会将响应结果写入codec中并返回给客户端。<br>该方法处理完codec中的内容后，会调用codec.Close()接口方法，处理请求结束时候的一些操作。<br>注意，看<code>s.serveRequest(codec, false, options)</code>，里面的<code>false</code>表示该方法是并发处理请求的</p>
<h5 id="ServeSingleRequest-方法，同步处理请求"><a href="#ServeSingleRequest-方法，同步处理请求" class="headerlink" title="ServeSingleRequest()方法，同步处理请求"></a>ServeSingleRequest()方法，同步处理请求</h5><p>呵呵，这个方法和上面的那个方法刚好相反，是同步处理请求的，等处理结束后，整个过程才会结束。此结束不提供codec.Close()方法，不用想也该明白，同步结束了，后面该干嘛就干嘛。<br>代码就不列出来了，自己YY。</p>
<h5 id="serveRequest-方法，具体处理客户端发来的请求"><a href="#serveRequest-方法，具体处理客户端发来的请求" class="headerlink" title="serveRequest()方法，具体处理客户端发来的请求"></a>serveRequest()方法，具体处理客户端发来的请求</h5><p>前面讲的两个方法，其实里面都是在调用这个方法的，这个也是我们服务器端的核心，下面小编就来好好探索一下。<br>在讲之前，小编建议大家好好了解下go语言中并发与并行的一些机制，也是为了更好的读懂这一部分代码，小编整理了下面几篇文章，希望大家先好好读读：<br><a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（一）</a><br><a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（二）</a><br><a href="/articles/reprint/go/golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89.html">golang语言并发与并行——goroutine和channel的详细理解（三）</a></p>
<p>这个方法，其实主要就执行了两个过程：解析读取发来的请求，执行处理请求。期间用到了很多锁和协程的概念，把该方法的主要代码列出来：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveRequest</span><span class="params">(codec ServerCodec, singleShot <span class="keyword">bool</span>, options CodecOption)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * golang中的同步是通过sync.WaitGroup来实现的．WaitGroup的功能：它实现了一个类似队列的结构，可以一直向队列中添加任务，当任务完成后便从队列中删除，如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，防止程序继续进行，直到所有的队列任务都完成为止．</span></span><br><span class="line"><span class="comment">	 * WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成时才解除阻塞，而不需要sleep一个固定的时间来等待．但是其缺点是无法指定固定的goroutine数目．可能通过使用channel解决此问题。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">var</span> pend  sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结束时候的调用</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			log.Error(<span class="keyword">string</span>(buf))</span><br><span class="line">		&#125;</span><br><span class="line">		s.codecsMu.Lock()</span><br><span class="line">		s.codecs.Remove(codec)</span><br><span class="line">		s.codecsMu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//context.Background() 返回一个空的Context，这个空的Context一般用于整个Context树的根节点。</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())  <span class="comment">//创建一个可取消的子Context</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> options&amp;OptionSubscriptions == OptionSubscriptions &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, notifierKey&#123;&#125;, newNotifier(codec))</span><br><span class="line">	&#125;</span><br><span class="line">	s.codecsMu.Lock()</span><br><span class="line">	<span class="comment">//接受一个*int32类型的指针值,并会返回该指针值指向的那个值</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) != <span class="number">1</span> &#123; <span class="comment">// server stopped</span></span><br><span class="line">		s.codecsMu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> &amp;shutdownError&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.codecs.Add(codec)  <span class="comment">//把请求加入集合</span></span><br><span class="line">	s.codecsMu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test if the server is ordered to stop</span></span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt32(&amp;s.run) == <span class="number">1</span> &#123;  <span class="comment">//确保当前server没有停止</span></span><br><span class="line">		reqs, batch, err := s.readRequest(codec) <span class="comment">//从其中读到请求信息</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err.Error() != <span class="string">&quot;EOF&quot;</span> &#123;</span><br><span class="line">				log.Debug(fmt.Sprintf(<span class="string">&quot;read error %v\n&quot;</span>, err))</span><br><span class="line">				codec.Write(codec.CreateErrorResponse(<span class="literal">nil</span>, err))</span><br><span class="line">			&#125;</span><br><span class="line">			pend.Wait()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//又是一堆验证</span></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) != <span class="number">1</span> &#123; </span><br><span class="line">			err = &amp;shutdownError&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				resps := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(reqs))</span><br><span class="line">				<span class="keyword">for</span> i, r := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">					resps[i] = codec.CreateErrorResponse(&amp;r.id, err)</span><br><span class="line">				&#125;</span><br><span class="line">				codec.Write(resps)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				codec.Write(codec.CreateErrorResponse(&amp;reqs[<span class="number">0</span>].id, err))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> singleShot &#123;  <span class="comment">//非并发</span></span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				s.execBatch(ctx, codec, reqs)  <span class="comment">//批处理请求</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.exec(ctx, codec, reqs[<span class="number">0</span>])</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		pend.Add(<span class="number">1</span>) <span class="comment">//添加一个阻塞任务</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reqs []*serverRequest, batch <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()  <span class="comment">//处理一个阻塞任务</span></span><br><span class="line">			<span class="keyword">if</span> batch &#123;</span><br><span class="line">				s.execBatch(ctx, codec, reqs) <span class="comment">//这个批处理请求</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.exec(ctx, codec, reqs[<span class="number">0</span>])  <span class="comment">//处理单个请求</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(reqs, batch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中我们得知，主要涉及到两个方法：</p>
<ul>
<li>readRequest(codec)<br>该方法解析并读取有效的客户端请求，会区分哪些是方法，哪些是订阅，根据不同状况，将这些信息都组装到requests[]中；</li>
<li>execBatch()/exec()，用于处理requests[]请求。一个批量处理，一个是单一处理，然后回调。具体的解析，稍后专门来讲。</li>
</ul>
<h5 id="execBatch-exec"><a href="#execBatch-exec" class="headerlink" title="execBatch()/exec()"></a>execBatch()/exec()</h5><p>这也是server的方法，前面也说了，这两个方法类似，都是处理请求的，一个批量处理，一个单个处理。<br>小编就只列一下exec()的源码了：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">exec</span><span class="params">(ctx context.Context, codec ServerCodec, req *serverRequest)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> callback <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">if</span> req.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		response = codec.CreateErrorResponse(&amp;req.id, req.err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		response, callback = s.handle(ctx, codec, req) <span class="comment">//处理请求</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := codec.Write(response); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(fmt.Sprintf(<span class="string">&quot;%v\n&quot;</span>, err))</span><br><span class="line">		codec.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> callback != <span class="literal">nil</span> &#123;</span><br><span class="line">		callback()  <span class="comment">//执行回调</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，从头到尾，能入得了法眼的也只有里面涉及到的<code>handle()</code>方法了。这个<code>handle()</code>真正的处理了请求内容。<br>接下来那就看一下这个handle()到底执行了哪些东西。</p>
<h5 id="handle-方法"><a href="#handle-方法" class="headerlink" title="handle()方法"></a>handle()方法</h5><p>server中最长最重要的一个方法，用于真正的处理数据，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handle</span><span class="params">(ctx context.Context, codec ServerCodec, req *serverRequest)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, req.err), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.isUnsubscribe &#123; <span class="comment">// 取消订阅, 第一个参数必须是订阅id</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(req.args) &gt;= <span class="number">1</span> &amp;&amp; req.args[<span class="number">0</span>].Kind() == reflect.String &#123;</span><br><span class="line">			notifier, supported := NotifierFromContext(ctx)</span><br><span class="line">			<span class="keyword">if</span> !supported &#123; <span class="comment">// interface doesn&#x27;t support subscriptions (e.g. http)</span></span><br><span class="line">				<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;ErrNotificationsUnsupported.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			subid := ID(req.args[<span class="number">0</span>].String())</span><br><span class="line">			<span class="keyword">if</span> err := notifier.unsubscribe(subid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;err.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> codec.CreateResponse(req.id, <span class="literal">true</span>), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;invalidParamsError&#123;<span class="string">&quot;Expected subscription id as first argument&quot;</span>&#125;), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是订阅消息。 那么创建订阅。并激活订阅</span></span><br><span class="line">	<span class="keyword">if</span> req.callb.isSubscribe &#123;</span><br><span class="line">		subid, err := s.createSubscription(ctx, codec, req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;err.Error()&#125;), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// active the subscription after the sub id was successfully sent to the client</span></span><br><span class="line">		activateSub := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			notifier, _ := NotifierFromContext(ctx)</span><br><span class="line">			notifier.activate(subid, req.svcname)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> codec.CreateResponse(req.id, subid), activateSub</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// regular RPC call, prepare arguments</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.args) != <span class="built_in">len</span>(req.callb.argTypes) &#123;</span><br><span class="line">		rpcErr := &amp;invalidParamsError&#123;fmt.Sprintf(<span class="string">&quot;%s%s%s expects %d parameters, got %d&quot;</span>,</span><br><span class="line">			req.svcname, serviceMethodSeparator, req.callb.method.Name,</span><br><span class="line">			<span class="built_in">len</span>(req.callb.argTypes), <span class="built_in">len</span>(req.args))&#125;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateErrorResponse(&amp;req.id, rpcErr), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arguments := []reflect.Value&#123;req.callb.rcvr&#125;</span><br><span class="line">	<span class="keyword">if</span> req.callb.hasCtx &#123;</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, reflect.ValueOf(ctx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		arguments = <span class="built_in">append</span>(arguments, req.args...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用提供的rpc方法，并获取reply</span></span><br><span class="line">	reply := req.callb.method.Func.Call(arguments)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(reply) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> codec.CreateResponse(req.id, <span class="literal">nil</span>), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.callb.errPos &gt;= <span class="number">0</span> &#123; <span class="comment">// test if method returned an error</span></span><br><span class="line">		<span class="keyword">if</span> !reply[req.callb.errPos].IsNil() &#123;</span><br><span class="line">			e := reply[req.callb.errPos].Interface().(error)</span><br><span class="line">			res := codec.CreateErrorResponse(&amp;req.id, &amp;callbackError&#123;e.Error()&#125;)</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> codec.CreateResponse(req.id, reply[<span class="number">0</span>].Interface()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Stop-方法"><a href="#Stop-方法" class="headerlink" title="Stop()方法"></a>Stop()方法</h5><p>好吧，server的最后一个方法，调用后，将停止接收请求，并且当阻塞队列中的消息处理结束后，则完整停止。代码就不列了。</p>
<p>至此，server.go内容到此结束。</p>
<h2 id="subscription-go"><a href="#subscription-go" class="headerlink" title="subscription.go"></a>subscription.go</h2><p>发布/订阅相关，这里面封装了消息结构，是否订阅等操作，这块的代码其实很简单，有兴趣的再进一步研读吧，小编精力有限，这里就不细看了，待有机会需要了，再来好好读读。</p>
<h2 id="client-go-client-example-test-go-client-test-go源码"><a href="#client-go-client-example-test-go-client-test-go源码" class="headerlink" title="client.go/client_example_test.go/client_test.go源码"></a>client.go/client_example_test.go/client_test.go源码</h2><p>大家有没有发现，前面一直在讲server相关，看得越多反而越迷茫，越往后，小编越迫切的想知道,client到底是怎样对接到server端的？<br>这次，小编打算从client_example_test.go源码开始阅读代码了，这样子更容易理解<br>打开<code>lient_example_test.go</code>你会发现，里面有一个客户端订阅消息的例子。来，还是先瞅一眼吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Number *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleClientSubscription</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client, _ := rpc.Dial(<span class="string">&quot;ws://127.0.0.1:8485&quot;</span>) <span class="comment">//客户端连接，</span></span><br><span class="line">	subch := <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">			subscribeBlocks(client, subch)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> block := <span class="keyword">range</span> subch &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;latest block:&quot;</span>, block.Number)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribeBlocks</span><span class="params">(client *rpc.Client, subch <span class="keyword">chan</span> Block)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	sub, err := client.EthSubscribe(ctx, subch, <span class="string">&quot;newBlocks&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;subscribe error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> lastBlock Block</span><br><span class="line">	<span class="keyword">if</span> err := client.CallContext(ctx, &amp;lastBlock, <span class="string">&quot;eth_getBlockByNumber&quot;</span>, <span class="string">&quot;latest&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;can&#x27;t get latest block:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	subch &lt;- lastBlock</span><br><span class="line">	fmt.Println(<span class="string">&quot;connection lost: &quot;</span>, &lt;-sub.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第1步–客户端连接"><a href="#第1步–客户端连接" class="headerlink" title="第1步–客户端连接"></a>第1步–客户端连接</h3><p>首先映入眼帘的是<code>rpc.Dial(&quot;ws://127.0.0.1:8485&quot;)</code>，它是要连接到websocket服务器端，可以理解为<code>它就是为了建立起一个客户端</code>。我们跟着进入到<code>client.go</code>文件中，会发现它调用的是<code>DialContext()</code>方法，而该方法会根据传入的不同的url类型，选择具体的网络进行连接，可以看出它目前支持的是”http”, “https”, “ws” 以及 “wss”，若url没有头部，则认为是本地进行IPC连接。从上面例子我们可知传入的是<code>ws</code>协议的连接，因此，需要接入<code>DialWebsocket(ctx, rawurl, &quot;&quot;)</code>这个方法，具体来看一下该方法吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialWebsocket</span><span class="params">(ctx context.Context, endpoint, origin <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> origin == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="keyword">if</span> origin, err = os.Hostname(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(endpoint, <span class="string">&quot;wss&quot;</span>) &#123; </span><br><span class="line">			origin = <span class="string">&quot;https://&quot;</span> + strings.ToLower(origin) <span class="comment">//origin为websocket客户端源</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			origin = <span class="string">&quot;http://&quot;</span> + strings.ToLower(origin)  <span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	config, err := websocket.NewConfig(endpoint, origin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newClient(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> wsDialContext(ctx, config)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可知，生成对应的origin，然后进一步配置websocket。origin官方的描述意思是<code>一个WebSocket客户端源</code>。<br>一切准备就绪以后，就会执行newClient()方法来生成客户端，下面来讲一下该方法。</p>
<h3 id="第2步–客户端连接内部机制"><a href="#第2步–客户端连接内部机制" class="headerlink" title="第2步–客户端连接内部机制"></a>第2步–客户端连接内部机制</h3><p>好吧，真正整合建立客户端连接的方法还是newClient()，该方法有两个参数，一个是上下文，一个是某协议生成并返回连接的方法（ws或者http）<br>先来看代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClient</span><span class="params">(initctx context.Context, connectFunc <span class="keyword">func</span>(context.Context)</span> <span class="params">(net.Conn, error)</span>) <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	conn, err := connectFunc(initctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	_, isHTTP := conn.(*httpConn)</span><br><span class="line"></span><br><span class="line">	c := &amp;Client&#123;</span><br><span class="line">		writeConn:   conn,</span><br><span class="line"></span><br><span class="line">		isHTTP:      isHTTP,</span><br><span class="line">		connectFunc: connectFunc,</span><br><span class="line">		<span class="built_in">close</span>:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		didQuit:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		reconnected: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn),</span><br><span class="line">		readErr:     <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">		readResp:    <span class="built_in">make</span>(<span class="keyword">chan</span> []*jsonrpcMessage),</span><br><span class="line">		requestOp:   <span class="built_in">make</span>(<span class="keyword">chan</span> *requestOp),</span><br><span class="line">		sendDone:    <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">		respWait:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*requestOp),</span><br><span class="line">		subs:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ClientSubscription),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isHTTP &#123;</span><br><span class="line">		<span class="keyword">go</span> c.dispatch(conn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码主要就是两个意思，先判断某协议的连接是不是http形式的，如果不是，则会启动一个goroutine调用dispatch方法。 这个方法下一个步骤专门来讲。<br>另外在此小编补充一句，HTTP协议和非HTTP协议有不同的处理流程， HTTP协议不支持长连接， 只支持一个请求对应一个回应的这种模式，同时也不支持发布/订阅模式。<br>这里还涉及到了client的结构，为了更好的理解，小编还是把这个结构列出来吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	idCounter   <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">//生成连接的函数，客户端会调用这个函数生成一个网络连接对象。</span></span><br><span class="line">	connectFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">	<span class="comment">//HTTP协议和非HTTP协议有不同的处理流程， HTTP协议不支持长连接， 只支持一个请求对应一个回应的这种模式，同时也不支持发布/订阅模式。 </span></span><br><span class="line">	isHTTP      <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过这里的注释可以看到，writeConn是调用这用来写入请求的网络连接对象，</span></span><br><span class="line">	<span class="comment">//只有在dispatch方法外面调用才是安全的，而且需要通过给requestOp队列发送请求来获取锁，</span></span><br><span class="line">	<span class="comment">//获取锁之后就可以把请求写入网络，写入完成后发送请求给sendDone队列来释放锁，供其它的请求使用。</span></span><br><span class="line">	writeConn net.Conn</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for dispatch</span></span><br><span class="line">	<span class="comment">//下面有很多的channel，channel一般来说是goroutine之间用来通信的通道，后续会随着代码介绍channel是如何使用的。</span></span><br><span class="line">	<span class="built_in">close</span>       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	didQuit     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;                  <span class="comment">// closed when client quits</span></span><br><span class="line">	reconnected <span class="keyword">chan</span> net.Conn                  <span class="comment">// where write/reconnect sends the new connection</span></span><br><span class="line">	readErr     <span class="keyword">chan</span> error                     <span class="comment">// errors from read</span></span><br><span class="line">	readResp    <span class="keyword">chan</span> []*jsonrpcMessage         <span class="comment">// valid messages from read</span></span><br><span class="line">	requestOp   <span class="keyword">chan</span> *requestOp                <span class="comment">// for registering response IDs</span></span><br><span class="line">	sendDone    <span class="keyword">chan</span> error                     <span class="comment">// signals write completion, releases write lock</span></span><br><span class="line">	respWait    <span class="keyword">map</span>[<span class="keyword">string</span>]*requestOp          <span class="comment">// active requests</span></span><br><span class="line">	subs        <span class="keyword">map</span>[<span class="keyword">string</span>]*ClientSubscription <span class="comment">// active subscriptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第3步–非http协议的dispatch处理"><a href="#第3步–非http协议的dispatch处理" class="headerlink" title="第3步–非http协议的dispatch处理"></a>第3步–非http协议的dispatch处理</h3><p>上一步中我们得知，因为我们的协议是<code>ws</code>因此会启动一个goroutine调用dispatch方法。dispatch方法是整个client的指挥中心，通过channel来和其他的goroutine来进行通信，获取信息，根据信息做出各种决策。<br>这个方法是客户端的一个核心方法，先来看代码吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatch is the main loop of the client.</span></span><br><span class="line"><span class="comment">// It sends read messages to waiting calls to Call and BatchCall</span></span><br><span class="line"><span class="comment">// and subscription notifications to registered subscriptions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">dispatch</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Spawn the initial read loop.</span></span><br><span class="line">	<span class="keyword">go</span> c.read(conn)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		lastOp        *requestOp    <span class="comment">// tracks last send operation</span></span><br><span class="line">		requestOpLock = c.requestOp <span class="comment">// nil while the send lock is held</span></span><br><span class="line">		reading       = <span class="literal">true</span>        <span class="comment">// if true, a read loop is running</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c.didQuit)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.closeRequestOps(ErrClientQuit)</span><br><span class="line">		conn.Close()</span><br><span class="line">		<span class="keyword">if</span> reading &#123;</span><br><span class="line">			<span class="comment">// Empty read channels until read is dead.</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readResp:</span><br><span class="line">				<span class="keyword">case</span> &lt;-c.readErr:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.<span class="built_in">close</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read path.</span></span><br><span class="line">		<span class="keyword">case</span> batch := &lt;-c.readResp:</span><br><span class="line">			<span class="comment">//读取到一个回应。调用相应的方法处理</span></span><br><span class="line">			<span class="keyword">for</span> _, msg := <span class="keyword">range</span> batch &#123;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> msg.isNotification():</span><br><span class="line">					log.Trace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: notification &quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					c.handleNotification(msg)</span><br><span class="line">				<span class="keyword">case</span> msg.isResponse():</span><br><span class="line">					log.Trace(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: response &quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					c.handleResponse(msg)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					log.Debug(<span class="string">&quot;&quot;</span>, <span class="string">&quot;msg&quot;</span>, log.Lazy&#123;Fn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;&lt;-readResp: dropping weird message&quot;</span>, msg)</span><br><span class="line">					&#125;&#125;)</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> maybe close</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-c.readErr:</span><br><span class="line">			<span class="comment">//接收到读取失败信息，这个是read线程传递过来的。</span></span><br><span class="line">			log.Debug(fmt.Sprintf(<span class="string">&quot;&lt;-readErr: %v&quot;</span>, err))</span><br><span class="line">			c.closeRequestOps(err)</span><br><span class="line">			conn.Close()</span><br><span class="line">			reading = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> newconn := &lt;-c.reconnected:</span><br><span class="line">			<span class="comment">//接收到一个重连接信息</span></span><br><span class="line">			log.Debug(fmt.Sprintf(<span class="string">&quot;&lt;-reconnected: (reading=%t) %v&quot;</span>, reading, conn.RemoteAddr()))</span><br><span class="line">			<span class="keyword">if</span> reading &#123;</span><br><span class="line">				<span class="comment">//等待之前的连接读取完成。</span></span><br><span class="line">				<span class="comment">// Wait for the previous read loop to exit. This is a rare case.</span></span><br><span class="line">				conn.Close()</span><br><span class="line">				&lt;-c.readErr</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//开启阅读的goroutine</span></span><br><span class="line">			<span class="keyword">go</span> c.read(newconn)</span><br><span class="line">			reading = <span class="literal">true</span></span><br><span class="line">			conn = newconn</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Send path.</span></span><br><span class="line">		<span class="keyword">case</span> op := &lt;-requestOpLock:</span><br><span class="line">			<span class="comment">// Stop listening for further send ops until the current one is done.</span></span><br><span class="line">			<span class="comment">//接收到一个requestOp消息，那么设置requestOpLock为空，</span></span><br><span class="line">			<span class="comment">//这个时候如果有其他人也希望发送op到requestOp，会因为没有人处理而阻塞。</span></span><br><span class="line">			requestOpLock = <span class="literal">nil</span></span><br><span class="line">			lastOp = op</span><br><span class="line">			<span class="comment">//把这个op加入等待队列。</span></span><br><span class="line">			<span class="keyword">for</span> _, id := <span class="keyword">range</span> op.ids &#123;</span><br><span class="line">				c.respWait[<span class="keyword">string</span>(id)] = op</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-c.sendDone:</span><br><span class="line">			<span class="comment">//当op的请求信息已经发送到网络上。会发送信息到sendDone。如果发送过程出错，那么err !=nil。</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Remove response handlers for the last send. We remove those here</span></span><br><span class="line">				<span class="comment">// because the error is already handled in Call or BatchCall. When the</span></span><br><span class="line">				<span class="comment">// read loop goes down, it will signal all other current operations.</span></span><br><span class="line">				<span class="comment">//把所有的id从等待队列删除。</span></span><br><span class="line">				<span class="keyword">for</span> _, id := <span class="keyword">range</span> lastOp.ids &#123;</span><br><span class="line">					<span class="built_in">delete</span>(c.respWait, <span class="keyword">string</span>(id))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Listen for send ops again.</span></span><br><span class="line">			<span class="comment">//重新开始处理requestOp的消息。</span></span><br><span class="line">			requestOpLock = c.requestOp</span><br><span class="line">			lastOp = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ps：由于工作上的一些意外，小编需要尽早结束本篇文章，后面剩余部分内容就全是[github-ZtesoftCS](https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)中的了，在此先感谢该作者了</code><br>下面通过下面这种图来说明dispatch的主要流程。下面图片中圆形是线程。 蓝色矩形是channel。 箭头代表了channel的数据流动方向。</p>
<img src="/articles/e10014d8/1.png" class="" title="dispatch流程">
<ul>
<li>多线程串行发送请求到网络上的流程 首先发送requestOp请求到dispatch获取到锁， 然后把请求信息写入到网络，然后发送sendDone信息到dispatch解除锁。 通过requestOp和sendDone这两个channel以及dispatch代码的配合完成了串行的发送请求到网络上的功能。</li>
<li>读取返回信息然后返回给调用者的流程。 把请求信息发送到网络上之后， 内部的goroutine read会持续不断的从网络上读取信息。 read读取到返回信息之后，通过readResp队列发送给dispatch。 dispatch查找到对应的调用者，然后把返回信息写入调用者的resp队列中。完成返回信息的流程。</li>
<li>重连接流程。 重连接在外部调用者写入失败的情况下被外部调用者主动调用。 调用完成后发送新的连接给dispatch。 dispatch收到新的连接之后，会终止之前的连接，然后启动新的read goroutine来从新的连接上读取信息。</li>
<li>关闭流程。 调用者调用Close方法，Close方法会写入信息到close队列。 dispatch接收到close信息之后。 关闭didQuit队列，关闭连接，等待read goroutine停止。 所有等待在didQuit队列上面的客户端调用全部返回。</li>
</ul>
<p>订阅部分小编暂时就不讲了。</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>本篇写的有点仓促，小编也认为写的很不合格，由于一些意外，小编源码阅读暂时停止更新。<br>后面若有机会，会修正本文内容的。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第5.1讲-rpc官翻及个人理解</title>
    <url>/articles/25c7447/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>rpc在ethereum中是很重要的一个模块，官方在该模块的一个叫做<code>doc.go</code>的文件中专门介绍了RPC的机制。本文小编会带着自己的理解逐步翻译<code>doc.go</code>中对RPC机制的描述。</p>
<a id="more"></a>
<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC全称是<code>Remote Procedure Call</code>，翻译过来就是远程程序调用，通俗的说就是远程服务器开放出某程序的方法(接口)，客户端通过网络或者其它的I/O通道调用这个方法，从而完成交互。又或者用另一种通俗的解释：调用远程计算机上的服务，就像调用本地服务一样。</p>
<p>当一个service创建后，将其注册到服务器上，这样该service就可以被外界的客户端访问了。<br>符合以下标准的方法可用于远程访问：</p>
<ul>
<li>对象必须导出</li>
<li>方法必须导出</li>
<li>方法返回0，1（响应或错误）或2（响应和错误）值</li>
<li>方法参数必须导出或是内置类型</li>
<li>方法返回值必须导出或是内置类型</li>
</ul>
<p>RPC在此支持使用订阅来支持发布/订阅模式。要满足此类模式的方法必须满足如下条件：</p>
<ul>
<li>对象必须导出</li>
<li>方法必须导出</li>
<li>第一个方法参数类型必须是context.Context</li>
<li>方法参数必须导出或内置类型</li>
<li>方法必须返回<code>元组订阅</code>和<code>错误</code></li>
</ul>
<p>发生以下情况时，订阅将会被删除：</p>
<ul>
<li>用户发出取消订阅的请求</li>
<li>创建订阅的连接被关闭。这种情况可能由客户端或者服务器触发。 服务器在写入出错或者是通知队列长度太大的时候会选择关闭连接。</li>
</ul>
<p><code>ps</code>：被调用者认为是服务器，调用者认为是客户端</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="示例1-基本操作"><a href="#示例1-基本操作" class="headerlink" title="示例1-基本操作:"></a>示例1-基本操作:</h3><p>如果返回的<code>error</code>不为空，则返回的<code>int</code>会被忽略，那<code>error</code>会被发送给客户端；反之若<code>error</code>为空，则发送<code>int</code>给客户端。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CalcService)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="示例2-参数支持指针"><a href="#示例2-参数支持指针" class="headerlink" title="示例2-参数支持指针"></a>示例2-参数支持指针</h3><p>关于这个示例官方写了很多解释，但越解释越乱，按小编的意思，知道可以接收指针就行。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CalService)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>, mod *<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="示例3-服务器端接收"><a href="#示例3-服务器端接收" class="headerlink" title="示例3-服务器端接收"></a>示例3-服务器端接收</h3><p>服务器端提供一个ServeCodec方法，用来接收一个ServeCodec实例，其中的codec用来读取客户端发出的request。codec处理request后，会把response返回给客户端。<br>服务器的这些请求或者响应，当然是并发的，不用解释了吧。<br>下面来看一个json形式的codec例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CalculatorService <span class="keyword">struct</span> &#123;&#125;  <span class="comment">//定义服务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//CalculatorService对应的第一个方法 </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *CalculatorService)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CalculatorService对应的第二个方法</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *CalculatorService Div(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> a/b, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> calculator := <span class="built_in">new</span>(CalculatorService)  <span class="comment">// 实例化</span></span><br><span class="line"> server := NewServer()  <span class="comment">//服务管理器</span></span><br><span class="line"> server.RegisterName(<span class="string">&quot;calculator&quot;</span>, calculator)  <span class="comment">//注册服务</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//监听获取回调</span></span><br><span class="line"> l, _ := net.ListenUnix(<span class="string">&quot;unix&quot;</span>, &amp;net.UnixAddr&#123;Net: <span class="string">&quot;unix&quot;</span>, Name: <span class="string">&quot;/tmp/calculator.sock&quot;</span>&#125;)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">	c, _ := l.AcceptUnix()</span><br><span class="line">	codec := v2.NewJSONCodec(c)</span><br><span class="line">	<span class="keyword">go</span> server.ServeCodec(codec) <span class="comment">//</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例4-发布-订阅"><a href="#示例4-发布-订阅" class="headerlink" title="示例4-发布/订阅"></a>示例4-发布/订阅</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *BlockChainService)</span> <span class="title">NewBlocks</span><span class="params">(ctx context.Context)</span> <span class="params">(Subscription, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>整体来说，本文主要还是介绍了rpc的一些基本规范，真正的掌握这个内容，还需要我们再代码中来理解。小编下一部分来解析rpc模块的具体代码。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第4讲-ethdb模块源码解读</title>
    <url>/articles/f54b1404/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了trie模块的源码，我们知道了其中的节点数据是通过ethdb来进行磁盘db的读写操作的。其实ethdb是依赖google的一个开源kv数据库levelDB实现的。最终所有的数据都是存储在levelDB中。<br>我们会很好奇，什么是levelDB？在ethdb中是如何处理levelDB的？下面小编一步步来揭开它的面纱。</p>
<a id="more"></a>

<h2 id="什么是levelDB"><a href="#什么是levelDB" class="headerlink" title="什么是levelDB"></a>什么是levelDB</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>效率高，支持billion级别的数据量</li>
<li>key和value都是任意长度的字节数组；</li>
<li>entry（即一条K-V记录）默认是按照key的字典顺序存储的，当然开发者也可以重载这个排序函数；</li>
<li>提供的基本操作接口：Put()、Delete()、Get()、Batch()；</li>
<li>支持批量操作以原子操作进行；</li>
<li>可以创建数据全景的snapshot(快照)，并允许在快照中查找数据；</li>
<li>可以通过前向（或后向）迭代器遍历数据（迭代器会隐含的创建一个snapshot）；</li>
<li>自动使用Snappy压缩数据；</li>
<li>可移植性；</li>
</ul>
<h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><ul>
<li>非关系型数据模型（NoSQL），不支持sql语句，也不支持索引；</li>
<li>一次只允许一个进程访问一个特定的数据库；</li>
<li>没有内置的C/S架构，就是说不包含网络服务架构，但开发者可以使用LevelDB库自己封装一个server；</li>
</ul>
<h2 id="ethdb模块概述"><a href="#ethdb模块概述" class="headerlink" title="ethdb模块概述"></a>ethdb模块概述</h2><p>这个模块不复杂，直接看里面的文件结构：<br>.<br>|____interface.go  数据库接口定义<br>|____database.go  对levelDB进行封装<br>|____database_test.go  测试案例，本文不讲这个，模块不复杂，不需要专门去探讨案例<br>|____memory_database.go  用于db测试，生产中不可使用。在trie模块中的测试案例应该见过很多次这个东西了<br>一目了然，只有四个文件。下面我们一个个来讲</p>
<h2 id="interface-go源码解读"><a href="#interface-go源码解读" class="headerlink" title="interface.go源码解读"></a>interface.go源码解读</h2><p>这个是需要第一个掌握的源码内容，因为它为在以太坊中操作db定义了一套规则，因此，要想了解ethdb模块就得先了解这个文件。<br>接口规范，代码不多，老规矩，先贴代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IdealBatchSize = <span class="number">100</span> * <span class="number">1024</span> <span class="comment">//批处理数据的时候用的值，这个值是根据实际调试经验确定的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于普通操作和批量操作写入数据</span></span><br><span class="line"><span class="keyword">type</span> Putter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Put(key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了所有的数据库操作， 所有的方法都是多线程安全的。</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">	Putter</span><br><span class="line">	Get(key []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error) <span class="comment">//获取</span></span><br><span class="line">	Has(key []<span class="keyword">byte</span>) (<span class="keyword">bool</span>, error)  <span class="comment">//判断</span></span><br><span class="line">	Delete(key []<span class="keyword">byte</span>) error  <span class="comment">//删除</span></span><br><span class="line">	Close()  <span class="comment">//关闭</span></span><br><span class="line">	NewBatch() Batch  <span class="comment">//实例化新的批处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量操作接口，不能多线程同时使用，当Write方法被调用的时候，数据库会提交写入的更改。</span></span><br><span class="line"><span class="keyword">type</span> Batch <span class="keyword">interface</span> &#123;</span><br><span class="line">	Putter</span><br><span class="line">	ValueSize() <span class="keyword">int</span>   <span class="comment">//批处理中的数据量</span></span><br><span class="line">	Write() error</span><br><span class="line">	Reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，<code>全都是字节形式的数据。</code><br>主要就是两大类，批处理操作和普通操作，两种方式的数据库操作。<br>没什么可以解释的</p>
<h2 id="memory-database-go-源码解读"><a href="#memory-database-go-源码解读" class="headerlink" title="memory_database.go 源码解读"></a>memory_database.go 源码解读</h2><p>看过trie模块代码的同学，应该很熟悉这个文件，官方解释说该文件仅供测试使用，可以说，这个文件只是模拟的一个数据库，并没有真正对接到levelDB，只是为了方便数据库的测试操作而使用。先来看代码，然后再解释，先上一坨代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个模拟存储数据的&lt;k,v&gt;数据库，可以看到，数据是存在了内存map中</span></span><br><span class="line"><span class="keyword">type</span> MemDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于实例化数据库，此处是为map开辟空间，没有指定具体大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemDatabase</span><span class="params">()</span> <span class="params">(*MemDatabase, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MemDatabase&#123;</span><br><span class="line">		db: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于实例化数据库，此处是为map开辟空间，指定了具体大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMemDatabaseWithCap</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="params">(*MemDatabase, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MemDatabase&#123;</span><br><span class="line">		db: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, size),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据存放到模拟的数据库里，也就是那个map里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Put</span><span class="params">(key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	db.lock.Lock() <span class="comment">//注意读写锁额</span></span><br><span class="line">	<span class="keyword">defer</span> db.lock.Unlock() <span class="comment">//defer是干嘛的，小编在别的文章里解释好多遍了。。</span></span><br><span class="line"></span><br><span class="line">	db.db[<span class="keyword">string</span>(key)] = common.CopyBytes(value) <span class="comment">//　好，插进去了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key检测某个数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Has</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	db.lock.RLock()  <span class="comment">//只读锁</span></span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	_, ok := db.db[<span class="keyword">string</span>(key)]</span><br><span class="line">	<span class="keyword">return</span> ok, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取某value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	db.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> entry, ok := db.db[<span class="keyword">string</span>(key)]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> common.CopyBytes(entry), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取db中所有的key，这样就可以在内存中验证某数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Keys</span><span class="params">()</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">	db.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	keys := [][]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> db.db &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, []<span class="keyword">byte</span>(key))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据，没啥解释的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	db.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(db.db, <span class="keyword">string</span>(key))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭，但是这是模拟数据库，因此也没什么可以关闭的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化批量操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">NewBatch</span><span class="params">()</span> <span class="title">Batch</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;memBatch&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//db长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *MemDatabase)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(db.db) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给批量操作定义一个要写入的数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> kv <span class="keyword">struct</span>&#123; k, v []<span class="keyword">byte</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存中模拟的批量数据的格式</span></span><br><span class="line"><span class="keyword">type</span> memBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	db     *MemDatabase <span class="comment">//数据库</span></span><br><span class="line">	writes []kv  <span class="comment">//写入的数据长度</span></span><br><span class="line">	size   <span class="keyword">int</span>   <span class="comment">//写入的数据长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据前的预处理，把外部批量导入的数据，进行批处理结构体格式的组合，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span> <span class="title">Put</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	b.writes = <span class="built_in">append</span>(b.writes, kv&#123;common.CopyBytes(key), common.CopyBytes(value)&#125;)</span><br><span class="line">	b.size += <span class="built_in">len</span>(value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把预处理好的数据插入到模拟数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span> <span class="title">Write</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	b.db.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> b.db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> b.writes &#123;</span><br><span class="line">		b.db.db[<span class="keyword">string</span>(kv.k)] = kv.v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批处理数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span> <span class="title">ValueSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复原批处理，毕竟这只是数据库中间的操作过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *memBatch)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b.writes = b.writes[:<span class="number">0</span>]</span><br><span class="line">	b.size = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件只是一个模拟的数据库，其实都是在内存中操作的。两部分，一个是数据库的操作，一个是批处理的操作。<br>上面小编基本都注释好了，应该很好理解吧？那小编就开始下一部分的讲解啦</p>
<h2 id="database-go源码解读"><a href="#database-go源码解读" class="headerlink" title="database.go源码解读"></a>database.go源码解读</h2><p>本来小编是想通过database_test.go中的测试用例来解读database.go源码的，但综合前面已经介绍的数据库相关内容，直接解释database.go源码应该更好一些。<br>这个文件真正的封装了google的levelDB，让我们来揭开一下这个神秘的面纱。</p>
<h3 id="所引用的包"><a href="#所引用的包" class="headerlink" title="所引用的包"></a>所引用的包</h3><p>先来看看它引用了哪些包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/ethereum/go-ethereum/log&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/ethereum/go-ethereum/metrics&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/filter&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/iterator&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/opt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/syndtr/goleveldb/leveldb/util&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以看出，除了引用了go本身的包的，还引用了<code>github.com/syndtr/goleveldb/leveldb</code>中的东西，这个是使用go封装过的leveldb，在github中可以找到该源码。</p>
<h3 id="db数据结构"><a href="#db数据结构" class="headerlink" title="db数据结构"></a>db数据结构</h3><p>接着来看一下以太坊对levelDB的结构的封装</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OpenFileLimit = <span class="number">64</span>  <span class="comment">//限制同时最多只能打开64个文件？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一套用于记录操作db的结构</span></span><br><span class="line"><span class="keyword">type</span> LDBDatabase <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="keyword">string</span>      <span class="comment">// 用于存放报告的文件</span></span><br><span class="line">	db *leveldb.DB <span class="comment">// google的levelDB实例</span></span><br><span class="line"></span><br><span class="line">	compTimeMeter  metrics.Meter <span class="comment">// 计算压缩数据所要花费的时间</span></span><br><span class="line">	compReadMeter  metrics.Meter <span class="comment">// 压缩期间读取的数据</span></span><br><span class="line">	compWriteMeter metrics.Meter <span class="comment">// 压缩期间写入的数据</span></span><br><span class="line">	diskReadMeter  metrics.Meter <span class="comment">// 计算读取数据影响到的条数</span></span><br><span class="line">	diskWriteMeter metrics.Meter <span class="comment">// 计算写入数据影响到的条数</span></span><br><span class="line"></span><br><span class="line">	quitLock sync.Mutex      <span class="comment">// 停止时候的访问保护</span></span><br><span class="line">	quitChan <span class="keyword">chan</span> <span class="keyword">chan</span> error <span class="comment">// 退出db前的处理</span></span><br><span class="line"></span><br><span class="line">	log log.Logger <span class="comment">// 日志 db路径跟踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先看到的是一堆的<code>metrics</code>，这是以太坊自己用于统计数据，评估性能的模块，姑且不去考虑。<br>从结构中我们也大致了解到，这它主要就是用来记录数据库的使用情况，加上退出db时候的处理。</p>
<h3 id="LDBDatabase用于实例化的方法"><a href="#LDBDatabase用于实例化的方法" class="headerlink" title="LDBDatabase用于实例化的方法"></a>LDBDatabase用于实例化的方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLDBDatabase</span><span class="params">(file <span class="keyword">string</span>, cache <span class="keyword">int</span>, handles <span class="keyword">int</span>)</span> <span class="params">(*LDBDatabase, error)</span></span> &#123;</span><br><span class="line">	logger := log.New(<span class="string">&quot;database&quot;</span>, file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保有一些缓存和文件</span></span><br><span class="line">	<span class="keyword">if</span> cache &lt; <span class="number">16</span> </span><br><span class="line">		cache = <span class="number">16</span></span><br><span class="line">	<span class="keyword">if</span> handles &lt; <span class="number">16</span> </span><br><span class="line">		handles = <span class="number">16</span></span><br><span class="line">	logger.Info(<span class="string">&quot;Allocated cache and file handles&quot;</span>, <span class="string">&quot;cache&quot;</span>, cache, <span class="string">&quot;handles&quot;</span>, handles)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化，性能调优相关 leveldb</span></span><br><span class="line">	db, err := leveldb.OpenFile(file, &amp;opt.Options&#123;</span><br><span class="line">		OpenFilesCacheCapacity: handles,</span><br><span class="line">		BlockCacheCapacity:     cache / <span class="number">2</span> * opt.MiB,</span><br><span class="line">		WriteBuffer:            cache / <span class="number">4</span> * opt.MiB, </span><br><span class="line">		Filter:                 filter.NewBloomFilter(<span class="number">10</span>),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> _, corrupted := err.(*errors.ErrCorrupted); corrupted </span><br><span class="line">		db, err = leveldb.RecoverFile(file, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// (Re)check for errors and abort if opening of the db failed</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	<span class="keyword">return</span> &amp;LDBDatabase&#123;</span><br><span class="line">		fn:  file,</span><br><span class="line">		db:  db,</span><br><span class="line">		log: logger,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个大体上就是levelDB的初始化操作，被外面的LDBDatabase封装了</p>
<h3 id="LDBDatabase的方法"><a href="#LDBDatabase的方法" class="headerlink" title="LDBDatabase的方法"></a>LDBDatabase的方法</h3><p>LDBDatabase的方法还是需要关注的。<br>封装之后的代码是支持多线程同时访问的，LDBDatabase中的方法是不需要进行安全处理的，可直接调用。</p>
<h4 id="先来看一些简单的方法"><a href="#先来看一些简单的方法" class="headerlink" title="先来看一些简单的方法"></a>先来看一些简单的方法</h4><p>都是一些比较基础的方法操作，有一个需要注意：插入数据时候，其实是插入到了内存队列中，并未写入db磁盘。而删除时候会把队列和磁盘的都删除了。<br>剩下的小编就不解释了，都在代码里标注了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取db的路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Path</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到leveldb的缓存队列中了，此时并没有写入磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Put</span><span class="params">(key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Put(key, value, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某key对应的数据是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Has</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Has(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某key对应的数据若存在，则返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	dat, err := db.db.Get(key, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	<span class="keyword">return</span> dat, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key删除缓存队列和磁盘中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.Delete(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历的迭代器初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">NewIterator</span><span class="params">()</span> <span class="title">iterator</span>.<span class="title">Iterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.NewIterator(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据提供的前缀，返回一个合适的迭代器，方便你查找该前缀子集的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">NewIteratorWithPrefix</span><span class="params">(prefix []<span class="keyword">byte</span>)</span> <span class="title">iterator</span>.<span class="title">Iterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db.NewIterator(util.BytesPrefix(prefix), <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某次数据库操作结束后关闭该实例，停止metrics统计信息，防止多个因为启动的数据库实例过多造成内部资源竞争</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db.quitLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> db.quitLock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> db.quitChan != <span class="literal">nil</span> &#123;</span><br><span class="line">		errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">		db.quitChan &lt;- errc</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-errc; err != <span class="literal">nil</span> </span><br><span class="line">			db.log.Error(<span class="string">&quot;Metrics collection failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err := db.db.Close()</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> </span><br><span class="line">		db.log.Info(<span class="string">&quot;Database closed&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		db.log.Error(<span class="string">&quot;Failed to close database&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前db实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">LDB</span><span class="params">()</span> *<span class="title">leveldb</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">NewBatch</span><span class="params">()</span> <span class="title">Batch</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ldbBatch&#123;db: db.db, b: <span class="built_in">new</span>(leveldb.Batch)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="再来看个比较复杂的方法"><a href="#再来看个比较复杂的方法" class="headerlink" title="再来看个比较复杂的方法"></a>再来看个比较复杂的方法</h4><p>这个方法主要是配置db性能检测的属性，也就是记录leveldb中的一些计数器，如果没有收到<code>quitChan()</code>,则会一直运行监测，另外要记住是每3秒钟获取一次leveldb中的计数器信息，具体看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">Meter</span><span class="params">(prefix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !metrics.Enabled  <span class="comment">//不检测，检测会消耗不少性能（个人感觉）</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="comment">//根据传入的前缀，增加一些信息</span></span><br><span class="line">	db.compTimeMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/time&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.compReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/input&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.compWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;compact/output&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.diskReadMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;disk/read&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	db.diskWriteMeter = metrics.NewRegisteredMeter(prefix+<span class="string">&quot;disk/write&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 退出处理</span></span><br><span class="line">	db.quitLock.Lock()</span><br><span class="line">	db.quitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error)</span><br><span class="line">	db.quitLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> db.meter(<span class="number">3</span> * time.Second) <span class="comment">//启动线程，调用监控，这貌似是每3秒监控一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后来看个最复杂的方法"><a href="#最后来看个最复杂的方法" class="headerlink" title="最后来看个最复杂的方法"></a>最后来看个最复杂的方法</h4><p>周期性监测leveldb内部的计数器，然后把信息报告给检测器，来看代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是当前版本报告的图表样式:</span></span><br><span class="line"><span class="comment">//   Compactions</span></span><br><span class="line"><span class="comment">//    Level |   Tables   |    Size(MB)   |    Time(sec)  |    Read(MB)   |   Write(MB)</span></span><br><span class="line"><span class="comment">//   -------+------------+---------------+---------------+---------------+---------------</span></span><br><span class="line"><span class="comment">//      0   |          0 |       0.00000 |       1.27969 |       0.00000 |      12.31098</span></span><br><span class="line"><span class="comment">//      1   |         85 |     109.27913 |      28.09293 |     213.92493 |     214.26294</span></span><br><span class="line"><span class="comment">//      2   |        523 |    1000.37159 |       7.26059 |      66.86342 |      66.77884</span></span><br><span class="line"><span class="comment">//      3   |        570 |    1113.18458 |       0.00000 |       0.00000 |       0.00000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这是当前版本读写监控的文本样式:</span></span><br><span class="line"><span class="comment">// Read(MB):3895.04860 Write(MB):3654.64712</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *LDBDatabase)</span> <span class="title">meter</span><span class="params">(refresh time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个计数器集合用于保存当前和先前的压缩值</span></span><br><span class="line">	compactions := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++</span><br><span class="line">		compactions[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 用于保存读写的数据信息</span></span><br><span class="line">	<span class="keyword">var</span> iostats [<span class="number">2</span>]<span class="keyword">float64</span></span><br><span class="line">	<span class="comment">// 一直循环来记录</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; ; i++ &#123;</span><br><span class="line">		<span class="comment">// 恢复数据状态</span></span><br><span class="line">		stats, err := db.db.GetProperty(<span class="string">&quot;leveldb.stats&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			db.log.Error(<span class="string">&quot;Failed to read database stats&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">//找用于记录压缩table</span></span><br><span class="line">		lines := strings.Split(stats, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(lines) &gt; <span class="number">0</span> &amp;&amp; strings.TrimSpace(lines[<span class="number">0</span>]) != <span class="string">&quot;Compactions&quot;</span> </span><br><span class="line">			lines = lines[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(lines) &lt;= <span class="number">3</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Compaction table not found&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		lines = lines[<span class="number">3</span>:]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检索所有table</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(compactions[i%<span class="number">2</span>]); j++ </span><br><span class="line">			compactions[i%<span class="number">2</span>][j] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _, line := <span class="keyword">range</span> lines &#123;</span><br><span class="line">			parts := strings.Split(line, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">6</span> </span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">for</span> idx, counter := <span class="keyword">range</span> parts[<span class="number">3</span>:] &#123;</span><br><span class="line">				value, err := strconv.ParseFloat(strings.TrimSpace(counter), <span class="number">64</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					db.log.Error(<span class="string">&quot;Compaction entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				compactions[i%<span class="number">2</span>][idx] += value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新所有需要的meter</span></span><br><span class="line">		<span class="keyword">if</span> db.compTimeMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compTimeMeter.Mark(<span class="keyword">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">0</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">0</span>]) * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>))</span><br><span class="line">		<span class="keyword">if</span> db.compReadMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compReadMeter.Mark(<span class="keyword">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">1</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">1</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		<span class="keyword">if</span> db.compWriteMeter != <span class="literal">nil</span> </span><br><span class="line">			db.compWriteMeter.Mark(<span class="keyword">int64</span>((compactions[i%<span class="number">2</span>][<span class="number">2</span>] - compactions[(i<span class="number">-1</span>)%<span class="number">2</span>][<span class="number">2</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化io操作的记录</span></span><br><span class="line">		ioStats, err := db.db.GetProperty(<span class="string">&quot;leveldb.iostats&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Failed to read database iostats&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		parts := strings.Split(ioStats, <span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(parts) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of ioStats&quot;</span>, <span class="string">&quot;ioStats&quot;</span>, ioStats)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		r := strings.Split(parts[<span class="number">0</span>], <span class="string">&quot;:&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(r) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of read entry&quot;</span>, <span class="string">&quot;entry&quot;</span>, parts[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		read, err := strconv.ParseFloat(r[<span class="number">1</span>], <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Read entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w := strings.Split(parts[<span class="number">1</span>], <span class="string">&quot;:&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(w) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Bad syntax of write entry&quot;</span>, <span class="string">&quot;entry&quot;</span>, parts[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		write, err := strconv.ParseFloat(w[<span class="number">1</span>], <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.log.Error(<span class="string">&quot;Write entry parsing failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> db.diskReadMeter != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.diskReadMeter.Mark(<span class="keyword">int64</span>((read - iostats[<span class="number">0</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> db.diskWriteMeter != <span class="literal">nil</span> &#123;</span><br><span class="line">			db.diskWriteMeter.Mark(<span class="keyword">int64</span>((write - iostats[<span class="number">1</span>]) * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		iostats[<span class="number">0</span>] = read</span><br><span class="line">		iostats[<span class="number">1</span>] = write</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> errc := &lt;-db.quitChan:</span><br><span class="line">			errc &lt;- <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(refresh):</span><br><span class="line">			<span class="comment">// 超时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批处理相关"><a href="#批处理相关" class="headerlink" title="批处理相关"></a>批处理相关</h3><p>从前面我们也了解到了，有时候我们需要批量处理数据，具体在database.go中是如下定义和实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ldbBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   *leveldb.DB</span><br><span class="line">	b    *leveldb.Batch</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里只是写入内存队列，并没有插入db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span> <span class="title">Put</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	b.b.Put(key, value)</span><br><span class="line">	b.size += <span class="built_in">len</span>(value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里才真正写入db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span> <span class="title">Write</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.db.Write(b.b, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span> <span class="title">ValueSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ldbBatch)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b.b.Reset()</span><br><span class="line">	b.size = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>memory_database.go</code>中的定义一样，一目了然，不用小编解释了吧？</p>
<h3 id="通用的db操作封装"><a href="#通用的db操作封装" class="headerlink" title="通用的db操作封装"></a>通用的db操作封装</h3><p>剩下的代码，定义了<code>table</code>和<code>tableBatch</code>的规则，这进一步对数据库做了通用的处理，通过这一套规则，底层可以使用别的各种数据库，不一定要选择levelDB。本不打算再列这块的代码的，算了，这模块的内容不多，就把这代码也都贴出来吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> table <span class="keyword">struct</span> &#123;</span><br><span class="line">	db     Database</span><br><span class="line">	prefix <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只要传入一个满足Database接口的db，均可正常操作本数据库，通用性更强</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTable</span><span class="params">(db Database, prefix <span class="keyword">string</span>)</span> <span class="title">Database</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;table&#123;</span><br><span class="line">		db:     db,</span><br><span class="line">		prefix: prefix,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">Put</span><span class="params">(key []<span class="keyword">byte</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Put(<span class="built_in">append</span>([]<span class="keyword">byte</span>(dt.prefix), key...), value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">Has</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Has(<span class="built_in">append</span>([]<span class="keyword">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">Get</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Get(<span class="built_in">append</span>([]<span class="keyword">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">Delete</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> dt.db.Delete(<span class="built_in">append</span>([]<span class="keyword">byte</span>(dt.prefix), key...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Do nothing; don&#x27;t close the underlying DB.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tableBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	batch  Batch</span><br><span class="line">	prefix <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTableBatch returns a Batch object which prefixes all keys with a given string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTableBatch</span><span class="params">(db Database, prefix <span class="keyword">string</span>)</span> <span class="title">Batch</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;tableBatch&#123;db.NewBatch(), prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dt *table)</span> <span class="title">NewBatch</span><span class="params">()</span> <span class="title">Batch</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;tableBatch&#123;dt.db.NewBatch(), dt.prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span> <span class="title">Put</span><span class="params">(key, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.Put(<span class="built_in">append</span>([]<span class="keyword">byte</span>(tb.prefix), key...), value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span> <span class="title">Write</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.Write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span> <span class="title">ValueSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tb.batch.ValueSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *tableBatch)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tb.batch.Reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不讲了，自己领悟吧。</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>本文主要介绍了以太坊对db接口的定义，对levelDB的封装，另外也给出一套通用的规范，来让人们可以更自由的选择使用别的数据库。<br>其中db中均涉及到了普通操作和批处理操作。另外对于levelDB,还加入了性能检测（计数）相关内容。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第3.2讲-trie模块源码解读</title>
    <url>/articles/dcade07d/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分，我们主要是讲trie源码的实现，要理解代码的实现过程，是需要先了解一下理论内容的，建议大家先看看我的上一篇文章：<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a></p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>小编根据对已有代码的了解，画了这么个trie相关一览图：</p>
<img src="/articles/dcade07d/1.png" class="" title="空树中添加到一个节点">

<h2 id="encoding-go源码解读"><a href="#encoding-go源码解读" class="headerlink" title="encoding.go源码解读"></a>encoding.go源码解读</h2><p>trie模块中，这个文件是我们首先要掌握的，这个主要是讲三种编码（<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>）的实现与转换，trie中全程都需要用到这些，该文件中主要实现了如下功能：</p>
<ol>
<li>hex编码转换为Compact编码：<code>hexToCompact()</code></li>
<li>Compact编码转换为hex编码：<code>compactToHex()</code></li>
<li>keybytes编码转换为Hex编码：<code>keybytesToHex()</code></li>
<li>hex编码转换为keybytes编码：<code>hexToKeybytes()</code></li>
<li>获取两个字节数组的公共前缀的长度：<code>prefixLen()</code></li>
</ol>
<p>但是，小编不会去讲这块的源码内容了，因为<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>这篇文章里已经穿插了很多相关的源码，重点都已经在其中解释的很详细了。<br>如果还有哪些地方不了解，大家可以留言或者微信与小编联系。</p>
<h2 id="node-go源码解读"><a href="#node-go源码解读" class="headerlink" title="node.go源码解读"></a>node.go源码解读</h2><p>大家得先看懂<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>关于节点方面的内容，否则很难理解小编下面要讲的源码。</p>
<h3 id="node的结构与定义"><a href="#node的结构与定义" class="headerlink" title="node的结构与定义"></a>node的结构与定义</h3><p>以太坊为MPT中的node定义了一套基本接口规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">interface</span> &#123;</span><br><span class="line">	fstring(<span class="keyword">string</span>) <span class="keyword">string</span> <span class="comment">//用来打印节点信息，没别的作用</span></span><br><span class="line">	cache() (hashNode, <span class="keyword">bool</span>)  <span class="comment">//保存缓存</span></span><br><span class="line">	canUnload(cachegen, cachelimit <span class="keyword">uint16</span>) <span class="keyword">bool</span>  <span class="comment">//除去缓存，cache次数的计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以太坊依据上面的规则为MTP定义了四种类型的节点，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123;</span><br><span class="line">		Children [<span class="number">17</span>]node  <span class="comment">//对应了黄皮书里面的分支节点</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123;  <span class="comment">//对应了黄皮书里面的扩展节点</span></span><br><span class="line">		Key   []<span class="keyword">byte</span></span><br><span class="line">		Val   node  <span class="comment">//可能指向叶子节点，也可能指向分支节点。</span></span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="keyword">byte</span></span><br><span class="line">	valueNode []<span class="keyword">byte</span>  <span class="comment">//叶子节点值，但是该叶子节点最终还是会包装在shortNode中</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>分为这四种节点：</p>
<ul>
<li>fullNode<br>这就是传说中的分支节点，会发现它里面定义了17个node，其中16个对应的16进制的0<del>9a</del>f，第17个还没搞清楚，后面清楚了再来讲。nodeFlag稍后再说。</li>
<li>shortNode<br>它本身若是扩展节点，则它的属性Val可能指向分支节点或者叶子节点，但要知道，叶子节点本身同样是用shortNode表示的；<br>它本身若是叶子节点，则Val的值为rlp编码的数据，而key则是该数据的完整hash(经过hex编码的)</li>
<li>valueNode：这是给叶子节点用的，但是要知道它不能单独使用，而是要放在shortNode中使用的，用于存放rlp编码的原始数据</li>
<li>hashNode：这个同样不能单独使用，我们在上面节点定义中发现了，会涉及到<code>nodeFlag</code>，先来看看定义：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeFlag <span class="keyword">struct</span> &#123;</span><br><span class="line">	hash  hashNode <span class="comment">// cached hash of the node (may be nil)</span></span><br><span class="line">	gen   <span class="keyword">uint16</span>   <span class="comment">// cache generation counter</span></span><br><span class="line">	dirty <span class="keyword">bool</span>     <span class="comment">// whether the node has changes that must be written to the database</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在其中发现了hashNode，这个属性是用来标记nodeFlag所属的node对象本身经过rlp编码后的hash值（该hash在hashNode中同样是经过hex编码的），若node有任何变化，则该hash就会发生变化。<br>nodeFlag中的gen，只要对应的node发生一次变化，计数就加一<br>nodeFlage中的bool，只要对应的node发生变化，它就变成true，表示要把数据重新刷新到DB中(以太坊用levelDB存储MTP信息)<br>小编认为，对node理解到此处就可以了，对node的具体操作，要结合MPT的具体操作来掌握，这就引出了我们的下一部分需要掌握的文件：trie.go</li>
</ul>
<h2 id="trie-go源码解读"><a href="#trie-go源码解读" class="headerlink" title="trie.go源码解读"></a>trie.go源码解读</h2><p>我们先来了解下以太坊给trie定义的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	db           *Database  <span class="comment">//trei在levelDB中</span></span><br><span class="line">	root         node  <span class="comment">//根结点</span></span><br><span class="line">	originalRoot common.Hash  <span class="comment">//32位byte[],从db中恢复出完整的trie</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cachegen表示当前trie树的版本，trie每次commit，则增加1</span></span><br><span class="line">	<span class="comment">//cachelimit如果当前的cache时代 - cachelimit参数 大于node的cache时代，那么node会从cache里面卸载，以便节约内存。</span></span><br><span class="line">	cachegen, cachelimit <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体我们来解读一下其中的每部分：</p>
<ul>
<li>db</li>
<li>root 可以理解为当前root指向哪个节点，初始时候，没有内容，则root=nil，表示指向nil</li>
<li>originalRoot</li>
<li>cachegen</li>
<li>cachelimit</li>
</ul>
<p>按小编的理解，trie中存入db本身的是各种类型的node，也就是从root指向的那个node开始存储，root本身并不存储。</p>
<p>想要真正掌握以太坊中的trie，小编建议还是从它的测试文件node_test.go作为入口来读取源码，这里面涉及到内容如果都看懂，那相信你对MPT了解已经非常深刻了。好，那咱们一个个来看：</p>
<h3 id="一颗空树"><a href="#一颗空树" class="headerlink" title="一颗空树"></a>一颗空树</h3><p>当为一颗空树时候，也就是trie只有一个节点，且trie.root=nil。<br>此时使用trie.Hash()可以返回当前整个trie树的hash值。而emptyRoot是trie预先定义的一个空节点时候的hash常量，将当前trie的hash和它比较，可以校验当前trie是否为空树。具体代码如下：<br>注意，这些hash是真实值，从进一步的代码中，我们是可以得知，这些hash是使用hex转换回来的hash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEmptyTrie</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> trie Trie</span><br><span class="line">	res := trie.Hash() <span class="comment">//获取当前trie的hash</span></span><br><span class="line">	exp := emptyRoot</span><br><span class="line">	<span class="keyword">if</span> res != common.Hash(exp) &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expected %x got %x&quot;</span>, exp, res)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从空树中添加一个节点"><a href="#从空树中添加一个节点" class="headerlink" title="从空树中添加一个节点"></a>从空树中添加一个节点</h3><p>添加一个节点，也就是添加叶子结点，先来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNull</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> trie Trie</span><br><span class="line">	value := []<span class="keyword">byte</span>(<span class="string">&quot;test&quot;</span>)  <span class="comment">//value为字节数组</span></span><br><span class="line">	key := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>) <span class="comment">//一个32位的hash，但是其中每一位都是0</span></span><br><span class="line">	trie.Update(key, value)</span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(trie.Get(key), value) &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;wrong value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始时，tril.root指向的是nil。<br>value：要把一个字符串内容为”test”的数据存入trie中<br>key：应该是value对应的rlp编码后的hash值<br>从trie.Update()进入到trie.go的insert方法中：会发现，key和value被组成一个shortNode，表示一个叶子节点，插入到trie空树中。<br>然后trie.root指向这个叶子节点。<br>可以这么理解，此时这棵树有一个根结点和一个叶子结点。<br>为更好说明，上个图，大体如下：</p>
<img src="/articles/dcade07d/1.png" class="" title="空树中添加到一个节点">

<h3 id="数据库中检测一个不存在的trie根节点"><a href="#数据库中检测一个不存在的trie根节点" class="headerlink" title="数据库中检测一个不存在的trie根节点"></a>数据库中检测一个不存在的trie根节点</h3><p>小编曾说个，以太坊的MPT中，是有google的levelDB参与的，而从trie定义的结构中，我们可知通过trie中的originalRoot可以恢复出一棵levelDB中存在的MPT树。<br>这个案例中，我们尝试使用一个不存在的hash来判断level中的确不存在该对应的MTP树。代码如下：<br><code>ps：小编需要说明，其中涉及的levelDB以及代码中的db操作相关，属于以太坊的ethdb模块中的内容，这个将在后续的文章中讲解，本文只一笔概述不会深入去讲db内容。</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMissingRoot</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	diskdb, _ := ethdb.NewMemDatabase()</span><br><span class="line">	<span class="comment">//New()中，第一个参数是将hex编码转为原始的hash 32位byte[]</span></span><br><span class="line">	trie, err := New(common.HexToHash(<span class="string">&quot;0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33&quot;</span>), NewDatabase(diskdb))</span><br><span class="line">	<span class="keyword">if</span> trie != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(<span class="string">&quot;New returned non-nil trie for invalid root&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := err.(*MissingNodeError); !ok &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;New returned wrong error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们可知，我们是要从一个新建的db中去找某hash对应的trie树。呵呵，当然会找不到。但程序具体是怎么执行查找的？需要我们进入New()方法去进一步了解过程：<br>传入的root是一个hash，根据该hash最后是在db中查找对应的trie根的。<br>其中<code>originalRoot: root, </code>，若最终查找出了该trie，则该root就是整个trie的hash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db:           db,</span><br><span class="line">		originalRoot: root,  <span class="comment">//把传入的hash保存在此处，只要能恢复了整个trie</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root != common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>) <span class="comment">//检查是否有对应的trie</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode  <span class="comment">//返回了找到的trie，按小编理解，这个rootnode应该是分支节点或叶子节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，真正进行node查找的方法是resolveHash()该方法也需要大家了解一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">resolveHash</span><span class="params">(n hashNode, prefix []<span class="keyword">byte</span>)</span> <span class="params">(node, error)</span></span> &#123;</span><br><span class="line">	cacheMissCounter.Inc(<span class="number">1</span>)  <span class="comment">//每执行一次resolveHash()方法，计数器+1</span></span><br><span class="line"></span><br><span class="line">	hash := common.BytesToHash(n)</span><br><span class="line">	enc, err := t.db.Node(hash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || enc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;MissingNodeError&#123;NodeHash: hash, Path: prefix&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mustDecodeNode(n, enc, t.cachegen), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的是那个计数器，<code>cacheMissCounter.Inc(1)</code>，不论从db中还原trie成功还是失败，计数器都会累加1</p>
<h3 id="操作存储在内存或磁盘的trie"><a href="#操作存储在内存或磁盘的trie" class="headerlink" title="操作存储在内存或磁盘的trie"></a>操作存储在内存或磁盘的trie</h3><p>db中只会存放最终真正确认有效的数据块，因此trie会被分为存在db磁盘中的以及留在内存中的两大类，具体可以看测试代码，（期间会涉及到部分非重点代码，小编就不列出了）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMissingNode</span><span class="params">(t *testing.T, memonly <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	diskdb, _ := ethdb.NewMemDatabase()  <span class="comment">//磁盘空间</span></span><br><span class="line">	triedb := NewDatabase(diskdb)  <span class="comment">//生成db</span></span><br><span class="line"></span><br><span class="line">	trie, _ := New(common.Hash&#123;&#125;, triedb) <span class="comment">//空节点创建</span></span><br><span class="line">	<span class="comment">//实际使用时，Update中的 value是需要先经过rlp编码</span></span><br><span class="line">	trie.Update([]<span class="keyword">byte</span>(<span class="string">&quot;120000&quot;</span>), []<span class="keyword">byte</span>(<span class="string">&quot;qwerqwerqwerqwerqwerqwerqwerqwer&quot;</span>))</span><br><span class="line">	trie.Update([]<span class="keyword">byte</span>(<span class="string">&quot;123456&quot;</span>), []<span class="keyword">byte</span>(<span class="string">&quot;asdfasdfasdfasdfasdfasdfasdfasdf&quot;</span>))</span><br><span class="line">	root, _ := trie.Commit(<span class="literal">nil</span>)  <span class="comment">//trie.Commit需要了解</span></span><br><span class="line">	<span class="keyword">if</span> !memonly &#123;  <span class="comment">//根据此处来判断是否提交到db</span></span><br><span class="line">		triedb.Commit(root, <span class="literal">true</span>)  <span class="comment">//这个就是将trie提交到db了</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据key查找某个trie是否存在</span></span><br><span class="line">	<span class="keyword">var</span> bts []<span class="keyword">byte</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	bts, err := trie.TryGet([]<span class="keyword">byte</span>(<span class="string">&quot;120000&quot;</span>))</span><br><span class="line">	fmt.Println(bts)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加一个node</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	<span class="comment">//本质上也是调用trie.Update()方法</span></span><br><span class="line">	err = trie.TryUpdate([]<span class="keyword">byte</span>(<span class="string">&quot;120099&quot;</span>), []<span class="keyword">byte</span>(<span class="string">&quot;zxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcv&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除一个node</span></span><br><span class="line">	trie, _ = New(root, triedb)</span><br><span class="line">	err = trie.TryDelete([]<span class="keyword">byte</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">	</span><br><span class="line">	hash := common.HexToHash(<span class="string">&quot;0xe1d943cc8f061a0c0b98162830b970395ac9315654824bf21b73b891365262f9&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> memonly &#123; <span class="comment">//为true，则在内存中删除该trie</span></span><br><span class="line">		<span class="built_in">delete</span>(triedb.nodes, hash)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">//为false，则在磁盘中删除该trie</span></span><br><span class="line">		diskdb.Delete(hash[:])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现，trie中存这样的几对方法：Update()和TryUpdate()、Get()和TryGet()、Delete()和TryDelete()；其实是没有加<code>Try</code>关键字的方法进一步封装了带有<code>Try</code>的方法，做了异常处理。另外：</p>
<ul>
<li>TryUpdate()方法：当传入的value长度大于0，则调用trie.insert()把把key和value组成节点插入trie（插入逻辑后续再说）；否则若value长度为0，则调用trie.delete()方法删除trie中key对应的节点。</li>
<li>TryGet()方法：就是从trie中调用tryGet()方法获取key对应的那一部分数据</li>
<li>TryDelete()方法：就是调用trie中delete()方法删除trie中key对应的节点。</li>
<li>triedb.Commit()方法：将数据提交给db，这个涉及到trie模块下的database.go，后面章节中单独讲</li>
<li>diskdb.Delete()方法：磁盘中删除某节点，这个属于<code>diskdb模块</code>内容，本文不讲解。</li>
</ul>
<p>节点的操作本身很重要，我们知道了，真正处理数据的是trie中的insert()、delete()、tryGet()这三个方法。接下来详细介绍一下它们。<br>先要知道，这些操作的数据目前都是在内存中保存的。<br>下面操作中，除了明确标明是在操作db，其余情况都是在内存中操作，这点一定要清楚，很容易搞混。</p>
<p><code>注意！小编多个新号让大家注意：****</code><br><em>只要trie树上的某条路径上有节点新增或者删除，那这条路径的节点都会被重新实例化并负值，如此一来，节点的nodeFlag中的dirty也被改为true，这样就表示这条路径的所有节点都需要重新插入到db。</em></p>
<h4 id="新增数据到trie"><a href="#新增数据到trie" class="headerlink" title="新增数据到trie"></a>新增数据到trie</h4><p>其实就是新增一个叶子节点到trie<br>前面提到过的一些文章中只是理论上讲了讲新增原理，真实情况要复杂很多。<br><span id="insert">先来上一坨代码，看看以太坊是怎么处理新增的：</span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法会被递归调用</span></span><br><span class="line"><span class="comment">//n表示从trie当前节点n开始插入</span></span><br><span class="line"><span class="comment">//prefix表示当前匹配到的key的公共前缀</span></span><br><span class="line"><span class="comment">//key 表示待插入数据当前key中剩余未匹配的部分</span></span><br><span class="line"><span class="comment">//value 待插入数据本身</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">insert</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>, value node)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123; </span><br><span class="line">		<span class="keyword">if</span> v, ok := n.(valueNode); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> !bytes.Equal(v, value.(valueNode)), value, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="comment">//要在节点A中新增节点B，若A和B本身数据一致，则认为已经新增，则直接返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, value, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		matchlen := prefixLen(key, n.Key) <span class="comment">//n.Key是扩展节点的公共key，这是公共结点匹配</span></span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123; </span><br><span class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</span><br><span class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">			&#125;<span class="comment">//新增返回的必是叶子结点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span> <span class="comment">//从这里可以看出，从根路径到插入数据的位置，整条路径的节点都会被重新实例化，node的dirty也被改为true，表示要重新更新</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//该case中，剩余部分代码，是为了将一个扩展节点拆分为两部分</span></span><br><span class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125; <span class="comment">//新建一个分支节点</span></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="comment">//插入分支节点第一个数据</span></span><br><span class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入分支节点第二个数据</span></span><br><span class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若待插入数据和trie中当前节点的前缀key一个也没匹配，则返回分支节点</span></span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则返回扩展节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *fullNode: <span class="comment">//分支节点插入数据</span></span><br><span class="line">		dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">		n = n.<span class="built_in">copy</span>()</span><br><span class="line">		n.flags = t.newFlag()</span><br><span class="line">		n.Children[key[<span class="number">0</span>]] = nn</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//也就是说，在空trie中添加一个节点，就是叶子节点，返回shortNode。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//恢复一个存储在db中的node</span></span><br><span class="line">		rn, err := t.resolveHash(n, prefix)  <span class="comment">//检查该node是否存在，若存在，加载在node中</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, n, n))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出：</p>
<ul>
<li>此时，只有key被编码为hex编码，而value是经过rlp编码的字节数组。</li>
<li>insert()最终返回的node其实就是trie.root所指向的node。</li>
<li>若trie中本身是存在key所对应的数据的，则不可被修改。也就是会说，trie本身只可增加节点，不可修改节点</li>
<li>若节点<code>n</code>指向的是<code>nil</code>，则当前是空trie，直接在其后加一个shortNode(叶子节点)即可。</li>
<li>若节点<code>n</code>指向的是<code>shortNode</code>，则该<code>shortNode</code>可能是扩展节点，也可能是叶子节点。<ul>
<li>若待插入的key剩余未匹配的部分能匹配到当前<code>shortNode</code>中key的全部长度，则在该<code>shortNode</code>之后新增分支节点，或者在<code>shortNode</code>之后的分支节点上新增待插入节点。</li>
<li>若待插入的key剩余未匹配的部分不能匹配到当前<code>shortNode</code>中key的全部长度，则该<code>shortNode</code>会新增一个分支节点，将shortNode分裂成两部分。这块建议大家画图理解。</li>
</ul>
</li>
<li>若节点<code>n</code>指向的是分支节点<code>fullNode</code>，理解了上面指向<code>shortNode</code>的过程，那这里就容易理解了，从分支节点下进一步查找要匹配的位置</li>
<li>若节点<code>n</code>指向的是<code>hashNode</code>，说明此时该节点属于轻节点，真实的节点数据被释放了。因此，通过hashNode去db中恢复该节点，然后进一步去插入。</li>
</ul>
<h4 id="从trie中获取数据"><a href="#从trie中获取数据" class="headerlink" title="从trie中获取数据"></a>从trie中获取数据</h4><p>其实就是根据输入到hash，在找到对应的叶子节点的数据，一言不合，先来代码，一坨。。。：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//origNode：当前查找的起始node位置</span></span><br><span class="line"><span class="comment">//key：输入要查找的数据的hash</span></span><br><span class="line"><span class="comment">//pos：当前hash匹配到第几位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">tryGet</span><span class="params">(origNode node, key []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, newnode node, didResolve <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//这表示当前trie是空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> valueNode: <span class="comment">//这就是我们要查找的叶子节点对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> *shortNode: <span class="comment">//在叶子节点或者扩展节点匹配</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Val = newnode</span><br><span class="line">			n.flags.gen = t.cachegen</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> *fullNode:  <span class="comment">//在分支节点匹配</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.flags.gen = t.cachegen</span><br><span class="line">			n.Children[key[pos]] = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//说明当前节点是轻节点，需要从db中获取</span></span><br><span class="line">		child, err := t.resolveHash(n, key[:pos])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err  <span class="comment">//trie重组，因此需要返回true</span></span><br><span class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</span><br><span class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, origNode, origNode))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不说别的，先说<code>didResolve</code>这个东西，用于判断trie树是否会发生变化，按理tryGet()只是用来获取数据的，哪里会影响trie发生变化，但是因为有可能我们会根据hashNode去db中获取该node值，获取到后，需要更新现有的trie，<code>didResolve</code>就会发生变化。<br>其实这段查询代码里，也就只有<code>didResolve</code>会让人郁闷一下，其它的就只是基本的递归查找树了。小编就不详解了，代码里注释大概写了点，够用了。<br>补充一下，当涉及到hashNode时，我们要知道，这是通过外部输入hashNode，进磁盘DB中查找对应节点。</p>
<h4 id="从trie中删除数据"><a href="#从trie中删除数据" class="headerlink" title="从trie中删除数据"></a>从trie中删除数据</h4><p>也就是说删除trie中的一个叶子节点。这个过程和插入过程很相似，小编就不讲了，再讲就累死了。</p>
<h3 id="节点缓存设置"><a href="#节点缓存设置" class="headerlink" title="节点缓存设置"></a>节点缓存设置</h3><p>当一个节点被提交次数达到指定上线时候，该节点将会被重新加载。<br>这个功能还是蛮有用的，提高效率。这个代码没细看，有兴趣的可以看看。<br>在<code>test_trie.go</code>中看<code>TestCacheUnload()</code>测试方法，在<code>trie.go</code>中看trie.SetCacheLimit()方法<br>话说这个缓存机制小编一直没看懂。。。</p>
<h2 id="Trie树的序列化、缓存-轻节点"><a href="#Trie树的序列化、缓存-轻节点" class="headerlink" title="Trie树的序列化、缓存(轻节点)"></a>Trie树的序列化、缓存(轻节点)</h2><p>小编相信，看懂<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC2%E8%AE%B2-rlp%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html">以太坊源码解读-第2讲-rlp模块源码解读</a>的同学，会很容易理解trie树的序列化的 。<br>序列化和反序列化，本就是内存和磁盘存储时候的两种转化，具体概念小编就不讲了。<br>当trie.Commit(nil)的时候，会执行序列化、缓存等操作，因此小编就将这两者合在一起讲了<br>需要注意的是，trie树序列化后，真正保存在磁盘上，是使用的<code>Compact Encoding</code>编码，这样会节省空间。<br>还有一点需要分清：<code>node本身节点的hash和shortNode中的key要区分，从根结点到叶子节点的key衔接起来，表示的是叶子节点value数据的hash值</code><br>关于trie的缓存机制，其实就是轻节点机制的设计理念，后面小编在代码中深入介绍吧。</p>
<h3 id="trie-Commit-nil-入口解析"><a href="#trie-Commit-nil-入口解析" class="headerlink" title="trie.Commit(nil)入口解析"></a>trie.Commit(nil)入口解析</h3><p>Commit()的目的，是将trie树中的key转为Compact编码，为每个节点生成一个hash。<br>可以这么说，它就是为了确保后续能正常将变动的数据提交到db.<br>来看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Commit</span><span class="params">(onleaf LeafCallback)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> </span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;commit called on trie with nil database&quot;</span>)</span><br><span class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)  </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">	t.root = cached</span><br><span class="line">	t.cachegen++</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span>  <span class="comment">//返回trie.root所指向的节点的hash，注意该hash是原始的32位hash，并未编码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为每个node生成一个hash</span></span><br><span class="line"><span class="comment">//返回的结果中，有两个node，后面文中详细解释</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">hashRoot</span><span class="params">(db *Database, onleaf LeafCallback)</span> <span class="params">(node, node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	h := newHasher(t.cachegen, t.cachelimit, onleaf) <span class="comment">//涉及到haser.go，后面解释</span></span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</span><br><span class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>)  <span class="comment">//为每个节点生成一个未编码的hash，该方法后面具体会详解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们了解到：</p>
<ul>
<li>每Commit()一次，该trie的cachegen就会加1</li>
<li>最终Commit()方法返回的是trie.root所指向的node的hash（未编码）。</li>
<li>其中的hashRoot()方法目的是<code>返回trie.root所指向的node的hash</code>以及<code>每个节点都带有各自hash的trie树的root</code>。</li>
<li>期间会涉及到hasher.go中的操作，它维护着一个操作trie中hash相关的对象池，我们也发现，在hashRoot()中最重要的就是它的hash()方法，接下来我们就好好探索一下它的具体实现。</li>
</ul>
<h3 id="haser-go的hash-方法"><a href="#haser-go的hash-方法" class="headerlink" title="haser.go的hash()方法"></a>haser.go的hash()方法</h3><p>这个方法主要就是为每个节点都生成一个hash，<br><span id="hash">来一坨代码：</span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hash</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> </span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> n.canUnload(h.cachegen, h.cachelimit) &#123;</span><br><span class="line">			cacheUnloadCounter.Inc(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dirty </span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	collapsed, cached, err := h.hashChildren(n, db) <span class="comment">//处理每个节点</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</span><br><span class="line">	hashed, err := h.store(collapsed, db, force) <span class="comment">//将当前节点生成hash，这方法很重要，下一节讲</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">return</span> hashNode&#123;&#125;, n, err</span><br><span class="line"></span><br><span class="line">	cachedHash, _ := hashed.(hashNode)</span><br><span class="line">	<span class="keyword">switch</span> cn := cached.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		cn.flags.hash = cachedHash <span class="comment">//将当前节点的hasn保存在flags中</span></span><br><span class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> </span><br><span class="line">			cn.flags.dirty = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">case</span> *fullNode:  <span class="comment">//和上面一样操作</span></span><br><span class="line">		cn.flags.hash = cachedHash</span><br><span class="line">		<span class="keyword">if</span> db != <span class="literal">nil</span> </span><br><span class="line">			cn.flags.dirty = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hashed, cached, <span class="literal">nil</span>  <span class="comment">//返回当前节点的hash以及当前节点本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次处理trie中的每个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">hashChildren</span><span class="params">(original node, db *Database)</span> <span class="params">(node, node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">switch</span> n := original.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *shortNode:</span><br><span class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()  <span class="comment">//递归算下来，相当于复制了两个新的trie</span></span><br><span class="line">		collapsed.Key = hexToCompact(n.Key) <span class="comment">//将前缀hex转为compact，方便磁盘存储</span></span><br><span class="line">		cached.Key = common.CopyBytes(n.Key) <span class="comment">//将key字节数组复制给cached</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</span><br><span class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">				<span class="keyword">return</span> original, original, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> collapsed.Val == <span class="literal">nil</span> </span><br><span class="line">			collapsed.Val = valueNode(<span class="literal">nil</span>) <span class="comment">//确保不为nil</span></span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span>  <span class="comment">//前者是用于磁盘存储的节点，后者是hash化的节点，可以称为轻节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *fullNode:</span><br><span class="line">		collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123; <span class="comment">//类似，处理每个节点</span></span><br><span class="line">				collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> </span><br><span class="line">					<span class="keyword">return</span> original, original, err</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				collapsed.Children[i] = valueNode(<span class="literal">nil</span>) <span class="comment">//确保不会出现nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</span><br><span class="line">		<span class="keyword">if</span> collapsed.Children[<span class="number">16</span>] == <span class="literal">nil</span> </span><br><span class="line">			collapsed.Children[<span class="number">16</span>] = valueNode(<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> n, original, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纠结了半天，小编觉得也没什么注释可以写的。具体的这里来解释吧：</p>
<ul>
<li>hash()方法很重要，最终它返回了头节点的hash以及每个子节点都带有hash的头节点。（头节点就是为了让trie.root最终指向它）<br>它主要完成了3个任务：<ul>
<li>缓存管理，检测是否要释放某节点</li>
<li>递归调用hashChildren()处理每个节点，它返回的是两个node，具体看下面的解释。</li>
<li>调用store()方法生成每个节点的hash，并保存在当前节点中，store()方法很重要，我们下一节单独讲</li>
</ul>
</li>
<li>hashChildren()方法主要就是为了处理树中的每个节点，比如：将shortNode的前缀key转为Compact编码，将nil数据处理一下。小编认为这个方法真正最主要的目的就是将当前所在节点复制了两份（分别叫做<code>collapsed</code>, <code>cached</code>），这样此时加上原先传入的总共就有3份当前节点数据了。复制的两份，其中一份<code>collapsed</code>是为了将来db磁盘存储；而另一份<code>cached</code>会保留在内存中，回调结束后trie.root会指向这个cached，这样，原先的那一份就会被gc了（trie.root原先是指向这一份），</li>
</ul>
<h3 id="haser-go的store-方法（涉及缓存）"><a href="#haser-go的store-方法（涉及缓存）" class="headerlink" title="haser.go的store()方法（涉及缓存）"></a>haser.go的store()方法（涉及缓存）</h3><p>我们上面提到了hashChildren()返回的是两个node，其中一个叫做<code>collapsed</code>的当前node被传入了store()方法中，而它只返回了一个当前node的hash。<br>前面我们已经知道<code>collapsed</code>节点做了部分处理，它最终目的是保存在db磁盘的。当它的节点本身被rlp序列化，就可以直接传入db保存了。<br>store()方法就是用来rlp序列化<code>collapsed</code>节点并将其插入db磁盘中，当前节点的hash也是由它来生成的。<br>具体我们来看这样一坨代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span> <span class="title">store</span><span class="params">(n node, db *Database, force <span class="keyword">bool</span>)</span> <span class="params">(node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash <span class="comment">//空数据或者hashNode，则不处理</span></span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">	h.tmp.Reset() <span class="comment">//缓存初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := rlp.Encode(h.tmp, n); err != <span class="literal">nil</span> <span class="comment">//将当前node序列化</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;encode error: &quot;</span> + err.Error())</span><br><span class="line">	<span class="keyword">if</span> h.tmp.Len() &lt; <span class="number">32</span> &amp;&amp; !force </span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">//编码后的node长度小于32，若force为true，则可确保所有节点都被编码</span></span><br><span class="line">	<span class="comment">// 长度过大的，则都将被新计算出来的hash取代</span></span><br><span class="line">	hash, _ := n.cache()  <span class="comment">//取出当前节点的hash</span></span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;  <span class="comment">//如果hash</span></span><br><span class="line">		h.sha.Reset()</span><br><span class="line">		h.sha.Write(h.tmp.Bytes())  <span class="comment">//将rlp编码的节点数据传入hash工具</span></span><br><span class="line">		hash = hashNode(h.sha.Sum(<span class="literal">nil</span>))  <span class="comment">//根据传入的节点信息，生成hash</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</span><br><span class="line">		db.lock.Lock()</span><br><span class="line"></span><br><span class="line">		hash := common.BytesToHash(hash)</span><br><span class="line">		db.insert(hash, h.tmp.Bytes()) <span class="comment">//将其插入db</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *shortNode:</span><br><span class="line">			<span class="keyword">if</span> child, ok := n.Val.(hashNode); ok <span class="comment">//指向的是分支节点</span></span><br><span class="line">				db.reference(common.BytesToHash(child), hash) <span class="comment">//用于统计当前节点的信息，比如当前节点有几个子节点，当前有效的节点数</span></span><br><span class="line">		<span class="keyword">case</span> *fullNode:</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Children[i].(hashNode); ok </span><br><span class="line">					db.reference(common.BytesToHash(child), hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123; <span class="comment">//onleaf是回调时候使用的，记得trie.Commit(x)里的那个参数吧，就是它</span></span><br><span class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *shortNode:</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok </span><br><span class="line">					h.onleaf(child, hash)</span><br><span class="line">			<span class="keyword">case</span> *fullNode:</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ </span><br><span class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</span><br><span class="line">						h.onleaf(child, hash)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中重要的一点就是hash的生成，它是根据序列化后的节点生成的。<br>注意看db的插入，根据hash来插入rlp序列化的节点，到时候我们就能根据这个hash来还愿整个节点了。而要注意的一点是<code>该hash是32位的原始hash，并未经过任何编码，最终该方法返回的hash也没有经过任何处理</code><br>另外stroe()方法传入的有个参数叫force，通过代码我们得知，如果设置为true，则即使长度再小的节点，也要进行rlp编码<br>剩下的代码，小编发现没什么要讲的。。。代码不复杂，写的都很清楚，能注释的也都注释了，</p>
<h3 id="缓存机制（轻节点）"><a href="#缓存机制（轻节点）" class="headerlink" title="缓存机制（轻节点）"></a>缓存机制（轻节点）</h3><p>讲了半天，就剩缓存没讲了，再次回到haser.go的hash()方法，这时候再来看这个缓存机制就很容易理解了。<br><a href="#hash">代码看这里</a><br>还记得Trie树的结构里面有两个参数， 一个是cachegen,一个是cachelimit。这两个参数就是cache控制的参数。 Trie树每一次调用Commit方法，会导致当前的cachegen增加1。<br>数据节点插入时候（<a href="#insert">代码看这里</a>），会把当前trie的cachegen存放到该节点中。<br>要知道，只要trie路径上新增或者删除一个节点，整个路径的节点都需要重新实例化，也就是节点中的nodeFlag被初始化了。都需要重新更新到db磁盘。<br>node.go源码中有针对每种node实现的<code>canUnload()</code>方法，大体上是当<code>trie.cachegen - node.cachegen &gt; cachelimit</code>和<code>dirty=false（表示当前节点未发生变化）</code>条件满足时就会返回true（说明该节点数据始终没有发生变化，自己好好悟悟这句话吧，最好拿数据实际操作一下）,此时hash()方法中，就不会返回节点数据，而是返回节点的一个hash值。</p>
<h4 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h4><p>小编在<a href="/articles/original/ethereum/src_analysis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC3.1%E8%AE%B2-trie%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.html">以太坊源码解读-第3.1讲-trie原理介绍</a>中已经初步介绍了轻节点的概念，根据上述缓存机制，我们返回的只有hash节点本身。这其实就是我们所说的轻节点。。。貌似小编没有什么需要继续往下说的了。。。一路看下来这篇文章的同学，应该会很容易理解这个吧。</p>
<h2 id="proof-go-源码"><a href="#proof-go-源码" class="headerlink" title="proof.go 源码"></a>proof.go 源码</h2><p>看了下，总共有三个方法：</p>
<ul>
<li>Prove()：根据给定的key，在trie中，将满足key中最大长度前缀的路径上的节点都加入到proofDb（队列中每个元素满足：未编码的hash以及对应rlp编码后的节点）</li>
<li>VerifyProof()：验证proffDb中是否存在满足输入的hash，和对应key的节点，如果满足，则返回rlp解码后的该节点。</li>
</ul>
<p>具体代码小编就不列了，也不复杂，有兴趣的可以看看</p>
<h2 id="database-go源码"><a href="#database-go源码" class="headerlink" title="database.go源码"></a>database.go源码</h2><p>它对ethdb做了进一步封装，方便trie中节点的插入删除操作，具体代码小编等下一次讲ethdb.go的时候再来解释。现在就不说了。</p>
<h2 id="iterator-go源码"><a href="#iterator-go源码" class="headerlink" title="iterator.go源码"></a>iterator.go源码</h2><p>以太坊提供的对trie树的遍历工具，有兴趣的看看，这里也不解释了，小编也懒得看了。</p>
<h2 id="security-trie-go源码"><a href="#security-trie-go源码" class="headerlink" title="security_trie.go源码"></a>security_trie.go源码</h2><p>这个可以理解为加密了的trie的实现，ecurity_trie包装了一下trie树， 所有的key都转换成keccak256算法计算的hash值。同时在数据库里面存储hash值对应的原始的key。<br>但是官方在代码里也注释了，这个代码不稳定，除了测试用例，别的地方并没有使用该代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有几个trie模块下的代码文件，小逼没有提到，不是说不重要，只是小编的精力主要集中在trie的整体逻辑。关于trie，写了两篇文章，写了将近半个月，涉及的比较多，有些地方写的不一定合理，大家可以留言指出。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第3.1讲-trie原理介绍</title>
    <url>/articles/636a5647/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解以太坊的同学都知道，以太坊中有三大重要的状态：<code>账户状态</code>、<code>交易状态</code>、<code>收据状态</code>（不要问小编它们有什么用-_-）。这三大状态怎么保存，怎样保证这些信息的安全？这就离不开我们这次要讲的以太坊<code>trie</code>模块了。</p>
<a id="more"></a>
<p>它提供了一种强大的数据结构<code>Merkle Patricia Tries</code>，我们亲切的称它为<code>MPT</code>。正是它维护着我们的这三种状态，让整个以太坊平稳有序的进行着。<br>看到这么强大的东西，是不是经不起诱惑了？那我们就快来解刨吧。</p>
<p>这篇文章主要是讲阅读trie模块源码前要掌握<code>编码</code>以及<code>节点原理</code>，具体源码的解析请看小编的另一篇文章：<a href="/articles/dcade07d">以太坊源码解读-第3.2讲-trie模块源码解读</a></p>
<h2 id="MPT的前世今生"><a href="#MPT的前世今生" class="headerlink" title="MPT的前世今生"></a>MPT的前世今生</h2><ul>
<li>MPT是这三种结构的组合：Trie，Patricia Trie，Merkle tree。每一种都非常经典，为了更好的了解以太坊，小编专门整理了三篇文章，值得一读（依次从上往下读）：<br>  <a href="/articles/5f802b92"><code>浅谈标准Trie树（字典树）</code></a><br>  <a href="/articles/12370dbd"><code>Patricia树介绍</code></a><br>  <a href="/articles/b3334ff6"><code>Merkle Tree（默克尔树）算法解析</code></a><br>  正是这三种树的进一步柔和，才有了今天以太坊上大名鼎鼎的MPT。</li>
<li>MPT是什么，它相比上面有什么优势？建议大家看看小编整理的这篇文章：<br>  <a href="/articles/f54d9616"><code>Merkle Patricia Tree (MPT) 以太坊merkle技术分析</code></a></li>
</ul>
<p>注意，上面这篇文章只是宏观上的介绍，MPT也只是大概讲讲是什么样的逻辑，能有个大概映像。具体细节，小编后面再详细介绍。</p>
<h2 id="MPT中的编码概念"><a href="#MPT中的编码概念" class="headerlink" title="MPT中的编码概念"></a>MPT中的编码概念</h2><p>MPT中会涉及到三种编码：<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>，每种编码在特定场合都有其重要的作用，小编曾尝试通过网络中的相关文章来了解这些编码是怎么生成的，但无奈啊，这些文章一个比一个写的复杂，一堆数学公式和专业术语，越看越看不懂。。。<br>终于，小编还是看完源码后，弯回来，自己来解释下这三种编码具体是怎么实现的。毕竟，了解了这些基础后，再看源码就会容易很多。吸取以前看的文章的不足之处，这次小编一定讲的通俗易懂：</p>
<h3 id="KEYBYTES-encoding"><a href="#KEYBYTES-encoding" class="headerlink" title="KEYBYTES encoding"></a>KEYBYTES encoding</h3><p>这就是原生的字节，没有添加任何防腐剂：go语言中的<code>byte</code>,长度为8，范围是0～255。二进制表示的话，就是<code>00000000~11111111</code>。<br>也就是说，一串普通数据通过<code>KEYBYTES encoding</code>编码后，就是由<code>很多byte</code>组成的一个<code>byte[]</code>数组，也就是我么说的字节数组。<br>这个编码搞开发的应该都懂，不难理解。</p>
<h3 id="HEX-encoding"><a href="#HEX-encoding" class="headerlink" title="HEX encoding"></a>HEX encoding</h3><p>我想，把它称为半字节编码(<code>nibble</code>)更好一些，具体细节一会儿讲。<br>在内存中，这种编码访问会更容易，不要问为什么，小编也不知道。。。涉及到硬件效率相关，貌似是因为16进制更容易计算。<br>具体这种编码是怎么实现的？这块小编重点讲讲。<br>用<code>KEYBYTES encoding</code>编码（上面有讲，就是go中普通的byte）转为<code>hex</code>编码的过程来演示，大家可能会更容易理解，先看代码演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申明一个byte数据t，值为249，这个t可以理解为就是`KEYBYTES encoding`编码数据</span></span><br><span class="line"><span class="comment">//它将会被转为`hex`编码</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">byte</span> = <span class="number">249</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便演示这里加一个l变量，表示t的长度为1，也就是总共一个字节</span></span><br><span class="line"><span class="keyword">var</span> l = <span class="number">1</span>  </span><br><span class="line"><span class="comment">//hex编码t总共会用到的空间大小</span></span><br><span class="line">l := <span class="number">2</span>*l + <span class="number">1</span>  </span><br><span class="line"><span class="comment">//开辟l大小的空间，传说中的nibbles</span></span><br><span class="line"><span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)  </span><br><span class="line"><span class="comment">//将s的高4位存入nibbles的第一个字节</span></span><br><span class="line">nibbles[<span class="number">0</span>] = s / <span class="number">16</span></span><br><span class="line"><span class="comment">//将s的低4位存入nibbles的第二个字节</span></span><br><span class="line">nibbles[<span class="number">1</span>] = s % <span class="number">16</span></span><br><span class="line"><span class="comment">//nibbles的最后一位存入标示符，代表这个是hex编码</span></span><br><span class="line">nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">fmt.Println(nibbles)</span><br></pre></td></tr></table></figure>
<p>最后输出编码为hex的结果nibbles：<br>    <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">15</span> <span class="number">9</span> <span class="number">16</span>]  <span class="comment">//原先数据的高4位保存位15，低4位保存位9，16表示该hex编码是通过KEYBYTES编码转换的</span></span><br></pre></td></tr></table></figure><br>代码里有些地方是不是还很懵逼？小编来解释一下：</p>
<ul>
<li><p>hex编码的目的是：<br>要将一个原始字节数组byte[]，其中的每个byte都拆分位高4位和低4位，分别放在同为字节数组的nibbles[]中（<code>bibbles的数组长度为原始字节数组的2倍再加1</code>）。其中依次高4位放在nibbles[]的偶数位，低4位放在nibbles[]的奇数位，最后一位设置为16（二进制表示<code>00010000</code>），表示这个hex编码是通过<code>KEYBYTES</code>编码转换的。</p>
</li>
<li><p>还不懂？小编继续换种方式解释：</p>
<ul>
<li>先记住：<code>一个byte的长度为8，范围是0～255。二进制表示的话，就是：00000000~11111111</code>。</li>
<li>要将byte值为<code>249</code>的数据转为hex编码，首先将<code>249</code>转为二进制表示：<code>11111001</code>，看清楚，高4位是1111，低4位是1001</li>
<li>249除以16得到的值为15，15的二进制表示是：1111，看清楚了吗？这就是249的高4位，</li>
<li>249除以16得到的余数为9，9的二进制表示是：1001，看清楚了吗？这就是249的低4位，</li>
<li><code>249</code>的长度为l=1，因此nibbles[]字节数组的长度为2*l+1=3，就是说，hex编码需要用3个byte才能表示了原来的<code>249</code>，nibbles的偶数位nibbles[0]存入<code>249</code>的高4位<code>00001111</code>，nibbles的奇数位nibbles[1]的低4位存入<code>249</code>的低4位<code>00001001</code>,最后一位nibbles[2]存入16（也就是二进制<code>00010000</code>）,发现了吗？hex中的每一个byte都表示一个16进制数。</li>
<li>因此<code>249</code>最终hex编码结果为：[<code>00001111</code>,<code>00001001</code>,<code>00010000</code>]，也就是[15 9 16]</li>
<li>这下该懂了吧，再不懂就只能弯回去再读几遍了。。小编自认为对这个hex编码的解释算是很仔细啦。。</li>
</ul>
</li>
<li><p>小编还要补充的重要内容是，很重要，否则很难理解<code>COMPACT encoding</code>编码：</p>
<ul>
<li><p><code>KEYBYTES encoding</code>编码的数据转成<code>HEX encoding</code>的编码的数据后，该byte[]最后一个是一定有后缀的，值为<code>16</code>，并且除去后缀后，剩余的编码长度为偶数。具体看上面的解释。</p>
</li>
<li><p>hex中两个连续byte表示原始数据的一个byte。</p>
</li>
<li><p>但是小编从以太坊源码中了解到，hex字节数组如果不是经过<code>KEYBYTES encoding</code>编码得到的，可能会有<code>前缀</code>(姑且这么称呼)这么一个东西，具体生成的hex结果会分为如下几种情况：</p>
<ol>
<li>hex字节数组长度为奇数，最后一个是后缀，标记为16，此时无前缀这。种就是前面所讲的经过<code>KEYBYTES encoding</code>编码得到的。</li>
<li>hex字节数组长度为奇数，最后一个不是后缀，此时会认为hex字节数组的第一个是其的前缀。</li>
<li>hex字节数组长度为偶数，最后一个是后缀，此时hex字节数组的第一个一定是其前缀。</li>
<li>hex字节数组长度为偶数，最后一个不是后缀，并且无前缀</li>
</ol>
<p><code>ps:</code>截止目前为止，小编依旧不知道hex的这个前缀是怎么生成的，为什么要有。。。如果有哪个小伙伴了解，可以留言分享一下。</p>
</li>
</ul>
</li>
</ul>
<h3 id="COMPACT-encoding"><a href="#COMPACT-encoding" class="headerlink" title="COMPACT encoding"></a>COMPACT encoding</h3><p>这种编码也就是黄皮书里讲的<code>Hex-Prefix Encoding</code>编码，可以看作是<code>HEX encoding</code>编码的另一种形式，在磁盘存储数据的时候，会节省磁盘空间。<br>既然都说了它是<code>HEX encoding</code>编码的另一种形式，也就是说，<code>COMPACT encoding</code>是通过<code>HEX encoding</code>转换实现的，转换后，会节省将近一半的磁盘空间。<br>思前想后，换了N种方式，最终小编认为，还是得先通过数学公式来理解什么是<code>COMPACT encoding</code>编码。</p>
<h4 id="数学公式定义"><a href="#数学公式定义" class="headerlink" title="数学公式定义"></a>数学公式定义</h4><p>这是黄皮书中给出的公式，耐心看，不复杂。<br>$$<br>\begin{split}<br>HP(x,t):x \in \mathbb{Y} &amp;\equiv<br>\begin{cases}<br>&amp;(16f(t),16x[0]+x[1],16x[2]+x[3],…)\ \ \ \ if\ ||x||\ is\ even \<br>&amp;(16(f(t)+1)+x[0],16x[1]+x[2],16x[3]+x[4],…)\ \ \ \ otherwise<br>\end{cases}<br>\<br>f(t) &amp;\equiv<br>\begin{cases}<br>&amp;2\ \ \ \ if\ \ t = 1 \<br>&amp;0\ \ \ \ if\ \ t = 0<br>\end{cases}<br>\end{split}<br>$$<br>解释一下公式的意思：</p>
<ol>
<li>||x||表示求x的长度，在源码中，x表示一个字节数组byte[]，也就是hex编码。</li>
<li>HP(x,t)代表的就是最终<code>COMPACT encoding</code>编码后的结果，其中的<code>t</code>，黄皮书中原本定义的是$t=0和t \neq 0$两种情况，但是结合源码，小编将其改为t=0和t=1这两种情况，这样更容易理解。<br>因为，源码中是这样实现的：<code>当hex有后缀的时候，则t=1，否则t=0</code>。</li>
<li>$\mathbb{Y}$根据hex的长度是<code>偶数(even)</code>还是<code>奇数(odd)</code>，划分为两种集合。每种集合中的第一个数据，代表的是<code>COMPACT encoding</code>编码的前缀，它包含了转换回hex编码所需要的信息。</li>
<li>$\mathbb{Y}$每种集合中的第二个数据开始，你会发现全是<code>16x[i]+x[i+1]</code>这种样式，这在二进制中，其实就是高4位和低4位组成一个byte 8位的过程1。如下图（为了画个像样的图，小编专门学axure。。。）：<img src="/articles/636a5647/1.png" class="" title="16x[i]+x[i+1]过程">

</li>
</ol>
<p><code>COMPACT encoding</code>大体就是这样子，理解了吗？不理解的继续看看后面的代码实现。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>来看一下hex编码是怎样转换为COMPACT编码的（<code>先知道，hex是有前缀的，前面提到过</code>）,要对着上面公式看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试案例，将hex编码&#123;1,2,3,4,5&#125;转换成Compact编码，并输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHexToCompact</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	testBytes := []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Print(hexToCompact(testBytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于hex编码是转换为COMPACT编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	terminator := <span class="keyword">byte</span>(<span class="number">0</span>) <span class="comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span></span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123; <span class="comment">//验证hex有后缀编码，</span></span><br><span class="line">		terminator = <span class="number">1</span>  <span class="comment">//hex编码有后缀，则t=1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]  <span class="comment">//此处只是去掉后缀部分的hex编码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>) </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*f(t)</span></span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> </span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123; <span class="comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span></span><br><span class="line">		<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span></span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> </span><br><span class="line">		<span class="comment">//这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）+ x[0]</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>]  </span><br><span class="line">		hex = hex[<span class="number">1</span>:] <span class="comment">//此时获取的hex编码无前缀无后缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:]) <span class="comment">//将hex编码映射到compact编码中</span></span><br><span class="line">	<span class="keyword">return</span> buf  <span class="comment">//返回compact编码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNibbles</span><span class="params">(nibbles []<span class="keyword">byte</span>, bytes []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> bi, ni := <span class="number">0</span>, <span class="number">0</span>; ni &lt; <span class="built_in">len</span>(nibbles); bi, ni = bi+<span class="number">1</span>, ni+<span class="number">2</span> &#123;</span><br><span class="line">		bytes[bi] = nibbles[ni]&lt;&lt;<span class="number">4</span> | nibbles[ni+<span class="number">1</span>] <span class="comment">//这个过程就是16x[i]+x[i+1]的过程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出的Compact编码结果为：<br>    <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//17为compact前缀</span></span><br><span class="line">[<span class="number">17</span> <span class="number">35</span> <span class="number">69</span>]  </span><br></pre></td></tr></table></figure><br>大伙这下该理解Compact编码是怎么实现的了吧？要还有什么疑问，就请大家留言吧。。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>在以太坊中，<code>KEYBYTES encoding</code>不会直接转位<code>COMPACT encoding</code>，需要先经过<code>HEX encoding</code>。<br>三种编码中，目前以太坊只支持如下转换：</p>
<ul>
<li><code>KEYBYTES encoding</code>转<code>HEX encoding</code></li>
<li><code>HEX encoding</code>转<code>KEYBYTES encoding</code></li>
<li><code>HEX encoding</code>转<code>COMPACT encoding</code></li>
<li><code>COMPACT encoding</code>转<code>HEX encoding</code></li>
</ul>
<h2 id="MPT树的形成原理"><a href="#MPT树的形成原理" class="headerlink" title="MPT树的形成原理"></a>MPT树的形成原理</h2><p>MPT的节点的形成等细节，网上很多文章讲的都很模糊，对于初学者很难理解，小编当初也是半天没看懂，最终还是看了源码后才真正了解是怎么一回事。也因此打算以自己的方式举个例子来好好解释下这些细节。<br>我们假设要将4个交易信息：<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>存储在MPT中，需要经过以下一系列操作。这四个交易信息，假设分别如下：<br><code>A</code>的交易信息内容：i am a<br><code>B</code>的交易信息内容：i am b<br><code>C</code>的交易信息内容：i am c,i am not d<br><code>D</code>的交易信息内容：i am d,i am not c</p>
<h3 id="1-将源数据序列化"><a href="#1-将源数据序列化" class="headerlink" title="1. 将源数据序列化"></a>1. 将源数据序列化</h3><p>为了便于传输，<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>这四个交易信息的数据是需要先使用<a href="articles/reprint/blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%AC%AC2%E8%AE%B2-rlp%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html">rlp</a>进行序列化的，它们经过序列化后分别为如下结果：<br><code>A_Serialize</code>：[134 105 32 97 109 32 <strong>97</strong>]<br><code>B_Serialize</code>：[134 105 32 97 109 32 <strong>98</strong>]<br><code>C_Serialize</code>：[145 105 32 97 109 32 <strong>99</strong> 44 105 32 97 109 32 110 111 116 32 <strong>100</strong>]<br><code>D_Serialize</code>：[145 105 32 97 109 32 <strong>100</strong> 44 105 32 97 109 32 110 111 116 32 <strong>99</strong>]</p>
<h3 id="2-为序列化后的数据源生成hash并将其转为hex编码"><a href="#2-为序列化后的数据源生成hash并将其转为hex编码" class="headerlink" title="2. 为序列化后的数据源生成hash并将其转为hex编码"></a>2. 为序列化后的数据源生成hash并将其转为hex编码</h3><p>在MPT中，其实是在操作经过hex编码的hash(32位)。因此上面序列化后的数据，需要做如下两部分操作：</p>
<ul>
<li>生成hash（均为32位长度）：<br><code>A_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134 105 32 97 109 32 <strong>97</strong>]<br><code>B_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134 105 32 97 109 32 <strong>98</strong>]<br><code>C_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 145 105 32 97 109 32 <strong>99</strong> 44 105 32 97 109 32 110 111 116 32 <strong>100</strong>]<br><code>D_Hash</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 145 105 32 97 109 32 <strong>100</strong> 44 105 32 97 109 32 110 111 116 32 <strong>99</strong>]</li>
<li>对上面这些hash进行hex编码（内存运算效率高），依据hex编码原理，最终结果每个都是65位长度：<br><code>A_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 6 6 9 2 0 6 1 6 13 2 0 6 <strong>1</strong> 16]<br><code>B_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 6 6 9 2 0 6 1 6 13 2 0 6 <strong>2</strong> 16]<br><code>C_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 1 6 9 2 0 6 1 6 13 2 0 6 <strong>3</strong> 2 12 6 9 2 0 6 1 6 13 2 0 6 14 6 15 7 4 2 0 6 <strong>4</strong> 16]<br><code>D_Hex</code>：[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 1 6 9 2 0 6 1 6 13 2 0 6 <strong>4</strong> 2 12 6 9 2 0 6 1 6 13 2 0 6 14 6 15 7 4 2 0 6 <strong>3</strong> 16]</li>
</ul>
<h3 id="3-生成MPT树"><a href="#3-生成MPT树" class="headerlink" title="3. 生成MPT树"></a>3. 生成MPT树</h3><p>前两步准备ok，接下来我们就要生成这颗MPT树了。讲多少遍也不如画一张图，我们先把这颗MPT树画出来，然后再来解释</p>
<img src="/articles/636a5647/2.png" class="" title="MPT树基本结构">
<p>从图中我们可以看出MPT的节点分为四种：<code>根节点</code>、<code>分支节点</code>、<code>扩展节点</code>、<code>叶子节点</code>，下面我们来详细解释一下这些节点的作用：</p>
<ul>
<li>根节点<br>根节点不存有任何信息，是一颗空节点</li>
<li>扩展节点<br>是&lt;K,V&gt;类型的节点，这节点中，K是hash的公共部分，就比如上面的<code>A_Hex</code>、<code>B_Hex</code>、<code>C_Hex</code>和<code>D_Hex</code>它们每个hash值从开始处，<code>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </code>共28个0是公共一致的，因此图中最上面的分支节点key就是这个公共部分;而V则是一个指针，会指向分支节点或者叶子节点。</li>
<li>分支节点<br>这个节点中有17个字段，其中前16个中，分别存有16进制从0～f中的一个字符，而这每一个字符所处区域，又指向hash非公共区域的起始位置，这块靠文字解释很难解释清楚，建议大家直接看图吧。<br>而第17个字段则存储在此处截止的节点信息，比如有三个key,分别是 (abc ,abd, ab) 第17个字段储存了ab节点的值。这块还有一些细节小编也还没搞懂，等后期了解后，再调整。</li>
<li>叶子节点<br>存储的是rlp编码后的原始数据，这个同样看图，文字很难说明，小编最初也是看各种文章文字解释，越解释越乱。</li>
</ul>
<p>小编想补充说明的是，在MPT中，除了叶子部分存有真实的数据，其余部分存储了完整的数据校验信息，只要获取到非叶子部分的MPT树，就可以进行如下几个操作：</p>
<ul>
<li>下载某个hash对应的数据块</li>
<li>校验下载的数据块是不是真实的</li>
</ul>
<p>看图，因为从根节点到叶子节点前，可以获取到一个完整的hash。</p>
<p>另外，只要节点中某条路径下新增或者删除节点，整条路径的节点都会被重新实例化，然后重新插入db。</p>
<h3 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h3><p>本节使用一个案例，介绍了生成一棵MPT树的基本流程，这为我们后续在代码中理解整个过程打下了非常好的基础。</p>
<h2 id="MPT轻节点"><a href="#MPT轻节点" class="headerlink" title="MPT轻节点"></a>MPT轻节点</h2><h3 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h3><p>上面的MPT树，有两个问题：</p>
<ul>
<li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li>
<li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制（名词是小编瞎编的），大体如下：</p>
<ul>
<li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li>
<li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li>
</ul>
<h3 id="图示轻节点"><a href="#图示轻节点" class="headerlink" title="图示轻节点"></a>图示轻节点</h3><p>根据上述，一棵长时间没有发生变化的MPT树，它内存应该是一棵轻节点树，如下图所示：</p>
<img src="/articles/636a5647/3.png" class="" title="内存中的轻节点">
<p>是不是很惊讶，root节点指向一个只有hash值的节点，该hash表示的是完整节点中MPT中root指向的那个节点本身的hash。</p>
<h4 id="轻节点中添加数据"><a href="#轻节点中添加数据" class="headerlink" title="轻节点中添加数据"></a>轻节点中添加数据</h4><p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p>
<img src="/articles/636a5647/4.png" class="" title="轻节点添加数据">

<h3 id="删除和获取"><a href="#删除和获取" class="headerlink" title="删除和获取"></a>删除和获取</h3><p>delete、get操作与上面的添加数据过程类似，小编就不讲了</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>本文需要了解中的三种编码，以及MPT树的形成原理、MPT轻节点的原理。<br>小编的初衷是为了更通俗的解释一些比较理论的概念，若有不合适的地方，大家可以留言，小编会及时改进的。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Patricia树介绍</title>
    <url>/articles/12370dbd/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>小编本想在网上找一篇合适的文章来介绍这个Patricia树的，但找了半天，没发现一个合适的。尤其很多地方直接把标准的trie当成了Patricia树，这样很容易受到勿扰。<br>思来想去，小编打算自己大概介绍下这个树了。</p>
<a id="more"></a>
<p>看该文前，Patricia树是标准trie的改进，因此，建议大家先看看另一篇文章：<a href="/articles/5f802b92">浅谈标准Trie树（字典树）</a></p>
<h2 id="什么是Patricia树"><a href="#什么是Patricia树" class="headerlink" title="什么是Patricia树"></a>什么是Patricia树</h2><p>对标准Trie树有过了解后，聪明的你会发现标准Trie树有如下缺点：</p>
<ol>
<li>标准Trie树给每个字符分配一个结点，如果某个字符串没有公共结点，那就变成，一个字符串每个字符占用一个空间，长此下去，资源量费</li>
<li>容易遭到黑客拒绝服务攻击。</li>
</ol>
<p>为了解决这些问题，Patricia树悄然而生，它和标准Trie树最大的区别就是，<code>对于其中的结点，如果该节点是唯一的儿子的话，就和父节点合并。</code><br>标准trie树再讲一遍也没意思，下面这张图是小编在网上找到的一张很能标明Patricia树结构的图，应该是一目了然吧？</p>
<img src="/articles/12370dbd/1.png" class="" title="patricia树示例">
<p>公共结点与<code>标准Trie树一样</code>，叶子结点处，都是兄弟。也就是说，除了叶子结点，每个结点都有左孩子和右孩子。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊源码解读-第2讲-rlp模块源码解读</title>
    <url>/articles/c2a19e0e/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正式解读源码前，小编想先解释下为什么使用选择这一模块作为以太坊源码解读的开端：</p>
<ol>
<li>该模块可以独立于其余模块，且内容少，便于理解整体编码风格，找找感觉。</li>
<li>不懂go语言的，读完这么模块，基本就没什么语言障碍了，话说，go语言是有点怪。。</li>
</ol>
<a id="more"></a>

<h2 id="什么是rlp"><a href="#什么是rlp" class="headerlink" title="什么是rlp"></a>什么是rlp</h2><ul>
<li>rlp(递归长度前缀，Recursive Length Prefix)，是不是看的一脸懵逼？</li>
<li>序列化听说过不？java开发的同学们应该更了解吧？<code>rlp</code>就是以太坊中的序列化工具，它可以将其中涉及到的任何类型的数据都转化为字节序列，方便网络传输。</li>
<li>待序列化的数据需要<code>大端</code>化处理</li>
<li>以太坊的rlp主要分为：<code>对树形结构的数据序列化</code>以及<code>字节数组的序列化</code>。</li>
<li>rlp适用于任意二进制数据数组的编码。</li>
</ul>
<h2 id="以太坊中rlp规则"><a href="#以太坊中rlp规则" class="headerlink" title="以太坊中rlp规则"></a>以太坊中rlp规则</h2><p>黄皮书中，介绍到了以太坊的rlp规则，公式比较多，小编一个个来解释一下。<br>公式是从整体到细节的，希望大家能按顺序看，这样看更容易理解</p>
<h3 id="公式中可能涉及到的符号解释"><a href="#公式中可能涉及到的符号解释" class="headerlink" title="公式中可能涉及到的符号解释"></a>公式中可能涉及到的符号解释</h3><ul>
<li>||x||表示公式的长度</li>
<li><code>这个点号符号</code>$\cdot$<code>表示的是字符串衔接，不是相乘</code></li>
<li>BE(x)表示x的<code>大端模式</code>,啥是大端模式小编不解释，基础概念，上百度谷歌一下～</li>
<li>$\equiv$，恒等于，理解成等于姑且也可以。。。</li>
<li>剩下的符号，小编看了看，都是初中高中的，不要说不知道。。。</li>
</ul>
<h3 id="公式1：待序列化数据定义"><a href="#公式1：待序列化数据定义" class="headerlink" title="公式1：待序列化数据定义"></a>公式1：待序列化数据定义</h3><p>要被序列化的数据类型，用数学定义如下：</p>
<p>$$<br>\begin{split}<br>&amp;\mathbb{T} \equiv \mathbb{L} \cup \mathbb{B} \<br>&amp;\mathbb{L} \equiv \{t: t = (t[0], t[1], …) \cap \forall_{n&lt;||t||}\ t[n] \in \mathbb{T} \} \<br>&amp;\mathbb{B} \equiv \{b: b = (b[0], b[1], …) \cap \forall_{n&lt;||b||}\ b[n] \in \mathbb{O} \}<br>\end{split}<br>$$</p>
<p>解释的不一定合理，但大体是这么个意思:</p>
<ul>
<li>$\mathbb{T}$表示：待序列化数据中，<em>字节数组</em>以及<em>树形结构（树、结构体）</em>的数据。</li>
<li>$\mathbb{L}$表示：$\mathbb{T}$之一的，不止一个节点的树形结构。</li>
<li>$\mathbb{B}$表示：$\mathbb{T}$之一的，字节数组。</li>
<li>$\mathbb{O}$表示：小编的理解是，包括待序列化数据以外的，任何字节数组。要知道最终序列化时，待序列化的数据是需要大端处理的。</li>
</ul>
<h3 id="公式2：序列化过程"><a href="#公式2：序列化过程" class="headerlink" title="公式2：序列化过程"></a>公式2：序列化过程</h3><p>以太坊序列化是如何执行的：</p>
<p>$$<br>RLP(x) \equiv<br>\begin{cases}<br>R_b(x), &amp;\ if\ \ x \in \mathbb{B} \<br>R_l(x), &amp;\ otherwise \<br>\end{cases}<br>$$</p>
<p>这个公式就好理解了吧，对于这两大类数据，执行不同的函数来处理序列化</p>
<h3 id="公式3：-R-b-x-字节数组的序列化规则"><a href="#公式3：-R-b-x-字节数组的序列化规则" class="headerlink" title="公式3：$R_b(x)$字节数组的序列化规则"></a>公式3：$R_b(x)$字节数组的序列化规则</h3><p>$$<br>R_b(x) \equiv<br>\begin{cases}<br>x, &amp;if\ \ ||x||=1 \cap x[0]&lt;128 \<br>(128+||x||) \cdot x, &amp;else\ if\ \ ||x||&lt;56 \<br>(183+||BE(||x||)||) \cdot BE(||x||)\cdot x, &amp;otherwise<br>\end{cases}<br>$$</p>
<p>这公式的意思如下：</p>
<ul>
<li>如果字节数组长度为1，且这个字节的值小于128，则不处理</li>
<li>如果不满足上一条要求，但是满足字节数组的长度小于56，那么就在原始数据前面加上<code>128与该字节数组长度之和</code>，该过程类似字符串衔接。</li>
<li>如果不满足以上两种条件，那么就先在原始数据前面加上<code>原始数据长度的大端表示的数据</code>，再在其前面加上<code>183与原始数据大端表示的长度之和</code></li>
</ul>
<h3 id="公式4-R-l-x-树型结构数据的序列化规则"><a href="#公式4-R-l-x-树型结构数据的序列化规则" class="headerlink" title="公式4: $R_l(x)$树型结构数据的序列化规则"></a>公式4: $R_l(x)$树型结构数据的序列化规则</h3><p>$$<br>\begin{split}<br>s(x) &amp;\equiv RLP(x_0) \cdot RLP(x_1)…\<br>R_l(x) &amp;\equiv<br>\begin{cases}<br>(192+||s(x)||) \cdot s(x), &amp;if\ \ ||s(x)||&lt;56 \<br>(247+||BE(||s(x)||)||) \cdot BE(||s(x)||) \cdot s(x), &amp;otherwise \<br>\end{cases}<br>\end{split}<br>$$</p>
<p>第1个公式的意思如下：</p>
<ul>
<li>将树形结构中的每个元素分别使用RLP进行处理，然后将处理结果依次连接起来（字符串连接），生成新的字节，表示为<code>s</code>。</li>
</ul>
<p>第2个公式的意思如下：</p>
<ul>
<li>如果公式1连接后的<code>s</code>字节长度小于56，那结果就是在<code>s</code>前面连接上<code>192与 *s的长度* 之和</code></li>
<li>如果不满足上面的要求，也就是<code>s</code>字节长度大于等于56，则在s的前面连接上<code>s长度的大端表示</code>，再在其前面加上<code>247与*连接后长度的大端模式的长度*</code></li>
</ul>
<p>看懂上面的两个公式了不？看懂的话，你就会明白，这公式会是一个<code>递归过程</code>，因为结构体里还有结构体，一层又一层。。。</p>
<h3 id="公式5-标量数据处理-特殊数据"><a href="#公式5-标量数据处理-特殊数据" class="headerlink" title="公式5: 标量数据处理(特殊数据)"></a>公式5: 标量数据处理(特殊数据)</h3><p>$$<br>RLP(i:i \in \mathbb{P} ) \equiv RLP(BE(i))<br>$$<br>标量数据，可以理解为我们通常所说的基本的数据。<br>此时RLP只能用来处理正整数。这块理解貌似有点费劲，后面可以看看源码来进一步了解。这些数据需要先大端处理。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>抛离公式，小编在此总结一下，RLP是如下处理数据的：</p>
<ol>
<li>如果是一个单字节(长度为1)并且其值在<code>[0x00,0x7f]</code>范围内（即0～127），RLP编码就是自身。</li>
<li>如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。</li>
<li>如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为$2^56$</li>
<li>如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的s。如果一个列表数据的s的字节长度为0-55，那么列表的RLP编码在其s前加上一个字节，这个字节的值是0xc0加上s的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。</li>
<li>如果一个列表数据的s的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表s字节长度的二进制编码的字节长度，然后依次跟着s字节长度部分和s部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过$2^56$。</li>
</ol>
<h2 id="RLP源码解析"><a href="#RLP源码解析" class="headerlink" title="RLP源码解析"></a>RLP源码解析</h2><p>讲了一堆天书，终于到了关键地方了。<br>rlp分为<code>编码</code>和<code>解码</code>两个部分，当然，小编只会讲<code>编码</code>过程。<br><code>解码</code>过程的实现和<code>编码</code>过程都差不多。<br>另外一个原因是小编没那么多精力去那么细看啦，知道有那么一回事就行。</p>
<h3 id="rlp编码后数据格式："><a href="#rlp编码后数据格式：" class="headerlink" title="rlp编码后数据格式："></a>rlp编码后数据格式：</h3><p>为了便于更好的理解后面的代码，小编现画出如下结构图：</p>
<img src="/articles/c2a19e0e/1.png" class="" title="序列化后的数据结构">
<p>除了最后一个编码数据，其余编码后的每个原始数据之后，都对应的标有该数据的起始和截止位置信息。</p>
<h3 id="rlp模块源文件结构"><a href="#rlp模块源文件结构" class="headerlink" title="rlp模块源文件结构"></a>rlp模块源文件结构</h3><p>项目根目录下，找到<code>rlp</code>目录，里面如下结构：<br>.<br>|____raw.go                  //用于处理编码后的rlp数据，比如计算长度、分离等<br>|____raw_test.go             //rlp数据测试用例<br>|____encode.go               //编码器，用于将给定的数据编码为rlp<br>|____encode_test.go          //编码测试，各种测试用例验证编码器的稳定性<br>|____encoder_example_test.go //用案例体验测试编码<br>|____decode.go               //解码器，用于将rlp数据解码为原始数据<br>|____decode_test.go          //用于测试解码，各种测试用例测试解码器的稳定性<br>|____decode_tail_test.go     //用案例体验测试解码<br>|____typecache.go            //类型缓存，用于记录哪些类型数据应该如何处理（如何编码和解码）<br>|____doc.go                  //没什么，rlp的相关描述</p>
<h3 id="rlp编码过程解析：第1部分"><a href="#rlp编码过程解析：第1部分" class="headerlink" title="rlp编码过程解析：第1部分"></a>rlp编码过程解析：第1部分</h3><p>经过小编分析，从<code>encoder_example_test.go</code>这个文件作为入口来分析是最合适不过的。<br>该example的目的是编码一个结构体。根据前面的描述可知，编码一个结构体，基本就会牵涉到rlp的所有编码逻辑了。<br>具体来看看该文件的内容，先是定义了一个要进行编码的结构体，名为<code>MyCoolType</code>,而紧随其后，定义了属于该结构体的一个函数<code>EncodeRLP()</code>。<br>此处<code>EncodeRLP()</code>其实是一个<code>被实现了的接口函数</code>，等后面分析了<code>encode.go</code>的代码就会明白（具体go语法的接口实现，小编不想解释。。小编突然觉得，<code>该写个go语言教程了</code>)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCoolType <span class="keyword">struct</span> &#123;  <span class="comment">//要编码的的结构体</span></span><br><span class="line">	Name <span class="keyword">string</span>  <span class="comment">//字符串，名称</span></span><br><span class="line">	a, b <span class="keyword">uint</span>    <span class="comment">//两个整型数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呵呵，(x *MyCoolType)表示，该方法是属于结构体的MyCoolType</span></span><br><span class="line"><span class="comment">// 呵呵，(err error)表示这个方法的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *MyCoolType)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  <span class="comment">//若结构体指针本身是空的，则编码&#123;0,0&#125;</span></span><br><span class="line">		err = Encode(w, []<span class="keyword">uint</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) <span class="comment">//此处可以发现，真正参与编码的只有结构体中的a,b两个</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则编码指定结果</span></span><br><span class="line">		err = Encode(w, []<span class="keyword">uint</span>&#123;x.a, x.b&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看看具体该结构体编码的过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例，测试为空和不为空的结构体的编码方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleEncoder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t *MyCoolType <span class="comment">// t 是空指针</span></span><br><span class="line">	bytes, _ := EncodeToBytes(t) <span class="comment">//编码成字节数组</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v → %X\n&quot;</span>, t, bytes)  <span class="comment">//输出编码结果</span></span><br><span class="line"></span><br><span class="line">	t = &amp;MyCoolType&#123;Name: <span class="string">&quot;foobar&quot;</span>, a: <span class="number">5</span>, b: <span class="number">6</span>&#125; <span class="comment">//t有数据</span></span><br><span class="line">	bytes, _ = EncodeToBytes(t)  </span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v → %X\n&quot;</span>, t, bytes)  <span class="comment">//输出编码结果</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output:         //标准测试，必须如此输出，用于校验输出结果        </span></span><br><span class="line">	<span class="comment">// &lt;nil&gt; → C28080</span></span><br><span class="line">	<span class="comment">// &amp;&#123;foobar 5 6&#125; → C20506</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体怎么运转这个测试，不要问小编，小编是个大忙人。。。</p>
<h3 id="rlp编码过程解析：第2部分"><a href="#rlp编码过程解析：第2部分" class="headerlink" title="rlp编码过程解析：第2部分"></a>rlp编码过程解析：第2部分</h3><p>从上一部分example中发现，编码的入口函数是：<code>EncodeToBytes()</code>，随即我们跟踪到<code>encode.go</code>这个文件中，重头戏来了.</p>
<ol>
<li><p>先来看看该文件中定义的两个全局内容：</p>
<ul>
<li>该文件定义了，<code>空数据（理解成字符串吧）</code>和<code>空集合（树形结构）</code>对应编码后的结果  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">EmptyString = []<span class="keyword">byte</span>&#123;<span class="number">0x80</span>&#125;  <span class="comment">//128，定义了序列化时候的空字符串，空的时候对应的是编码128。</span></span><br><span class="line">EmptyList   = []<span class="keyword">byte</span>&#123;<span class="number">0xC0</span>&#125;  <span class="comment">//192，定义了序列化时候的空集合，空的时候对应的编码192</span></span><br></pre></td></tr></table></figure></li>
<li>其次，定义了一个接口，用于自定义编码数据（<code>看到了不，第1部分那个结构体里实现的方法，就是这个接口</code>）：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以理解为，任何拥有下面接口中函数的`结构体`，都表示继承并实现了该接口</span></span><br><span class="line"><span class="keyword">type</span> Encoder <span class="keyword">interface</span> &#123;</span><br><span class="line">	EncodeRLP(io.Writer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第1部分的一个待编码的结构体中，有两个uint数据，编码后，两个uint的序列是会衔接在一起的，因此为了便于区分我是需要知道每个uint在编码序列中的哪个位置，因此，有这么一个结构体：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> encbuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	str     []<span class="keyword">byte</span>      <span class="comment">// 被编码后的数据全部在此处，比如第1部分结构体中的两个uint，编码后的结果都紧挨着存在该str中</span></span><br><span class="line">	lheads  []*listhead <span class="comment">// 每个数据在编码序列中存储的位置。比如，还是上面那两个uint，编码后，第一个uint在str中的起始位置是多少，截止位置是多少，都在listhead[0]中记录的</span></span><br><span class="line">	lhsize  <span class="keyword">int</span>         <span class="comment">// lheads的长度，也就是说，被编码的数据有几个。比如，两个uint参与编码，那lhsize=2</span></span><br><span class="line">	sizebuf []<span class="keyword">byte</span>      <span class="comment">// 9个字节大小的辅助buffer，专门用来处理uint的编码的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>呵呵，<code>listhead</code>这个结构体是如下定义的，用来确定被编码的数据，在序列中的哪一部分：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> listhead <span class="keyword">struct</span> &#123;</span><br><span class="line">	offset <span class="keyword">int</span> <span class="comment">// 被编码的某个数据在序列中的起始位置</span></span><br><span class="line">	size   <span class="keyword">int</span> <span class="comment">// 包含头部在内的所有编码了的数据的总长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另外，encbuf结构体有如下这些函数（函数比较多，小编在此概述一下这些函数的功能）：<ol>
<li><code>reset()</code>：用于将encbuf中的数据初始化，后面对象池中调取时候，会用到。</li>
<li><code>Write()</code>：实现了<code>io.Writer的接口</code>，用于连接byte[]编码，可以理解为字符串连接，在结构体若实现了<code>EncodeRLP</code>自定义编码，用<code>Write()</code>函数会很方便</li>
<li><code>encode()</code>：用于编码数据，同时将先后编码的数据依次衔接起来（<code>后面详细介绍</code>）。</li>
<li><code>encodeStringHeader()</code>：将encbuf中的头部是需要序列化，该函数是将头部结构体中的一个<code>新的编码后的元素</code>和<code>先前已编码的所有数据</code>衔接起来</li>
<li><code>encodeString()</code>：该函数是将当前编码后的一个原始数据衔接到已编码的所有数据之后</li>
<li><code>list()</code>：用于保存每个元素编码后的头部信息，</li>
<li><code>listEnd()</code>：编码衔接结束后的长度统计处理</li>
<li><code>size()</code>：计算编码后的数据和其头部的总长度</li>
<li><code>toBytes()</code>：将每个头部编码，并衔接到对应的编码后的数据之后</li>
<li><code>toWriter</code>：该方法是io流方式，将编码后的头部写在编码数据之后</li>
<li>看不懂这些方法的同学，最好先好好看看上面画的那个<code>序列化后的数据结构</code>图</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ok，接着来看看我们的<code>EncodeToBytes()</code>函数，它就是用来将数据序列化为byte数组的元凶。<br>该函数中，可以发现，为了减少资源浪费，提高连续编码的效率，以太坊使用了对象池来保存一个<code>encbuf</code>实例<br><code>ps</code>:下面代码有个关键词叫<code>defer</code>，表示，这行代码要等return完之后才会执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToBytes</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	eb := encbufPool.Get().(*encbuf)  <span class="comment">//从对象池中获取一个用于存储完整编码数据的空间</span></span><br><span class="line">	<span class="keyword">defer</span> encbufPool.Put(eb)          <span class="comment">//return 结束之后才会执行，将实例化的encbuf放入对象池，方便下次使用。</span></span><br><span class="line">	eb.reset()  <span class="comment">//encbuf结构体的函数，初始化该结构体对应实例中的元素</span></span><br><span class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123; <span class="comment">//原始数据进行编码，刚编码好的数据是放在字符串中的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eb.toBytes(), <span class="literal">nil</span> <span class="comment">//将编码后的数据本身和头部衔接起来并放在byte[]中，并返回最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正重要的一段代码就是：<code>eb.encode(val)</code>，不要闷逼，再次强调<code>eb</code>是<code>encbuf结构体的实例</code>，<code>encode</code>是其最重要的函数，看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *encbuf)</span> <span class="title">encode</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rval := reflect.ValueOf(val)  <span class="comment">//获取该数据具体的值（包括结构体）</span></span><br><span class="line">	ti, err := cachedTypeInfo(rval.Type(), tags&#123;&#125;) <span class="comment">//根据数据类型来编码数据</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ti.writer(rval, w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先注意一下其中的最后一行代码涉及到的<code>writer()</code>，这个在下一节中会具体去讲，简单说就是，writer被定义为了一种数据类型，<code>只要满足它函数格式的，都属于writer类型</code><br>好的，这块代码，其中的<code>cachedTypeInfo()</code>，把我们的节奏引入了高潮，具体如何，且听下一部分分析</p>
</li>
</ol>
<h3 id="rlp编码过程解析：第3部分"><a href="#rlp编码过程解析：第3部分" class="headerlink" title="rlp编码过程解析：第3部分"></a>rlp编码过程解析：第3部分</h3><p>继续上回讲解，<code>cachedTypeInfo()</code>函数是在<code>typecache.go</code>中实现的，这个文件里，对编码和解码做了详细的规划，让我们更加清晰的了解到了rlp的全局结构。</p>
<ol>
<li><code>cachedTypeInfo()</code>函数具体怎么回事我们先不说，按惯例，先来看看<code>typecache.go</code>该文件中主要定义了哪些全局属性：<ul>
<li>该文件定义了一个读写锁，多线程、并发读取数据时候的保护措施；还定义了一个映射，不同的数据类型，对应不同的编码或者解码器。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	typeCacheMutex sync.RWMutex    <span class="comment">//读写锁，用来在多线程的时候保护typeCache这个Map</span></span><br><span class="line">	<span class="comment">//核心数据结构，保存了类型-&gt;编解码器函数，*typeinfo指针类型，根据不同的数据类型（reflect.Type），保存不同的解码方式</span></span><br><span class="line">	typeCache      = <span class="built_in">make</span>(<span class="keyword">map</span>[typekey]*typeinfo)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
  其中发现有两个重要的结构体：<ul>
<li>首先是<code>typekey</code>，定义了数据所属类型，以及该数据的特点（是否是集合，是否为空等）  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typekey <span class="keyword">struct</span> &#123;</span><br><span class="line">	reflect.Type   <span class="comment">//数据类型不同，则编码解码的数据类型也不同</span></span><br><span class="line">	tags <span class="comment">//某种数据类型中，是否为空，是否为集合，不同情况处理不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在该结构体其中其中，又有一个<code>tags</code>结构体，主要是用来标注数据的特点，如下：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tags <span class="keyword">struct</span> &#123;</span><br><span class="line">	nilOK <span class="keyword">bool</span>  <span class="comment">//是否为空</span></span><br><span class="line">	tail <span class="keyword">bool</span>  <span class="comment">//是否为集合（切片）</span></span><br><span class="line">	ignored <span class="keyword">bool</span>  <span class="comment">//该参数留着，备用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>其次定义了一个编码器和解码器的结构体<code>typeinfo</code>，注意他们对应的函数  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeinfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	decoder  <span class="comment">//解码，</span></span><br><span class="line">	writer   <span class="comment">//编码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> decoder <span class="function"><span class="keyword">func</span><span class="params">(*Stream, reflect.Value)</span> <span class="title">error</span> //把满足该结构的函数，定义为数据类型<span class="title">decoder</span></span></span><br><span class="line"><span class="keyword">type</span> writer <span class="function"><span class="keyword">func</span><span class="params">(reflect.Value, *encbuf)</span> <span class="title">error</span>  //把满足该结构的函数，定义为数据类型<span class="title">writer</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>接着我们来讲讲期待已久的<code>cachedTypeInfo()</code>函数，怎么说吧，它的作用是，根据数据属性的不同，返回一个合适的<code>编码\解码器</code>来处理该数据，为了保证读写安全，使用了读写锁；为了提高效率，缓存了<code>数据类型</code>和<code>编码\解码器</code>的映射（就是说，比如字符串类型的数据，要用到专门处理字符串的编码\解码器）。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo</span><span class="params">(typ reflect.Type, tags tags)</span> <span class="params">(*typeinfo, error)</span></span> &#123;</span><br><span class="line">	typeCacheMutex.RLock()  <span class="comment">//加读锁来保护</span></span><br><span class="line">	info := typeCache[typekey&#123;typ, tags&#125;]  <span class="comment">//在缓存中查是找是否有typ类型的数据对应的 编码\解码器</span></span><br><span class="line">	typeCacheMutex.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;   </span><br><span class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span>  <span class="comment">//若找到了，则返回结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// not in the cache, need to generate info for this type.</span></span><br><span class="line">	<span class="comment">//加写锁 调用cachedTypeInfo1函数创建并返回，</span></span><br><span class="line">	<span class="comment">//这里需要注意的是在多线程环境下有可能多个线程同时调用到这个地方，</span></span><br><span class="line">	<span class="comment">//所以当你进入cachedTypeInfo1方法的时候需要判断一下是否已经被别的线程先创建成功了。</span></span><br><span class="line">	typeCacheMutex.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> typeCacheMutex.Unlock()  <span class="comment">//等return执行完毕后，才会调用该行defer。再次吐槽go..</span></span><br><span class="line">	<span class="keyword">return</span> cachedTypeInfo1(typ, tags) <span class="comment">//缓存中不存在，则创建对应类型的编码\解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上面代码，真正该注意的是<code>cachedTypeInfo1(typ,tags)</code>，它的目的就是根据数据类型去创建并缓存对应的编码\解码器。代码实现如下：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedTypeInfo1</span><span class="params">(typ reflect.Type, tags tags)</span> <span class="params">(*typeinfo, error)</span></span> &#123;</span><br><span class="line">	key := typekey&#123;typ, tags&#125;</span><br><span class="line">	info := typeCache[key]</span><br><span class="line">	<span class="keyword">if</span> info != <span class="literal">nil</span> &#123;  <span class="comment">//此处再次验证是为了避免并发请求造成影响</span></span><br><span class="line">		<span class="keyword">return</span> info, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	typeCache[key] = <span class="built_in">new</span>(typeinfo)  <span class="comment">//根据数据类型，新建一个它的编码\解码器的缓存空间（此时并不知道具体是哪个编码\解码器）</span></span><br><span class="line">	info, err := genTypeInfo(typ, tags) <span class="comment">//根据数据类型，找到它对应的编码\解码器</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(typeCache, key)  <span class="comment">//创建失败则清除此空间</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err  <span class="comment">//返回空</span></span><br><span class="line">	&#125;</span><br><span class="line">	*typeCache[key] = *info <span class="comment">//创建成功保存该编码器</span></span><br><span class="line">	<span class="keyword">return</span> typeCache[key], err <span class="comment">//返回当前数据类型的编码/解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码，又有一个重要的函数：<code>genTypeInfo(typ, tags)</code>，它用来根据数据类型，找到对应的编码\解码器，具体实现如下：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genTypeInfo</span><span class="params">(typ reflect.Type, tags tags)</span> <span class="params">(info *typeinfo, err error)</span></span> &#123;</span><br><span class="line">	info = <span class="built_in">new</span>(typeinfo)  <span class="comment">//新建一个保存编码\解码的空间</span></span><br><span class="line">	<span class="keyword">if</span> info.decoder, err = makeDecoder(typ, tags); err != <span class="literal">nil</span> &#123; <span class="comment">//解码获取失败，则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> info.writer, err = makeWriter(typ, tags); err != <span class="literal">nil</span> &#123;  <span class="comment">//编码获取失败，则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只有成功找到了编码器和解码器，才会返回它们的映射信息。别忘了info的结构体类型</span></span><br><span class="line">	<span class="keyword">return</span> info, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
清楚了吧，整个编码器和解码器的框架结构其实并不复杂，其中用到的线程安全机制和缓存机制是蛮有意思的。对于上面代码提到的<code>makeDecoder()</code>和<code>makeWriter()</code>,也就是具体获取编码\解码器是怎样实现的，小编在下一部分来解释，莫心急，心急吃不了豆腐～～～</li>
</ul>
</li>
</ol>
<h3 id="rlp编码过程解析：第4部分"><a href="#rlp编码过程解析：第4部分" class="headerlink" title="rlp编码过程解析：第4部分"></a>rlp编码过程解析：第4部分</h3><ol>
<li>紧接上一部分，<code>makeDecoder()</code>和<code>makeWriter()</code>具体是用来实现获取对应编码\解码器的，这下又跳转回<code>encode.go</code>文件中，小编这里只讲编码器<code>makeWriter()</code>的获取了，解码器类似，只是相反而已。具体如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeWriter</span><span class="params">(typ reflect.Type, ts tags)</span> <span class="params">(writer, error)</span></span> &#123;</span><br><span class="line">	kind := typ.Kind()  <span class="comment">//先获取数据类型</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> typ == rawValueType:</span><br><span class="line">			<span class="keyword">return</span> writeRawValue, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> typ.Implements(encoderInterface):</span><br><span class="line">			<span class="keyword">return</span> writeEncoder, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> kind != reflect.Ptr &amp;&amp; reflect.PtrTo(typ).Implements(encoderInterface):</span><br><span class="line">			<span class="keyword">return</span> writeEncoderNoPtr, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Interface:</span><br><span class="line">			<span class="keyword">return</span> writeInterface, <span class="literal">nil</span>    </span><br><span class="line">		<span class="keyword">case</span> typ.AssignableTo(reflect.PtrTo(bigInt)):</span><br><span class="line">			<span class="keyword">return</span> writeBigIntPtr, <span class="literal">nil</span>  </span><br><span class="line">		<span class="keyword">case</span> typ.AssignableTo(bigInt):</span><br><span class="line">			<span class="keyword">return</span> writeBigIntNoPtr, <span class="literal">nil</span> </span><br><span class="line">		<span class="keyword">case</span> isUint(kind):</span><br><span class="line">			<span class="keyword">return</span> writeUint, <span class="literal">nil</span>  </span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Bool:</span><br><span class="line">			<span class="keyword">return</span> writeBool, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.String:</span><br><span class="line">			<span class="keyword">return</span> writeString, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Slice &amp;&amp; isByte(typ.Elem()):</span><br><span class="line">			<span class="keyword">return</span> writeBytes, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Array &amp;&amp; isByte(typ.Elem()):</span><br><span class="line">			<span class="keyword">return</span> writeByteArray, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Slice || kind == reflect.Array:</span><br><span class="line">			<span class="keyword">return</span> makeSliceWriter(typ, ts)</span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Struct:</span><br><span class="line">			<span class="keyword">return</span> makeStructWriter(typ)</span><br><span class="line">		<span class="keyword">case</span> kind == reflect.Ptr:</span><br><span class="line">			<span class="keyword">return</span> makePtrWriter(typ)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;rlp: type %v is not RLP-serializable&quot;</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个代码应该很好懂吧，根据不同的数据类型，返回对应的具体的编码函数，注意看<code>makeWriter()</code>的数据返回类型，返回的是一个编码函数，这就是对应数据类型的编码器。每种数据类型都有各自的编码器被返回。建议大家根据需要去仔细读读每种编码器的具体实现方式，也挺有意思的。<br> 另外需要知道，对于长度为1的数据，是没有必要做head记录的。因此，关于对head操作，大伙看看不同的编码器中的处理就明白了。</li>
<li>小编根据第1部分提供的待编码数据类型可知，该数据类型是指针，且实现了<code>EncodeRLP()</code>接口，它对应的类型是上述代码中的第2个<code>case</code>,即<code>typ.Implements(encoderInterface)</code>，因此小编详细介绍下<code>writeEncoder()</code>，先看它的代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeEncoder</span><span class="params">(val reflect.Value, w *encbuf)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> val.Interface().(Encoder).EncodeRLP(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 就两行代码，指向了我们在第1部分的定义的待编码的结构体数据中的<code>EncodeRLP()</code>函数，为了方便演示，小编这里再列出来看看： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCoolType <span class="keyword">struct</span> &#123;  </span><br><span class="line">	Name <span class="keyword">string</span>  </span><br><span class="line">	a, b <span class="keyword">uint</span>   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *MyCoolType)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> </span><br><span class="line">		err = Encode(w, []<span class="keyword">uint</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		err = Encode(w, []<span class="keyword">uint</span>&#123;x.a, x.b&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 呵呵，发现了吧，该接口实现中，调用了<code>Encode()</code>函数，其中的参数<code>w</code>指的是它是<code>encbuf</code>，该函数是在<code>encode.go</code>文件中。那就看看它的具体实现吧：<br> 该函数其实也很有特点：因为有的时候，以太坊中的数据并不是直接通过<code>EncodeToBytes()</code>传入具体的数据来编码，很多时候它是通过io流传入待编码数据的，因此，其实这个<code>Encode()</code>函数也很重要。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//语法说明，断言w.(*encbuf)的具体类型是否为*encbuf，是，则返回给outer=*encbuf,并且ok为true；否，则返回outer=nil，并且ok为false</span></span><br><span class="line">	<span class="keyword">if</span> outer, ok := w.(*encbuf); ok &#123; <span class="comment">//EncodeRLP接口提供的参数是`io.Writer`类型，但是，从前面分析我们得知，我们传入的是实现了`io.Writer`的`encbuf`。因此需要判断。</span></span><br><span class="line">		<span class="keyword">return</span> outer.encode(val) </span><br><span class="line">	&#125;</span><br><span class="line">	eb := encbufPool.Get().(*encbuf) <span class="comment">//若是直接输入的`io.Writer`流来编码，则通过该处对象池将其转为`encbuf`</span></span><br><span class="line">	<span class="keyword">defer</span> encbufPool.Put(eb) <span class="comment">//当return后才会执行</span></span><br><span class="line">	eb.reset()</span><br><span class="line">	<span class="keyword">if</span> err := eb.encode(val); err != <span class="literal">nil</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eb.toWriter(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 若传入的是标准<code>io.Writer</code>,则该代码最终返回的是<code>eb.toWriter(w)</code>流结果，它和<code>EncodeToBytes()</code>函数中返回的byte[]结果还是有区别的。<br> 此处编码结束，看看下1部分吧，在坚持一下就可以结束了～～</li>
</ol>
<h3 id="rlp编码过程解析：第5部分"><a href="#rlp编码过程解析：第5部分" class="headerlink" title="rlp编码过程解析：第5部分"></a>rlp编码过程解析：第5部分</h3><p>拿到编码器就可以回到第2部分的<code>encode()</code>函数了。返回编码结果，进一步返回到<code>EncodeToBytes()</code>函数，最终返回到第1部分的编码结果。</p>
<h2 id="解码相关概述"><a href="#解码相关概述" class="headerlink" title="解码相关概述"></a>解码相关概述</h2><p>本来小编是不想讲的，想了想，还是大概说两句吧。<br>解码和编码的方向相反，方式一样。解码时候，先计算好开辟好的结构体、数据类型等的大小和空间，然后就可以在被序列化的编码中，读取到指定位置的值，从而读取到具体数据。<br>还不懂吗？看代码吧。。。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个编码过程，其实可以这么说明：<br>待编码数据，先根据数据类型去对象池中找相应的解码器，若没有该解码器则新建一个并将其加入缓存。编码结束后，会返回一个结构体信息，其中包含所有编码后的序列以及其中每个被编码的数据的头部信息（它们在整个编码序列中的位置）。最后，拼装编码序列以及头部信息（此时头部信息会进行编码），生成最终的编码序列。图示如下：</p>
<img src="/articles/c2a19e0e/2.png" class="" title="编码整体流程">

<p>吐出一口老血，终于完成这个浩大的工程了。。。<br>解码过程就不写了，根据编码过程反推就行。</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>(以太坊源码解读)第1讲-看前必读</title>
    <url>/articles/ff874140/</url>
    <content><![CDATA[<ul>
<li>本项目是在IntelliJ idea 2017.3.1版中部署的，部署时候，需要注意项目结构，具体部署不是小编的重点，此处就不详细解释了，有需要的可以别的网站查阅，资料很多</li>
<li>可以在此处参考小编从IntelliJ idea发布的以太坊项目来部署：<a href="https://github.com/jason-wj/blockchain-analysis">https://github.com/jason-wj/blockchain-analysis</a></li>
<li>小编是基于ethereum 1.8.3阅读的（原先看的是1.8.1，看改动不大，这次编辑文章，就直接用1.8.3啦）</li>
<li>源码解读最初参考自：<a href="https://github.com/ZtesoftCS/go-ethereum-code-analysis">https://github.com/ZtesoftCS/go-ethereum-code-analysis</a> ，小编根据自己个人学习方式和理解能力做了大量修改，个人认为，更容易让初学者理解。</li>
</ul>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>使用web3.js与智能合约交互</title>
    <url>/articles/7a486277/</url>
    <content><![CDATA[<p>使用truffle编译并发布智能合约到以太坊私有网络后，接下来，就该开放接口给前端使用了。这时会面临个问题，怎样和以太坊的智能合约进行交互？<br>大体两种方式：</p>
<ol>
<li>直接使用原生的web3.js与智能合约操作，小编尝试了以下，操作起来很麻烦，总之很别扭。</li>
<li>使用<code>truffle-contract</code>模块来操作智能合约，它将原生的web3.js进行了一些必要的封装，简化了操作方式，用着很顺手，基本类似于写truffle测试用例时候的语法格式。但是<a href="https://github.com/trufflesuite/truffle-contract">官方</a>有些地方的使用方法讲的很模糊，小编在此进一步翻译一下。<a id="more"></a>

</li>
</ol>
<h2 id="truffle-contract的使用-需要有nodejs基础"><a href="#truffle-contract的使用-需要有nodejs基础" class="headerlink" title="truffle-contract的使用 (需要有nodejs基础)"></a>truffle-contract的使用 (<code>需要有nodejs基础</code>)</h2><ol>
<li>truffle编译智能合约，发布到以太坊私有网络。生成的json文件放在接口项目的某文件夹下：<br><code>备注：</code>编译发布智能合约可以参考此处：<a href="http://www.wjblog.top/categories/%E5%8E%9F%E5%88%9B/%E4%BB%A5%E5%A4%AA%E5%9D%8A/truffle/%E5%AE%98%E7%BF%BB/">http://www.wjblog.top/categories/%E5%8E%9F%E5%88%9B/%E4%BB%A5%E5%A4%AA%E5%9D%8A/truffle/%E5%AE%98%E7%BF%BB/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小编在此处放的：</span><br><span class="line">testProject&#x2F;assert&#x2F;contract&#x2F;token&#x2F;CrowdsaleFCToken</span><br></pre></td></tr></table></figure></li>
<li>项目根目录安装web3.js以及truffle-contract:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install web3.js</span><br><span class="line">npm install truffle-contract</span><br></pre></td></tr></table></figure></li>
<li>核心代码，头部声明：<br>小编用的nodejs的express框架，主要看方法内部就可以，别的地方不用深究<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);  <span class="comment">//导入web3模块</span></span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">&#x27;truffle-contract&#x27;</span>);  <span class="comment">//导入truffle-contract模块</span></span><br><span class="line"><span class="keyword">var</span> crowdsaleToken = <span class="built_in">require</span>(<span class="string">&#x27;../assert/contract/token/CrowdsaleFCToken&#x27;</span>) <span class="comment">//导入（json文件）指定的已经发布到以太坊私有网络中的合约，该合约应该位于第1步提到的地方。</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3();  <span class="comment">//实例化web3</span></span><br><span class="line"><span class="keyword">var</span> token = contract(crowdsaleToken);  <span class="comment">//实例化合约，contract方法可以将json解析，并将最终合约文件信息返回</span></span><br><span class="line">web3.setProvider(<span class="keyword">new</span> web3.providers.HttpProvider());  <span class="comment">//设置网络</span></span><br><span class="line">token.setProvider(web3.currentProvider);</span><br></pre></td></tr></table></figure></li>
<li>核心代码，具体合约中的方法以及变量的调用(要注意合约中的方法和变量是不是<code>public</code>的)：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/send&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        token.deployed().then(<span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//调用智能合约方法</span></span><br><span class="line">            instance.getTokenExchangeAmount(<span class="number">6000000000000000</span>,<span class="number">100</span>,<span class="number">18</span>,<span class="number">8</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                res.send(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用智能合约方法</span></span><br><span class="line">            instance.balanceOf(web3.eth.coinbase).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                res.send(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用合约中的全局变量或常量</span></span><br><span class="line">            instance.saleAmount.call().then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">               res.send(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送以太币，换取token</span></span><br><span class="line">            instance.buyTokens(web3.eth.accounts[<span class="number">1</span>],&#123;<span class="attr">from</span>:web3.eth.accounts[<span class="number">1</span>],<span class="attr">value</span>:web3.toWei(<span class="number">1000</span>,<span class="string">&quot;ether&quot;</span>)&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                res.send(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
 代码中，<code>deployed()</code>标示使用以太坊默认账户操作，也就是<code>coinbase</code>账户，也可以使用<code>at(账户地址)</code>来指定别的账户。</li>
<li>整体的使用方式就是上面提到的那些了，这么一展示，之后看<a href="https://github.com/trufflesuite/truffle-contract">官方</a>的文档就很容易了</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
      </categories>
      <tags>
        <tag>truffle</tag>
        <tag>contracts</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第16讲 将应用和truffle集成编译</title>
    <url>/articles/2937276b/</url>
    <content><![CDATA[<p>如果你的应用要和Truffle集成在一起（反正小编还没见过有集成在一起的），则需要参考该文档：<a href="http://truffleframework.com/docs/advanced/build_processes">http://truffleframework.com/docs/advanced/build_processes</a><br>（这个小编就不翻译了，暂时没卵用）</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第15讲 网络和app发布</title>
    <url>/articles/cf19e958/</url>
    <content><![CDATA[<p>暂未翻译</p>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第14讲 各种配置文件（truffle.js、MochaJS、Solidity）</title>
    <url>/articles/c382f486/</url>
    <content><![CDATA[<h2 id="truffle-js配置"><a href="#truffle-js配置" class="headerlink" title="truffle.js配置"></a>truffle.js配置</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当使用Windows的命令行时，默认的配置文件名与truffle冲突。这种情况下，我们推荐使用Windows的power Shell或Git BASH。你也可以将配置文件重命名为truffle-config.js来避免冲突。<br>这也是为什么<code>truffle init</code>时候，项目里会生成一个<code>truffle.js</code>和<code>truffle_config.js</code>。</p>
<ol>
<li>配置文件位置：<br>它在项目根目录中，称为<em>truffle.js</em></li>
<li>必须要配置这个文件，格式如下，默认是8545端口：   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">      port: <span class="number">8545</span>,</span><br><span class="line">      network_id: <span class="string">&quot;*&quot;</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3></li>
<li>build设置<br>就是说，将你的应用和Truffle结合在一起当应用（一般很少见），可参考：<br><a href="/doc/truffle/doc/%E7%AC%AC16%E8%AE%B2_%E5%B0%86%E5%BA%94%E7%94%A8%E5%92%8Ctruffle%E9%9B%86%E6%88%90%E7%BC%96%E8%AF%91.md">第16讲_将应用和truffle集成编译</a>  </li>
<li>合约发布时，可以指定使用哪个网络：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用哪种网络，需要在truffle.js中配置</span><br><span class="line">migrate —network live  </span><br></pre></td></tr></table></figure></li>
<li>具体配置文件如下：   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    networks: &#123;</span><br><span class="line">      development: &#123;</span><br><span class="line">        host: <span class="string">&quot;127.0.0.1&quot;</span>,  <span class="comment">// 默认为localhost</span></span><br><span class="line">        port: <span class="number">8545</span>,         <span class="comment">// 默认为8545</span></span><br><span class="line">        network_id: <span class="string">&quot;*&quot;</span> <span class="comment">// match any network</span></span><br><span class="line">      &#125;,</span><br><span class="line">      live: &#123;</span><br><span class="line">        host: <span class="string">&quot;178.25.19.88&quot;</span>, <span class="comment">// Random IP for example purposes (do not use)</span></span><br><span class="line">        port: <span class="number">80</span>,</span><br><span class="line">        network_id: <span class="number">1</span>,        <span class="comment">// Ethereum public network</span></span><br><span class="line">        <span class="comment">// optional config values:</span></span><br><span class="line">        <span class="comment">// gas  - 默认为4712388  </span></span><br><span class="line">        <span class="comment">// gasPrice  - 默认为100000000000（100Gwei）</span></span><br><span class="line">        <span class="comment">// from - default address to use for any transaction Truffle makes during migrations</span></span><br><span class="line">        <span class="comment">// provider - web3 provider instance Truffle should use to talk to the Ethereum network.</span></span><br><span class="line">        <span class="comment">//          - function that returns a web3 provider instance (see below.)</span></span><br><span class="line">        <span class="comment">//          - if specified, host and port are ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>说明：<ol>
<li><strong>注意，networks中，每一个代表一个provider</strong></li>
<li>设置网络参数，设置gas和地址等信息，</li>
<li>truffle.js中的networks配置是必要的，默认给出的网络是可以连接在任意的network_id中的，在测试时候，这是有用的，但是在生产环境下，不建议。可通过network _id来指定多个网络。</li>
<li>gas：gas最大值设置，默认为4712388（这个设置的大点，默认就好，）</li>
<li>gasPrice：gas 价格，默认为100000000000wei(众筹一般：100Gwei就够了)</li>
<li>from：移植期间，默认的第一个有效提供者（当前指定以太坊网络中）</li>
<li>provider：默认是web3使用host和port提供：<br>注意，在任意网络中，或者是设置host/port或者设置provider，不可以同时设置。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://&lt;host&gt;:&lt;port&gt;&quot;</span>);</span><br><span class="line">    <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">8. 管理多个providers，  </span></span><br><span class="line"><span class="string">一个网络还不够用啊，非要搞一堆，具体自己看文档吧（http://truffleframework.com/docs/advanced/configuration），这里小编偷懒不翻译了，感觉没啥用。</span></span><br><span class="line"><span class="string">9. 设置.sol合约编译输出的默认路径（contracts_build_directory）  </span></span><br><span class="line"><span class="string">默认就是输出来./build/contracts  </span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      contracts_build_directory: <span class="string">&quot;./output&quot;</span>,</span><br><span class="line">      networks: &#123;</span><br><span class="line">        development: &#123;</span><br><span class="line">          host: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">          port: <span class="number">8545</span>,</span><br><span class="line">          network_id: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Mocha配置<ol>
<li>可参考：<a href="http://mochajs.org/">http://mochajs.org/</a></li>
<li>例子：   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mocha: &#123;</span><br><span class="line">  useColors: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Solidity编译器配置<br>可以设置solc:   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">solc: &#123;</span><br><span class="line">  optimizer: &#123;</span><br><span class="line">    enabled: <span class="literal">true</span>,</span><br><span class="line">    runs: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第13讲 编写外部脚本</title>
    <url>/articles/712f35b3/</url>
    <content><![CDATA[<ol>
<li><p>有时候想写个外部脚本来和合约交互，Truffle已经替你想好了，你只要这么做就行</p>
</li>
<li><p>truffle develop环境中运行：  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec &lt;path&#x2F;to&#x2F;file.js&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>文件结构<br>为了使得脚本能正常运行，需要它们能通过js模块导出一个函数，并且有一个回调函数：  </p>
<pre><code class="js">module.exports = function(callback)&#123;
   //perform actions
&#125;</code></pre>
<p> 在脚本里，随便写，只要能运行就好。上面那个回调，当脚本结束后，会被执行</p>
</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第12讲 Truffle的develop环境和console环境</title>
    <url>/articles/70e2cc7d/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>总之是很叼的东西，有时候方便测试</p>
</li>
<li><p>提供了两种方式</p>
<ol>
<li>Truffle console :一个基本的交互控制台，用于连接一个已有以太坊网络或者是已有的Truffle Develop环境</li>
<li>Truffle Develop：一个基本的控制台，就是创建独立的一个测试环境（模拟以太坊）</li>
</ol>
</li>
<li><p>为什么会有这两种方式</p>
<ol>
<li>使用Truffle console <ol>
<li>有一个真实的区块链网络</li>
<li>想要发布到以太坊公共测网络</li>
<li>想用别的账户名称</li>
</ol>
</li>
<li>使用Truffle Develop<ol>
<li>用于测试项目，并不急于发布</li>
<li>不需要特殊的账户操作</li>
<li>不想安装或者管理区块链客户端<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2></li>
</ol>
</li>
</ol>
</li>
<li><p>退出环境使用：control+c</p>
</li>
<li><p>所有的命令都需要在你项目的根目录下运行</p>
<ol>
<li><p>Truffle console环境，命令：  </p>
<pre><code>truffle console</code></pre>
<p> 他将会在配置文件truffle.js中查找命名为development的网络，并且连接。你也可以使用  —netwokr <name>，这样就会去truffle.js对应的networks的 name  </p>
</li>
<li><p>Truffle Develop环境  </p>
<ol>
<li>登陆环境:  <pre><code class="bash">truffle develop</code></pre>
</li>
</ol>
</li>
<li><p>连接localhost:9545，这种方式不会去考虑truffle.js中配置的环境怎样</p>
</li>
<li><p>Truffle console和Truffle Develop的环境的命令基本都一致</p>
<h2 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h2><p>如果命令不可用，说明该命令对该阶段的项目并不起作用  </p>
</li>
</ol>
</li>
<li><p>build</p>
</li>
<li><p>compile</p>
</li>
<li><p>create</p>
</li>
<li><p>debug</p>
</li>
<li><p>exec</p>
</li>
<li><p>install</p>
</li>
<li><p>migrate</p>
</li>
<li><p>networks</p>
</li>
<li><p>opcode</p>
</li>
<li><p>publish</p>
</li>
<li><p>test</p>
</li>
<li><p>version</p>
</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第7.2讲 编写一个JavaScript测试文件</title>
    <url>/articles/d2be0737/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Truffle使用了Mocha（<a href="https://mochajs.org/%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%92%8CChai%E6%96%AD%E8%A8%80%E6%9D%A5%E5%86%99js%E6%B5%8B%E8%AF%95%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9E%85%E7%9E%85%E6%9C%89%E5%A4%9A%E5%90%8A%E3%80%82">https://mochajs.org/）测试框架和Chai断言来写js测试，让我们来瞅瞅有多吊。</a><br>如果你不熟悉使用Mocha写测试用例，需要先看<a href="https://mochajs.org/">https://mochajs.org/</a><br>小编肯定没用它写过。。。也懒得去专研它了，有需要的还是看原文吧。。<h2 id="呵呵"><a href="#呵呵" class="headerlink" title="呵呵"></a>呵呵</h2>量真大，翻译不动了。。。。。。。。。。。。。。。</li>
</ul>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第7.1讲 合约测试</title>
    <url>/articles/d97bcb06/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol>
<li>可以用两种不同的方式编写简单且容易管理的测试：<ol>
<li>在JavaScript中，执行合约就像运行一个应用一样简单</li>
<li>在Solidity 中，总之也是很方便</li>
</ol>
</li>
<li>test文件是从根目录中可以找打到，Truffle只会运行.js, .es, .es6, and .jsx, and .sol这几个文件，其他会被忽略<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2></li>
<li>运行   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truffle develop  &#x2F;&#x2F;进入环境（若已经在项目根目录下进入该环境，则不需要执行该命令）</span><br><span class="line">test  &#x2F;&#x2F;该环境中测试</span><br></pre></td></tr></table></figure></li>
<li>也可指定路径  <pre><code>test ./path/to/test/file.js</code></pre>
<h2 id="独立的运行环境"><a href="#独立的运行环境" class="headerlink" title="独立的运行环境"></a>独立的运行环境</h2>运行测试文件时，Truffle提供了一个独立的环境，确保每个测试不会被干扰<h2 id="快速和可靠性"><a href="#快速和可靠性" class="headerlink" title="快速和可靠性"></a>快速和可靠性</h2>一句话翻译：测试速度老快了，而且老安全了。  </li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第6讲 发布合约</title>
    <url>/articles/615df6fa/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>migrations说白了就是将编译好的智能合约移到网上</li>
<li>truffle项目的根目录中，会找到一个名叫migrations目录：  </li>
<li>该目录中都是javascript文件，用于将智能合约发布到以太坊网上</li>
<li>中文翻译migrate，叫做移植，或者是发布，后面就都这么称呼了</li>
<li>就是说，需要再该目录下，编辑一些发布文件，这样才能将合约部署到以太坊上</li>
</ol>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>为了运行migrations目录，同样是在项目根目录下，输入如下命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle develop  //进入环境（若已经在项目根目录下进入该环境，则不需要执行该命令）</span><br><span class="line">migrate  //该环境中发布，migrate可以指定发布网络，网络在truffle.js中：migrate —live</span><br></pre></td></tr></table></figure>
<p>运行后，在migrations中的所有文件都会被执行。<br>如果你之前已经运行过，则将从上次运行的位置开始执行。<br>若其中的文件没有改变，则该命令不生效。<br>可以加入—reset配置，则可覆盖重新运行该命令。<br><img src="/doc/img/truffle/6-1.png" width = "300" height = "150"/></p>
<h2 id="初始化发布"><a href="#初始化发布" class="headerlink" title="初始化发布"></a>初始化发布</h2><ol>
<li>综述：<br>我先大概解释下，要不然后面看的一脸懵逼，按我的理解，就是初始化truffle项目的时候，contracts目录中会自动生成一个叫做<em>Migrations.sol</em>的智能合约文件，然后你需要按照“迁移文件（下面介绍）”的规则实现具体的迁移，其中需要引用到该Migrations.sol中的合约，否则移植功能无法实现。<br>下面的内容都是官方的翻译，基本就是我这句话的意思。</li>
<li>Truffle需要你有一个发布合约以便可以使用提供的移植功能。这个合约必须包含一个特殊的接口，但是你按照你的想法任意修改合约。对于大多数项目，这个合约将会作为第一次迁移进行部署，并且不会再被更新。<br>另外，这个发布合约在你使用truffle init命令时候，就会被创建出。然后你就可以按着你的想法在里面进行调整了。默认创建的该移植合约如下：<br>文件地址：<strong>项目根目录/contracts/Migrations.sol</strong>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.17;</span><br><span class="line"></span><br><span class="line">contract Migrations &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint public last_completed_migration;</span><br><span class="line"></span><br><span class="line">  modifier restricted() &#123;</span><br><span class="line">    if (msg.sender &#x3D;&#x3D; owner) _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Migrations() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setCompleted(uint completed) public restricted &#123;</span><br><span class="line">    last_completed_migration &#x3D; completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function upgrade(address new_address) public restricted &#123;</span><br><span class="line">    Migrations upgraded &#x3D; Migrations(new_address);</span><br><span class="line">    upgraded.setCompleted(last_completed_migration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>请注意！：<br>你必须在你第一次发布时候，部署上面的Migrations合约，这样才能移植功能才能生效。为此，你必须创建一个移植文件，类似如下：</li>
</ol>
<p><strong>文件名：migrations/1_initial_migration.js</strong><br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Migrations = artifacts.require(<span class="string">&quot;./Migrations.sol&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(Migrations);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    <strong>备注</strong>：<br>    1. 文件名需要以数字开头，之后的文件名随意。需要数字编号，才能知道记录迁移是否成功。<br>    2. artifacts.require(“MyContract”)：<br>在开始移植前，我们会通过该方法告诉Truffle，我们想和哪个合约进行交互。这个方法类似于nodejs中的require，但是在这里，它可以返回一个合约的抽象层，我们可以在我们发布的其余脚本中使用该合约抽象层。<br>    3. 注意：传入的MyContract必须是指具体的合约，而不是一个合约文件名（因为一个文中可能有多个合约）。<br>    4. module.exports：<br>所有的迁移必须通过module.exports语法导出一个函数。每个导出的函数必须接受一个deployer对象作为它的第一个参数。该对象提供了一个清晰的语法结构，同时提供了一些通用的职责（比如保存发布的文件，以备稍后使用）<br>    5. deployer对象是用来缓存发布任务的主要操作接口，这些接口稍后介绍。<br>4. 可以依照编号继续创建新的发布</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol>
<li>你的迁移文件被deployer放到部署任务中，，你可以同步编写部署任务，deployer将会按照顺序继续执行：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure></li>
<li>或者也可以按照如下方式进行部署   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy A, then deploy B, passing in A&#x27;s newly deployed address</span></span><br><span class="line">deployer.deploy(A).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> deployer.deploy(B, A.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="网络考虑"><a href="#网络考虑" class="headerlink" title="网络考虑"></a>网络考虑</h2></li>
<li>根据网络条件部署，这是一项高级功能，请先参考：第15讲 网络和app发布</li>
<li>要考虑网络，则需要按如下编写迁移文件   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer, network</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (network == <span class="string">&quot;live&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something specific to the network named &quot;live&quot;.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Perform a different step otherwise.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可用账户"><a href="#可用账户" class="headerlink" title="可用账户"></a>可用账户</h2>移植文件可以通过客户端或者web3返回一些账户列表如下：  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer, network, accounts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Use the accounts within your migrations.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2>deployer中包含有很多可以简化移植的功能  </li>
<li>deployer.deploy(合同，参数…选项)<br>用于部署一个具体的合同，其中涉及到传入一个合约，还有一些特定的参数。这对单例合约是很有用的，在整个dapp中，只会被实例化一次。</li>
<li>你可以部署一个或者一组合约，以便加速合约的部署。对于第二个参数，可以包含指定的键名（例如：overwrite）或者别的参数(如：gas、from)，如果overwrite设置为false，则表示不会覆盖，不执行该合约。</li>
<li>请注意，在调用deploy部署前，你需要先部署和链接（关于链接，看下一节）好你所依赖的库，   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy a single contract without constructor arguments</span></span><br><span class="line">deployer.deploy(A);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy a single contract with constructor arguments</span></span><br><span class="line">deployer.deploy(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t deploy this contract if it has already been deployed</span></span><br><span class="line">deployer.deploy(A, &#123;<span class="attr">overwrite</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a maximum amount of gas and `from` address for the deployment</span></span><br><span class="line">deployer.deploy(A, &#123;<span class="attr">gas</span>: <span class="number">4612388</span>, <span class="attr">from</span>: <span class="string">&quot;0x....&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy multiple contracts, some with arguments and some without.</span></span><br><span class="line"><span class="comment">// This is quicker than writing three `deployer.deploy()` statements as the deployer</span></span><br><span class="line"><span class="comment">// can perform the deployment as a single batched request.</span></span><br><span class="line">deployer.deploy([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">   B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);  </span><br><span class="line"><span class="comment">// External dependency example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For this example, our dependency provides an address when we&#x27;re deploying to the</span></span><br><span class="line"><span class="comment">// live network, but not for any other networks like testing and development.</span></span><br><span class="line"><span class="comment">// When we&#x27;re deploying to the live network we want it to use that address, but in</span></span><br><span class="line"><span class="comment">// testing and development we need to deploy a version of our own. Instead of writing</span></span><br><span class="line"><span class="comment">// a bunch of conditionals, we can simply use the `overwrite` key.</span></span><br><span class="line">deployer.deploy(SomeDependency, &#123;<span class="attr">overwrite</span>: <span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li>deployer.link(library,destinations)用于将一个已经部署的library连接到一个或者多个合约。<br>destinations，目的地，可以是一个或者多个合约，如果目的地不含有效的库，则忽略   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deploy library LibA, then link LibA to contract B, then deploy B.</span></span><br><span class="line">deployer.deploy(LibA);</span><br><span class="line">deployer.link(LibA, B);</span><br><span class="line">deployer.deploy(B);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link LibA to many contracts</span></span><br><span class="line">deployer.link(LibA, [B, C, D]);</span><br></pre></td></tr></table></figure></li>
<li>deployer.then(function(){…})<br>运行任意一个步骤。在移植过程中使用它来调用特定的合同功能，以添加，编辑和重新组织合同数据。   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">deployer.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create a new version of A</span></span><br><span class="line">  <span class="keyword">return</span> A.new();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  a = instance;</span><br><span class="line">  <span class="comment">// Get the deployed instance of B</span></span><br><span class="line">  <span class="keyword">return</span> B.deployed();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  b = instance;</span><br><span class="line">  <span class="comment">// Set the new instance of A&#x27;s address on B via B&#x27;s setA() function.</span></span><br><span class="line">  <span class="keyword">return</span> b.setA(a.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第5讲 编译合约</title>
    <url>/articles/fad85707/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>小编使用的是Truffle Develope环境，因此，关于项目编译的命令，都没有加上前缀truffle，若使用Ganache环境，请加上该前缀，具体可参考其中的描述：第4讲 选择一个以太坊客户端</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><ul>
<li>在/contracts中，所有的智能合约原文件都在这里（后缀为.sol的文件）</li>
<li>在/contracts中，有一个默认的Migrations.sol文件，它是用来协助部署的。</li>
</ul>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>为了编译truffle项目，需要先进入到项目根目录，然后输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle develop  //进入环境</span><br><span class="line">compile  //该环境中编译</span><br></pre></td></tr></table></figure>
<p>当你第一次编译的时候，所有的合约都会被编译；<br>当再次编译的时候，只会编译改动过的合约文件；<br>如果要覆盖重新编译，则需要输入配置项：–all</p>
<h2 id="编译出的文件"><a href="#编译出的文件" class="headerlink" title="编译出的文件"></a>编译出的文件</h2><p>编译生成的文件会被放在/build/contracts目录中，不可以修改其中的文件</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>可以使用import命令来申明合约的依赖关系，truffle会依照正确的顺序编译合同，并且确保所有的依赖关系发送给编译器，可以使用两种方式指定依赖  </p>
<ol>
<li>通过文件名导入依赖<br>要从单独的文件导入别的合约，需要填入如下代码到你的当前合约源文件中：   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="string">&quot;./AnotherContract.sol&quot;</span></span><br></pre></td></tr></table></figure>
 这将会使得AnotherContract.sol中的合约都生效</li>
<li>从现有的包中导入合约，  <ol>
<li>truffle支持从EthPM或者npm安装的包文件中导入的合约，在你当前编辑的合约中加入（编译时，truffle会先检索EthPM的包，然后才是npm的）：  <pre><code>import &quot;somepackage/SomeContract.sol&quot;</code></pre>
</li>
<li>EthPM没用过。。。自行网上搜索吧  </li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第3讲 创建项目</title>
    <url>/articles/39ce2b06/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官方和社区已有项目应用地址：<a href="http://truffleframework.com/boxes/metacoin">http://truffleframework.com/boxes/metacoin</a>  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>从头开始项目建立空项目  <ol>
<li>创建和初始化：   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir testproject</span><br><span class="line"><span class="built_in">cd</span> testproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure></li>
<li>目录结构：   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">print</span> | sed -e <span class="string">&#x27;s;[^/]*/;|____;g;s;____|; |;g’ //mac环境</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第4讲 选择一个以太坊客户端</title>
    <url>/articles/dbe1bf88/</url>
    <content><![CDATA[<h1 id="第4讲-选择一个以太坊客户端"><a href="#第4讲-选择一个以太坊客户端" class="headerlink" title="第4讲_选择一个以太坊客户端"></a>第4讲_选择一个以太坊客户端</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>需要选择一个以太坊客户端环境来测试truffle项目  </p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>truffle推荐我们使用三种测试使用的客户端（小编选择第二种方式了，再安装别的，电脑就要爆了）  </p>
<ol>
<li>Ganache（图形界面）  <ol>
<li>以前我们使用的是testrpc环境，但是Truffle建议我们使用Ganache，也就是testrpc的升级版，它已经取代了testrpc</li>
<li>需要单独安装，安装地址：<a href="http://truffleframework.com/ganache">http://truffleframework.com/ganache</a></li>
<li>Ganache优点  <ol>
<li>它简化了dapp的开发，可以快速的了解truffle项目是怎样影响区块链，</li>
<li>查看账户、余额、合同创建以及gas成本等细节。</li>
<li>可以对挖矿进行微调</li>
</ol>
</li>
<li>启动后，Ganache是运行在：<a href="http://127.0.0.1:7545地址下。它将会展示前10个默认账户以及每个账户对应的助记符（mnemonic，毕竟原始账户一个那么长的字符串，很难记忆，改成助记符得方便很多）">http://127.0.0.1:7545地址下。它将会展示前10个默认账户以及每个账户对应的助记符（mnemonic，毕竟原始账户一个那么长的字符串，很难记忆，改成助记符得方便很多）</a></li>
<li>另外：  <ol>
<li>不要在公网使用助记符，会丢失你的财产  </li>
<li>助记符参考地址：<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki</a></li>
</ol>
</li>
</ol>
</li>
<li>Truffle Develop  <ol>
<li>默认端口号是9545</li>
<li>Truffle内置的一个客户端，不需要单独安装，使用如下命令即可进入该环境：  <pre><code class="bash">truffle develop</code></pre>
 <img src="/articles/dbe1bf88/1.png" class="" title="启动界面"></li>
<li>启动后，就像前面提到的Ganache，同样会给出助记符</li>
<li>之后就可以输入truffle相关命令了<br>注意：Ganache中环境中，每个命令都要加上前缀truffle，但是在Truffle Develop环境中，不需要。</li>
</ol>
</li>
<li>Ganache 命令行<br>略，小编用第二种方式就够了</li>
</ol>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第2讲 安装</title>
    <url>/articles/4926f4e0/</url>
    <content><![CDATA[<ul>
<li>这是mac版安装方式，其余linux可参考<a id="more"></a></li>
<li>是以太坊最受欢迎的一个框架，需要nodejs支持，安装nodejs  <ul>
<li>nodejs安装    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure></li>
<li>使用npm安装到所有model都在这个路径路径：/usr/lib/node_modules</li>
<li>下载并安装truffle    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g truffle  //其中-g参数指定将包安装到全局环境中。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>查看truffle版本    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truffle version</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
  <entry>
    <title>(truffle官翻)第1讲 概述</title>
    <url>/articles/1e5b5f1/</url>
    <content><![CDATA[<ul>
<li>参考官网文档：<a href="http://truffleframework.com/docs/">http://truffleframework.com/docs/</a></li>
<li>truffle的作用，基本一句话：是用来编译、测试、部署智能合约的工具，使用起来非常方便。</li>
<li>建议有智能合约编写基础再来看本教程，参考官网：<a href="http://truffleframework.com/">http://truffleframework.com/</a></li>
<li>truffle版本：4.1.3</li>
<li>solidity:0.4.19</li>
</ul>
]]></content>
      <categories>
        <category>以太坊</category>
        <category>truffle</category>
        <category>官翻</category>
      </categories>
      <tags>
        <tag>ethereum</tag>
        <tag>truffle</tag>
      </tags>
  </entry>
</search>

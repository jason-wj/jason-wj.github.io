---
title: (白话密码学基础)第2讲-序列密码
mathjax: true
copyright: true
original: true
explain: 文中可能会根据需要做部分调整
date: 2018-04-03 16:33:49
categories: [原创,密码学,基础]
tags: [cryptology]
---
## 概述
上一章提到，对称密码学分为分组密码和序列密码两部分：
* 序列密码：
序列密码单独加密。它通过将密钥序列中的每个位与每个明文位相加实现的。它有`同步序列密码`和`异步序列密码`之分，前者只取决于密钥，而后者取决于密钥和密文。大多数加密算法都是异步的。
<!-- more --> 
* 分组密码
分组密码每次使用相同的密钥加密整个明文位分组。这意味着对给定分组内任何明文位的加密都依赖于与它同在一个分组内的其它所有的明文位。此类加密的算法有：高级加密标准(AES)，数据加密标准（DES），三重DES

这两种加密方式的区别还是很明显的，大家可以去网上找找，进一步了解两者的区别。
本章主要讲序列密码相关。分组密码在之后章节中会逐一介绍。

## 序列密码的加密和解密
`定义如下：`
明文、密文和密钥序列都是由单独的位组成即$x_i,y_i,s_i\ \in\ ${0,1}。
**加密：** $y_i=e_{s_i}(x_i)\ \equiv\ (x_i\ +\ s_i)\ mod\ 2$
**解密：** $x_i=d_{s_i}(y_i)\ \equiv\ (y_i\ +\ s_i)\ mod\ 2$
小编在此举个例子来让大家更直观的熟悉下这个序列密码的定义：
* `初始：`
    s密钥：0 1 0 1 0 1
    x原文：1 1 0 1 0 0
* `求密文y：`
需要用到上一章`模运算`概念，得出，这里小编演示下前两位的计算过程：
s密钥和x原文第1位相加，再套用加密规则为：(0+1) mod 2，即1 mod 2，因此密文第2位为1。
s密钥和x原文第2位相加，再套用加密规则为：(1+1) mod 2，即2 mod 2，根据上一章最小$\gamma$的计算规则，得出$\gamma\ =\ 0$，因此密文第2位为0。
y密文：1 0 0 0 0 1
* `破解出明文`：
用`模运算`调用序列密码解密规则，求出原文。
* `此加密解密过程本质上是异或过程。`

呵呵，根据上面的案例，可以总结出此序列密码的特点：
1. 每一位密文为对应的mod的最小余数
2. 加密和解密用的同一个密钥，是为了保证加密和解密都顺利，有兴趣的可以证明一下去：把加密公式带入到解密公式里。
3. 密钥长度和原文一样长
4. 使用模2的好处是，得出的结果只有0,1两种结果。可以将算数运算看作是布尔函数，比如与门（AND）、或门（OR）、与非门（NAND）等。
5. 密钥的本质是随机数，让攻击者看不出规律来。

## 随机数与密码

### 随机数生成器（RNG）
由上一小节可以，为了确保安全，密钥的随机性是很重要的。这里小编主要介绍三种随机数生成器：
* **真随机数生成器（TRNG）**
可以这么说，这种生成器最大的特点就是不可复制，比如：随机抛硬币100次，得出的顺序，基本是没可能再重现一次的。再比如掷骰子、抖动频率等物理现象，基本都是唯一的。
* **伪随机数生成器（PRNG）**
这个搞开发的应该都熟悉，基于某个种子点而生成的数据，java等等的random函数，都是基于这个原理实现的。各行各业一般都是用这一方法来实现随机的。具体公式如下：
$$
s_0=seed\\\
s_{i+1}\ \equiv\ f{s_i},i=0,1,...
$$

    最常见的是一种线性同余生成器：
$$
s_0=seed\\\
s_{i+1}\ \equiv\ a{s_i} + b mod m,i=0,1,...
$$
    这种生成器的特点是：可以根据$s_i$推算出$s_{i-1}$、$s_{i-2}$、$s_{i-3}$...，也可以推算出$s_{i+1}$、$s_{i+2}$、$s_{i+3}$...等。
* **加密安全的伪随机数生成器（CSPRNG）**
CSPRNG是PRNG的一种特例，这种特例一般只在密码学验证中使用，在工程中一般不用。概念比较冷僻，但很好理解：
无法根据$s_i$推算出$s_{i-1}$、$s_{i-2}$、$s_{i-3}$...，也不可以推算出$s_{i+1}$、$s_{i+2}$、$s_{i+3}$...等。
在密码学领域，这种状态更为理想。

### TRNG的应用：一次一密
TRNG为什么很少被应用，这一小节就会给出答案，且听小编慢慢道来。
首先定义一个完美的密钥应该具有的特性，即`无条件安全`：
`如果一个密码体制在无限计算资源的情况下也不能被破译，则说明它是无条件看全的或信息理论上安全的。`
概念很简单，但实现却很难，要知道，一般情况下，即使密码再复杂，也能够用大量计算在某一天将结果运算出来。
看看目前已经构建出来的一个称为`一次一密`的密码机制：
`一个序列密码称为一次一密，必须满足以下几个要求：`
`1. 通过真随机数生成器得到密钥序列`$s_0,s_1,s_2,...$
`2. 只有合法的通信才知道密钥序列`
`3. 每个密码序列位s_i仅使用一次。`
用公式表示：$y_{密文第i位}\ \equiv\ x_(明文第i位)\ s_{密钥第i位}\ mod\ 2$，可以这么理解：`密钥的每一位都是随机的，无法确定出一个规则来获取，并且若不知道加密后的密文的话，想获取明文是不可能的。`
下面小编来解读一下这三个要求：
1. TRNG真随机数生成，上一节已经讲了，需要依托物理设备来实现，一般PC机并不满足。
2. 能把密钥安全的送到对方，呵呵，这只能是脱离网络，想尽别的方式来尽量保证安全了。
3. 明文的每一个字符都需要用密钥对应的每一位来加密，也就是说，密钥长度和明文长度是一样的。自然，若要有新的明文，则需要重新走一遍这些流程。
一次一密的加密方式，这下应该明白有哪些不足之处了吧，每个要求也就是它的每个不足之处，正是它苛刻的要求，除非需要绝对的安全（如冷战期间的通信，当时就用的这种方式），否则一般是不会考虑的。

### PRNG、CSPRNG应用-实际序列密码
为了能够更好的再现实生活中应用密码，我们一般是用伪随机数来代替真随机数的，这样我们就需要一个种子`k`（种子的作用：用于给密钥生成做参考，也就是说，密钥是依据一个固定的值k，来生成的）。
可以这么说，`实际应用的加密算法(序列密码、分组密码、公钥算法等)，都不是**无条件安全**的`。我们唯一能够期待的就是`计算安全`：






### 关于实际序列密码



呵呵，，有时间在写，，


---
title: 公钥算法的基本数论-欧几里得算法
mathjax: true
copyright: true
original: true
top: false
notice: false
categories:
  - 原创
  - 密码学
  - 基础
tags:
  - cryptology
abbrlink: cea59c37
date: 2018-11-05 11:35:10
authorship:
srcpath:
---
## 前言
该算法是非对称密码学算法理论中的一部分，还是很有必要掌握的
<!-- more -->
## 最大公约数(gcd)
两个正整数$r_0$和$r_1$的$gcd$表示为
$$
gcd(r_0,r_1)
$$

## 欧几里得算法
为了更方便的对大整数进行最大公约数计算，通常使用的是欧几里得算法。
接下来逐步实现证明这个算法。

### 定理
两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。

### 一个简单的观察
欧几里得算法是基于一个简单的观察来实现的，先来看这样一个公式：
$$
gcd(r_0,r_1) = gcd(r_0-r_1,r_1)
$$
其中$r_0 > r_1$，并且两个数均为正整数。
证明该公式的过程：
假设$gcd(r_0,r_1)=g$，由于$g$可以同时处以$r_0$和$r_1$，则可以记作$r_0=g \cdot x$和$r_1=g \cdot y$，其中x>y，且x和y为互素的整数，即它们没有公共因子。也就是说：
$$
gcd(r_0-r_1,r_1) = gcd(g \cdot (x-y),g \cdot y)=g
$$
结合前面已经得知$gcd(r_0,r_1)=g$，综合可知：
$$
\begin{cases}
gcd(r_0-r_1,r_1) = gcd(g \cdot (x-y),g \cdot y)=g \\\
gcd(r_0,r_1)=g
\end{cases}
$$
因此，证明结果成立。

### 得出欧几里得算法的原理
只要满足$r_0-mr_1>0$,迭代使用这个过程可以得到：
$$
gcd(r_0,r_1)=gcd(r_0-r_1,r_1)=gcd(r_0-2r_1,r_1)= ... = gcd(r_0-mr_1,r_1)
$$
如果m选择了最大值，则此算法使用的步骤也是最少的，这种情况可以表示为：
$$
gcd(r_0,r_1)=gcd(r_0 \bmod r_1,r_1)
$$
由于第一项($r_0 \bmod r_1$)比第二项$r_1$小，通常可以交换它们：
$$
gcd(r_0,r_1)=gcd(r_1,r_0 \bmod r_1)
$$
交换后，继续迭代计算，每一轮都保留了上一轮迭代的结果（每一轮结果都要交换，确保gcd第一项大于第二项），直到最后：$gcd(r_k,0)=r_k$,也就是：
$$
gcd(r_0,r_1)=...=gcd(r_k,0)=r_k
$$

### golang代码实现
```golang
package main

import "fmt"
//欧几里得算法，也就是辗转相除法

var (
	val1 int
	val2 int
	tmp  int
)

func main() {
	fmt.Scanln(&val1, &val2)
	for val2 != 0 {
		tmp = val2
		val2 = val1 % val2
		val1 = tmp
	}
	fmt.Printf("result:%d", val1)
}
```

## 扩展的欧几里得算法（EAA）
欧几里得算法的主要应用不是计算gcd，而是用来计算模逆元的，而模逆元在公钥密码学中占有举足轻重的地位。

## EAA概述
公式如下：
```math
gcd(r_0,r_1) = s \cdot r_0 + t \cdot r_1
```
其中$s$和$t$均表示整型系数，这个等式通常也称为丢番图方程。
上面的方程推导思路：
在标准欧几里得方程中，每一轮的计算中，我们都进行如下操作：
```math
r_i=s_ir_0+t_ir_1
```
则在最后一轮结果中得到的$s$和$t$就是我们需要的结果。

### 详细推导过程
1. 在标准欧几里得算法中的连续两轮有如下结果：
```math
\begin{aligned}
r_{i-2}=s_{i-2}r_0+t_{i-2}r_1 \\
r_{i-1}=s_{i-1}r_0+t_{i-1}r_1
\end{aligned}
```
2. 在第i轮计算中，首先要通过标准欧几里得计算得知：
```math
r_{i-2}=q_{i-1}*r_{i-1}+r_i
```
该公式最终可转换为：
```math
r_i=r_{i-2}-q_{i-1} \cdot r_{i-1}
```
3. 结合`1`和`2`中公式可得：
```math
r_i=(s_{i-2}r_0+t_{i-2}r_1)-q_{i-1}(s_{i-1}r_0+t_{i-1}r_1)
```
该公式最终转换为：
```math
r_i=[s_{i-2}-q_{i-1}s_{i-1}]r_0+[t_{i-2}-q_{i-1}t_{i-1}]r_1
```
4. 得出最终公式：
将`3`中得到的公式和本节最初给出的公式：
```math
r_i=s_ir_0+t_ir_1
```
`ps:这个公式可知，初始化参数为：`$s_0=1,s_1=0,t_0=0,t_1=1$

然后，得到了最终我们需要的结果：
```math
\begin{aligned}
s_i=s_{i-2}-q_{i-1}s_{i-1} \\
t_i=t_{i-2}-q_{i-1}t_{i-1}
\end{aligned}
```

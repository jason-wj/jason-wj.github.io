---
title: 公钥算法的基本数论-欧几里得算法
mathjax: true
copyright: true
original: true
top: false
notice: false
categories:
  - 原创
  - 密码学
  - 基础
tags:
  - cryptology
abbrlink: cea59c37
date: 2018-11-05 11:35:10
authorship:
srcpath:
---
## 前言
该算法是非对称密码学算法理论中的一部分，还是很有必要掌握的
<!-- more -->
## 最大公约数(gcd)
两个正整数$r_0$和$r_1$的$gcd$表示为
$$
gcd(r_0,r_1)
$$

## 欧几里得算法
为了更方便的对大整数进行最大公约数计算，通常使用的是欧几里得算法。
接下来逐步实现证明这个算法。

### 定理
两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。

### 一个简单的观察
欧几里得算法是基于一个简单的观察来实现的，先来看这样一个公式：
$$
gcd(r_0,r_1) = gcd(r_0-r_1,r_1)
$$
其中$r_0 > r_1$，并且两个数均为正整数。
证明该公式的过程：
假设$gcd(r_0,r_1)=g$，由于$g$可以同时处以$r_0$和$r_1$，则可以记作$r_0=g \cdot x$和$r_1=g \cdot y$，其中x>y，且x和y为互素的整数，即它们没有公共因子。也就是说：
$$
gcd(r_0-r_1,r_1) = gcd(g \cdot (x-y),g \cdot y)=g
$$
结合前面已经得知$gcd(r_0,r_1)=g$，综合可知：
$$
\begin{cases}
gcd(r_0-r_1,r_1) = gcd(g \cdot (x-y),g \cdot y)=g \\\
gcd(r_0,r_1)=g
\end{cases}
$$
因此，证明结果成立。

### 得出欧几里得算法的原理
只要满足$r_0-mr_1>0$,迭代使用这个过程可以得到：
$$
gcd(r_0,r_1)=gcd(r_0-r_1,r_1)=gcd(r_0-2r_1,r_1)= ... = gcd(r_0-mr_1,r_1)
$$
如果m选择了最大值，则此算法使用的步骤也是最少的，这种情况可以表示为：
$$
gcd(r_0,r_1)=gcd(r_0 \bmod r_1,r_1)
$$
由于第一项($r_0 \bmod r_1$)比第二项$r_1$小，通常可以交换它们：
$$
gcd(r_0,r_1)=gcd(r_1,r_0 \bmod r_1)
$$
交换后，继续迭代计算，每一轮都保留了上一轮迭代的结果（每一轮结果都要交换，确保gcd第一项大于第二项），直到最后：$gcd(r_k,0)=r_k$,也就是：
$$
gcd(r_0,r_1)=...=gcd(r_k,0)=r_k
$$

### golang代码实现
```golang
package main

import "fmt"
//欧几里得算法，也就是辗转相除法

var (
	val1 int
	val2 int
	tmp  int
)

func main() {
	fmt.Scanln(&val1, &val2)
	for val2 != 0 {
		tmp = val2
		val2 = val1 % val2
		val1 = tmp
	}
	fmt.Printf("result:%d", val1)
}
```

---
title: 以太坊源码解读-第5.3讲-http rpc的启动流程分析
mathjax: false
copyright: true
original: true
top: false
notice: false
abbrlink: 5e9143bf
date: 2018-11-07 18:27:55
categories:
  - 原创
  - 以太坊
  - 源码解读
tags:
  - ethereum
---
## 前言
以太坊中，总共有四种rpc服务，分别是`InProc`、`IPC`、`Http`、`Ws`，本文是通过介绍`Http rpc`的整个过程来了解以太坊rpc的情况。
<!-- more -->

## 启动过程

### http的配置
1. 先按如下顺序来找到这么个入口：
`cmd->geth->main.go->app.Run(os.Args)->geth->makeFullNode(ctx)->makeConfigNode(ctx)`
这个主要是完成以太坊的启动配置过程，这块的大意是，对`Eth模块`、`Shh模块`、`Node模块`、`Dashboard模块`进行配置，先给他们提供默认配置，然后检查是否有用户自定义的`toml`配置文件，若有，则覆盖默认配置，在此选择用默认配置。
2. 先要说明一下，http相关配置是在`Node模块`中进行的，最后其余所有的模块都是注册到`Node模块中`，`Node`结构大体如下：
  ```go
  type Node struct {
    ...
    config   *Config          // http相关主要就是在该Config中配置的
    services     map[reflect.Type]Service // 当前正在运行的服务（模块），以太坊把每个模块的功能都统一成service，然后注册到node.services中
    rpcAPIs       []rpc.API   // 所有模块的rpcAPIs都放在其中统一管理
    //http相关其余配置
    httpEndpoint  string       // HTTP endpoint (interface + port) to listen at (empty = HTTP disabled)
    httpWhitelist []string     // HTTP RPC modules to allow through this endpoint
    httpListener  net.Listener // HTTP RPC listener socket to server API requests
    httpHandler   *rpc.Server  // HTTP RPC request handler to process the API requests
    ...
  }
  ```
  {% asset_img 1.png  geth启动过程 %}

3. 这里我们主要关心http的配置，直接看对`Node模块`配置情况：`defaultNodeConfig`以及`defaultNodeConfig->node.DefaultConfig`，其中有对http的基本配置，具体解释看下面代码注释：
```go
func defaultNodeConfig() node.Config {
	cfg := node.DefaultConfig
	cfg.Name = clientIdentifier
	cfg.Version = params.VersionWithCommit(gitCommit)
  cfg.HTTPModules = append(cfg.HTTPModules, "eth", "shh")
  //在已有的modules基础上，再加上eth shh两个模块
	cfg.WSModules = append(cfg.WSModules, "eth", "shh")
	cfg.IPCPath = "geth.ipc"
	return cfg
}

var DefaultConfig = Config{
  // 节点信息默认的存放位置，mac、windows、others三个平台
  DataDir:          DefaultDataDir(),
  // HTTP RPC server的默认端口，8545
  HTTPPort:         DefaultHTTPPort,
  // 默认rpcapi接口提供方式，标示，其实就是api.namespace
  HTTPModules:      []string{"net", "web3"},
  // 虚拟主机地址
  HTTPVirtualHosts: []string{"localhost"},
  // 下面whisper和p2p相关，暂不考虑
	WSPort:           DefaultWSPort,
	WSModules:        []string{"net", "web3"},
	P2P: p2p.Config{
		ListenAddr: ":30303",
		MaxPeers:   25,
		NAT:        nat.Any(),
	},
}
```
此步我们可以看出，http modules默认总共有`net`、`web3`、`eth`、`shh`四类的rpcapi，

4. http的进一步配置
`makeConfigNode(ctx)->utils.SetNodeConfig(ctx, &cfg.Node)->setHTTP(ctx, cfg)`，在其中可以发现，其余默认的一些配置：
```go
func setHTTP(ctx *cli.Context, cfg *node.Config) {
	if ctx.GlobalBool(RPCEnabledFlag.Name) && cfg.HTTPHost == "" {
		cfg.HTTPHost = "127.0.0.1"
		if ctx.GlobalIsSet(RPCListenAddrFlag.Name) {
			cfg.HTTPHost = ctx.GlobalString(RPCListenAddrFlag.Name)
		}
	}

	if ctx.GlobalIsSet(RPCPortFlag.Name) {
		cfg.HTTPPort = ctx.GlobalInt(RPCPortFlag.Name)
	}
	if ctx.GlobalIsSet(RPCCORSDomainFlag.Name) {
		cfg.HTTPCors = splitAndTrim(ctx.GlobalString(RPCCORSDomainFlag.Name))
	}
	if ctx.GlobalIsSet(RPCApiFlag.Name) {
		cfg.HTTPModules = splitAndTrim(ctx.GlobalString(RPCApiFlag.Name))
	}
	if ctx.GlobalIsSet(RPCVirtualHostsFlag.Name) {
		cfg.HTTPVirtualHosts = splitAndTrim(ctx.GlobalString(RPCVirtualHostsFlag.Name))
	}
}
```
4. 注册
返回到`cmd->geth->main.go->app.Run(os.Args)->geth->makeFullNode(ctx)`，其余配置好的模块（或者叫做服务）,都会被注册到`Node`中

5. 总结
`cmd->geth->main.go->app.Run(os.Args)->geth->makeFullNode(ctx)`主要做了两件事：
  1. 配置模块
  2. 注册模块到node

### 启动http rpc过程
1. 前往：
`cmd->geth->main.go->app.Run(os.Args)->geth->makeFullNode(ctx)->startNode(ctx, node)->utils.StartNode(stack)->stack.Start()->n.startRPC(services)`中，找到：
`n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts);`，这一行就是用来启动http rpc的，看看它所需要的4个参数：
  1. n.httpEndpoint，默认值为127.0.0.1
  2. apis，默认值为所有的服务的api
  3. n.config.HTTPModules，rpcapi的标示，前面提到过，默认给出：["eth","shh","net","web3"]
  4. n.config.HTTPCors 跨域资源共享，由外部输入
  5. n.config.HTTPVirtualHosts 防攻击的设置，官方有解释，可以去看看，限制访问范围，默认：localhost
2. startHTTP还是很重要的，这里列出源码和注释：
```go
//初始化http以及启动http rpc服务
func (n *Node) startHTTP(endpoint string, apis []rpc.API, modules []string, cors []string, vhosts []string) error {
	// endpoint必须有
	if endpoint == "" {
		return nil
	}
	// 白名单其实就是modules，默认给出：["eth","shh","net","web3"]
	whitelist := make(map[string]bool)
	for _, module := range modules {
		whitelist[module] = true
	}
	// 创建一个rpc server，并且注册服务，要求满足白名单条件
	handler := rpc.NewServer()
	for _, api := range apis {
		if whitelist[api.Namespace] || (len(whitelist) == 0 && api.Public) {
			if err := handler.RegisterName(api.Namespace, api.Service); err != nil {
				return err
			}
			n.log.Debug("HTTP registered", "service", api.Service, "namespace", api.Namespace)
		}
	}
	// All APIs registered, start the HTTP listener
	var (
		listener net.Listener
		err      error
	)
	if listener, err = net.Listen("tcp", endpoint); err != nil {
		return err
  }
  //启动 rpc
	go rpc.NewHTTPServer(cors, vhosts, handler).Serve(listener)
	n.log.Info("HTTP endpoint opened", "url", fmt.Sprintf("http://%s", endpoint), "cors", strings.Join(cors, ","), "vhosts", strings.Join(vhosts, ","))
	// All listeners booted successfully
	n.httpEndpoint = endpoint
	n.httpListener = listener
	n.httpHandler = handler

	return nil
}
```
至此，http rpc完全启动，其余的几种rpc也类似，在此就不分析了。

## 总结
原本打算把具体的rpc流程也顺带讲一下，但混在一起会乱，就先不提了。
本文梳理后，可以很清晰的了解到，以太坊是如何启动一项rpc服务的，为我们后来进一步研究rpc做了一些充分的准备。




---
title: 以太坊vm系列2-基础篇
mathjax: false
copyright: true
original: true
top: false
notice: false
categories:
  - 原创
  - 以太坊
  - 源码解读
tags:
  - ethereum
  - EVM
abbrlink: 4b0172c1
date: 2018-07-18 15:49:03
---
## 前言
vm这东西，要想自己搞公链，这是绕不开的一道坎。
原本想根据黄皮书来逐步了解vm的理念，时间和精力有限，打算结合一些现有的网络资料，编辑整理出自己对vm的理解。Howard是量子链的大神，有幸在以太坊线下沙龙中听了他的演讲，一个字：非常强。回来翻了下他的相关文章，发现他有很完整的以太坊vm讲解的文章，都是英文^^。。。
小编准备结合他的文章来以自己的方式了解到底vm是怎样运行的。

## 概述
一个合约写出来，传到vm后是如何处理的？燃料手续费是怎么样一个逻辑？为什么任意别的语言也可以开发合约？想要开发自己的公链，别的模块怎么和vm对接？等等。。。
带着种种问题，我们没有理由不去了解vm到底是怎么一回事。
好，我们一步步的来揭开这层神秘的面纱

## 解析只有一个变量的合约
solidity编写：
```JavaScript
pragma solidity ^0.4.11;
contract C {
    uint256 a;
    constructor() public {
      a = 1;
    }
}
```
Remix编译（不要说不知道这是什么工具。。。）该合约，
我们获取了EVM字节码：
上面整个合约编辑后的字节码，16进制表示，evm中就是以这个来运行的
```
6080604052348015600f57600080fd5b50600160008190555060358060256000396000f3006080604052600080fd00a165627a7a72305820c2f00be46981ed7116a7d8162fd0cb5c04c4571aa49f5fccbea4b90a5fe8f9290029
```

上面的一坨信息，看的就头大，但不要急，我们先从合约中的简单的存储变量赋值来入手：
```JavaScript
a = 1
```
这个过程的字节码是：`6001600081905550`（先不用考虑怎么得来的），我们通过查看[以太坊vm系列1-指令集汇总](/articles/715e1612)，把它拆成一行一条指令
```armasm
60 01 //60是PUSH1指令，因此后面要跟另一个16进制数
60 00 //同理
81
90
55
50
```
为了更清晰的了解上面的内容，我们用[以太坊vm系列1-指令集汇总](/articles/715e1612)中查出的结果重新描述一下汇编代码：
`stack[]表示栈，store{}表示存储器`(后续均使用此表示)
```armasm
PUSH1 01  //60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]
PUSH1 00  //60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x0 0x1]
DUP2      //81    ，从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x1 0x0 0x1]
SWAP1     //90    ，从栈顶起，将前两个数据交换。此时栈中数据stack[0x0 0x1 0x1]
SSTORE    //55    ，将数值0x01存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x1],存储器数据store{`0x1数值存在0x0地址`}
POP       //50    ，丢弃栈顶数据。此时栈中数据stack[],存储器数据store{`0x1数值存在0x0地址`}
```
从上面分析中可知：Solidity是将`uint256 a`保存在`0x0`的位置上。

仔细观察，会发现`DUP2`、`SWAP1`	、`POP`命令都是多余的，去掉后，会更清晰，并且运行结果也一样：
```armasm
PUSH1 01  //60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]
PUSH1 00  //60 0x0，该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x0 0x1]
SSTORE    //55    ，将数值0x01存储在存储器的0x0的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x1],存储器数据store{`0x1数值存在0x0地址`}
```

## 解析有两个变量的合约
代码如下：
```JavaScript
pragma solidity ^0.4.11;
contract C {
    uint256 a;
    uint256 b;
    constructor() public {
      a = 1;
      b = 2;
    }
}
```
编译后，`b=2`的过程的EVM字节码（a=1前面已解析）：
```
6002600181905550
```
对应的汇编指令：
```armasm
PUSH1 0x2  //60 0x2，该过程可以用0x2表示,它是push(0x2)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x2]
PUSH1 0x1  //60 0x1，该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值2压入栈中。此时栈中数据stack[0x1 0x2]
DUP2       //81，   从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x2 0x1 0x2]
SWAP1      //90，   从栈顶起，将前两个数据交换。此时栈中数据stack[0x1 0x2 0x2]
SSTORE     //55，   将数值0x02存储在存储器的0x1的位置上，此时会消耗掉栈顶的两项数据。此时栈中数据stack[0x2],存储器数据store{`0x02数值存在0x1地址`}
POP        //50，   丢弃栈顶数据。此时栈中数据stack[],存储器数据store{`0x1数值存在0x0地址`,`0x2数值存在0x1地址`}
```

可知，最终：
store{`0x1数值存在0x0地址`,`0x2数值存在0x1地址`}，也就是说a存在0x0地址，b存在0x1地址

## 存储打包
上面案例中，我们将每个数据都保存在了一个地址，其实每个地址可以看作是一个槽，一个槽可以放下32字节的。要是每个16字节的变量分别都放在32字节的不同槽中，会很浪费空间的，要知道手续费可不是闹着玩的。
Solidity提供的优化方案：尽量将小一点的两个数据打包并存储在同一个槽中。
把合约改为如下样子，a和b都使用uint128，也就是16个字节：
```JavaScript
pragma solidity ^0.4.11;
contract C {
    uint128 a;
    uint128 b;
    constructor() public {
      a = 1;
      b = 2;
    }
}
```
编译后，`a=1;b=2;`对应EVM字节码：
```

```
对应汇编指令：
```armasm
PUSH1 0x1                                 //60 0x1，    该过程可以用0x1表示,它是push(0x1)的速记。这条指令将数值1压入栈中。此时栈中数据stack[0x1]
PUSH1 0x0                                 //60 0x0，    该过程可以用0x0表示,它是push(0x0)的速记。这条指令将数值0压入栈中。此时栈中数据stack[0x0 0x1]
DUP1                                      //80，        从栈顶起，将栈中第1个元素复制并加入栈顶。此时栈中数据stack[0x0 0x0 0x1]
PUSH2 0x100                               //61 0x100    占用2个字节，将256压入栈。此时栈中数据stack[0x100 0x0 0x0 0x1]
EXP                                       //0a          从栈顶起，依次取出2个元素，第一个元素为底数，第二个元素为指数，计算出结果为1，然后1字节存储到栈中。此时栈中数据stack[0x1 0x0 0x1]
DUP2                                      //81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0x1 0x0 0x1]
SLOAD                                     //54          检测栈顶元素对应的地址，在db中是否存在值,并读取出,此处db中不存在对应数据，应该是返回0了，push到栈中(这个是猜的。。)。此时栈中数据stack[0x0 0x0 0x1 0x0 0x1]
DUP2                                      //81          从栈顶起，将栈中第2个元素复制并加入栈顶。此时栈中数据stack[0x0 0x0 0x0 0x1 0x0 0x1]
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF //6f 0xFF...  将16字节值0xFF...推入栈中。此时栈中数据stack[0xFF... 0x0 0x0 0x0 0x1 0x0 0x1]
MUL                                       //02          栈中两个元素相乘，结果存入栈中。此时栈中数据stack[0x0 0x0 0x0 0x1 0x0 0x1]
NOT                                       //19
AND                                       //16
SWAP1                                     //90
DUP4                                      //83
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF //6f 0xFF...
AND                                       //16
MUL                                       //02
OR                                        //17
SWAP1                                     //90
SSTORE                                    //55
POP                                       //50
```



>量子链-Howard英文原文：https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30
>xuli中文翻译：https://lilymoana.github.io/evm_part1.html

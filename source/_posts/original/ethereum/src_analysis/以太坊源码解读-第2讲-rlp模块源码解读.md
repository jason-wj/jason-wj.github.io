---
title: 以太坊源码解读-第2讲-rlp模块源码解读
mathjax: true
copyright: true
original: true
date: 2018-04-09 23:28:57
categories: [原创,以太坊,源码解读]
tags: [ethereum]
---
## 前言
在正式解读源码前，小编想先解释下为什么使用选择这一模块作为以太坊源码解读的开端：
1. 该模块可以独立于其余模块，且内容少，便于理解整体编码风格，找找感觉。
2. 不懂go语言的，读完这么模块，基本就没什么语言障碍了，话说，go语言是有点怪。。
<!-- more -->

## 什么是rlp
* rlp(递归长度前缀，Recursive Length Prefix)，是不是看的一脸懵逼？
* 序列化听说过不？java开发的同学们应该更了解吧？`rlp`就是以太坊中的序列化工具，它可以将其中涉及到的任何类型的数据都转化为字节序列，方便网络传输。
* 待序列化的数据需要`大端`化处理
* 以太坊的rlp主要分为：`对树形结构的数据序列化`以及`字节数组的序列化`。
* rlp适用于任意二进制数据数组的编码。

## 以太坊中rlp规则
黄皮书中，介绍到了以太坊的rlp规则，公式比较多，小编一个个来解释一下。
公式是从整体到细节的，希望大家能按顺序看，这样看更容易理解

### 公式中可能涉及到的符号解释
* ||x||表示公式的长度
* `这个点号符号$\cdot$表示的是字符串衔接，不是相乘`
* BE(x)表示x的`大端模式`,啥是大端模式小编不解释，基础概念，上百度谷歌一下～
* $\equiv$，恒等于，理解成等于姑且也可以。。。
* 剩下的符号，小编看了看，都是初中高中的，不要说不知道。。。

### 公式1：待序列化数据定义
要被序列化的数据类型，用数学定义如下：

$$
\begin{split}
&\mathbb{T} \equiv \mathbb{L} \cup \mathbb{B} \\\
&\mathbb{L} \equiv \\{t: t = (t[0], t[1], ...) \cap \forall_{n<||t||}\ t[n] \in \mathbb{T} \\} \\\
&\mathbb{B} \equiv \\{b: b = (b[0], b[1], ...) \cap \forall_{n<||b||}\ b[n] \in \mathbb{O} \\}
\end{split}
$$

解释的不一定合理，但大体是这么个意思:
* $\mathbb{T}$表示：待序列化数据中，*字节数组*以及*树形结构（树、结构体）*的数据。
* $\mathbb{L}$表示：$\mathbb{T}$之一的，不止一个节点的树形结构。
* $\mathbb{B}$表示：$\mathbb{T}$之一的，字节数组。
* $\mathbb{O}$表示：小编的理解是，包括待序列化数据以外的，任何字节数组。要知道最终序列化时，待序列化的数据是需要大端处理的。

### 公式2：序列化过程
以太坊序列化是如何执行的：

$$
RLP(x) \equiv
\begin{cases}
R_b(x), &\ if\ \ x \in \mathbb{B} \\\
R_l(x), &\ otherwise \\\
\end{cases}
$$

这个公式就好理解了吧，对于这两大类数据，执行不同的函数来处理序列化

### 公式3：$R_b(x)$字节数组的序列化规则

$$
R_b(x) \equiv
\begin{cases}
x, &if\ \ ||x||=1 \cap x[0]<128 \\\
(128+||x||) \cdot x, &else\ if\ \ ||x||<56 \\\
(183+||BE(||x||)||) \cdot BE(||x||)\cdot x, &otherwise
\end{cases}
$$

这公式的意思如下：
* 如果字节数组长度为1，且这个字节的值小于128，则不处理
* 如果不满足上一条要求，但是满足字节数组的长度小于56，那么就在原始数据前面加上`128与该字节数组长度之和`，该过程类似字符串衔接。
* 如果不满足以上两种条件，那么就先在原始数据前面加上`原始数据长度的大端表示的数据`，再在其前面加上`183与原始数据大端表示的长度之和`

### 公式4: $R_l(x)$树型结构数据的序列化规则

$$
\begin{split}
s(x) &\equiv RLP(x_0) \cdot RLP(x_1)...\\\
R_l(x) &\equiv
\begin{cases}
(192+||s(x)||) \cdot s(x), &if\ \ ||s(x)||<56 \\\
(247+||BE(||s(x)||)||) \cdot BE(||s(x)||) \cdot s(x), &otherwise \\\
\end{cases}
\end{split}
$$


第1个公式的意思如下：
* 将树形结构中的每个元素分别使用RLP进行处理，然后将处理结果依次连接起来（字符串连接），生成新的字节，表示为`s`。

第2个公式的意思如下：
* 如果公式1连接后的`s`字节长度小于56，那结果就是在`s`前面连接上`192与 *s的长度* 之和`
* 如果不满足上面的要求，也就是`s`字节长度大于等于56，则在s的前面连接上`s长度的大端表示`，再在其前面加上`247与*连接后长度的大端模式的长度*`

看懂上面的两个公式了不？看懂的话，你就会明白，这公式会是一个`递归过程`，因为结构体里还有结构体，一层又一层。。。

### 公式5: 标量数据处理(特殊数据)

$$
RLP(i:i \in \mathbb{P} ) \equiv RLP(BE(i))
$$
标量数据，可以理解为我们通常所说的基本的数据。
此时RLP只能用来处理正整数。这块理解貌似有点费劲，后面可以看看源码来进一步了解。这些数据需要先大端处理。

### 总结：
抛离公式，小编在此总结一下，RLP是如下处理数据的：
1. 如果是一个单字节(长度为1)并且其值在`[0x00,0x7f]`范围内（即0～127），RLP编码就是自身。
2. 如果一个数据串的字节长度是0-55字节，那么它的RLP编码是在数据串开头增加一个字节，这个字节的值是0x80加上数据串的字节长度。因此增加的该字节的取值范围为[0x80, 0xb7]。
3. 如果一个数据串的字节长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xb7加上数据串字节长度的二进制编码的字节长度，然后依次跟着数据串字节长度部分和内容部分。比如：一个长度为1024字节的数据串，其字节长度用16进制表示为0x0400，长度为2个字节，因此RLP编码头字节的值为0xb9（0xb7 + 0x02），然后跟着两字节为0x0400，后面再加上数据串的具体内容。因此增加的首字节的取值范围为[0xb8, 0xbf]，因此其能编码的最大数据长度为$2^56$
4. 如果是一个嵌套的列表数据，则需要先将列表中的数据按照单元素的编码规则进行RLP编码后串联得到列表数据的s。如果一个列表数据的s的字节长度为0-55，那么列表的RLP编码在其s前加上一个字节，这个字节的值是0xc0加上s的字节长度。因此首字节的取值范围为[0xc0, 0xf7]。
5. 如果一个列表数据的s的长度大于55，那么它的RLP编码是在开头增加一个字节，这个字节的值等于0xf7加上列表s字节长度的二进制编码的字节长度，然后依次跟着s字节长度部分和s部分。因此首字节的取值范围为[0xf8, 0xff]，因此一个列表中存储的所有元素的字节长度不能超过$2^56$。

## RLP源码解析
讲了一堆天书，终于到了关键地方了





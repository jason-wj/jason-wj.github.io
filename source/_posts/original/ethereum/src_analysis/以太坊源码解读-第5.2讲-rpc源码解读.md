---
title: 以太坊源码解读-第5.2讲-rpc源码解读
mathjax: false
copyright: true
original: true
date: 2018-05-03 14:04:01
categories: [原创,以太坊,源码解读]
tags: [ethereum]
---
## 前言
本文我们将分析rpc模块的源码，如果对rpc概念还不是很清楚的同学，建议先看看这篇文章[`以太坊源码解读-第5.1讲-rpc官翻及个人理解`](/articles/original/ethereum/src_analysis/以太坊源码解读-第5.1讲-rpc官翻及个人理解.html)
<!--more-->
先来看看该模块下有哪些文件：
.
|\_\_\_\_ipc_unix.go
|\_\_\_\_ipc_windows.go
|\_\_\_\_ipc.go
|\_\_\_\_http.go
|\_\_\_\_doc.go
|\_\_\_\_inproc.go
|\_\_\_\_utils.go
|\_\_\_\_websocket.go
|\_\_\_\_errors.go
|\_\_\_\_server.go
|\_\_\_\_server_test.go
|\_\_\_\_client.go
|\_\_\_\_client_example_test.go
|\_\_\_\_client_test.go
|\_\_\_\_subscription.go
|\_\_\_\_subscription_test.go
|\_\_\_\_utils_test.go
|\_\_\_\_http_test.go
|\_\_\_\_types.go
|\_\_\_\_types_test.go
|\_\_\_\_json.go
|\_\_\_\_json_test.go

文件很多，一眼看去真的很头大，小编借鉴[rpc源码分析-github](https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)中提供的一张图片先全局的介绍一下rpc模块中整体的文件结构，这样方便后面的理解：
{% asset_img 1.png  rpc模块文件结构 %}
图中`网络协议channels`和`Json`两部分，请其求和回应的编码和解码都是同时与服务端和客户端打交道的类。`网络协议channels`主要提供连接和数据传输的功能。 `json`的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。
另外需要知道，各种对外的服务都是被注册到server中的。

## server_test.go和server.go源码
小编结合着server_test.go文件来讲解一下server.go源码。

### 先来看看server_test.go
为了方便测试，server_test.go中定义了一个`Service`，这个`Service`用来被注册到server中，关于这个Service很有必要知道是如何定义的：
```go
type Service struct{}

type Args struct {
	S string
}

type Result struct {
	String string
	Int    int
	Args   *Args
}

func (s *Service) NoArgsRets() {}  //第1个有效的回调方法

func (s *Service) Echo(str string, i int, args *Args) Result { //第2个有效的回调方法
	return Result{str, i, args}
}

func (s *Service) EchoWithCtx(ctx context.Context, str string, i int, args *Args) Result {  //第3个有效的回调方法
	return Result{str, i, args}  
}

func (s *Service) Sleep(ctx context.Context, duration time.Duration) {  //第4个有效的回调方法
	select {
	case <-time.After(duration):
	case <-ctx.Done():
	}
}

func (s *Service) Rets() (string, error) { //第5个有效的回调方法
	return "", nil
}

func (s *Service) InvalidRets1() (error, string) { //无效的回调方法
	return nil, ""
}

func (s *Service) InvalidRets2() (string, string) { //无效的回调方法
	return "", ""
}

func (s *Service) InvalidRets3() (string, string, error) { //无效的回调方法
	return "", "", nil
}

func (s *Service) Subscription(ctx context.Context) (*Subscription, error) { //一个有效的订阅
	return nil, nil
}
```

根据[`以太坊源码解读-第5.1讲-rpc官翻及个人理解`](/articles/original/ethereum/src_analysis/以太坊源码解读-第5.1讲-rpc官翻及个人理解.html)中描述，我们知道上述代码中，`Service`对应的共有5个有效回调方法（也就是开放的方法），3个无效的回调方法，还有1个有效的订阅方法。我们通过下面的测试用例来验证：
```go
func TestServerRegisterName(t *testing.T) {
	server := NewServer()  //server新实例
	service := new(Service)  //具体某服务的实例
	if err := server.RegisterName("calc", service); err != nil //根据名称将某服务注册
		t.Fatalf("%v", err)
	if len(server.services) != 2  //是否有两个服务
		t.Fatalf("Expected 2 service entries, got %d", len(server.services))
	svc, ok := server.services["calc"]  //获取某服务
	if !ok 
		t.Fatalf("Expected service calc to be registered")
	if len(svc.callbacks) != 5 //是否有5个有效方法
		t.Errorf("Expected 5 callbacks for service 'calc', got %d", len(svc.callbacks))
	if len(svc.subscriptions) != 1  //是否有1个有效订阅方法
		t.Errorf("Expected 1 subscription for service 'calc', got %d", len(svc.subscriptions))
}
```

然后server_test.go中还有3个测试方法是用来测试`Service`中的每个方法是否正确，其中涉及到了rpc的方方面面。这几个测试方法小编就不列出来了，大家可以去看看，方法本身还是很容易理解的。




---
title: 以太坊源码解读-第5.2讲-rpc源码解读
mathjax: false
copyright: true
original: true
date: 2018-05-03 14:04:01
categories: [原创,以太坊,源码解读]
tags: [ethereum]
---
## 前言
本文我们将分析rpc模块的源码，如果对rpc概念还不是很清楚的同学，建议先看看这篇文章[`以太坊源码解读-第5.1讲-rpc官翻及个人理解`](/articles/original/ethereum/src_analysis/以太坊源码解读-第5.1讲-rpc官翻及个人理解.html)
<!--more-->
先来看看该模块下有哪些文件：
.
|\_\_\_\_ipc_unix.go
|\_\_\_\_ipc_windows.go
|\_\_\_\_ipc.go
|\_\_\_\_http.go
|\_\_\_\_doc.go
|\_\_\_\_inproc.go
|\_\_\_\_utils.go
|\_\_\_\_websocket.go
|\_\_\_\_errors.go
|\_\_\_\_server.go
|\_\_\_\_server_test.go
|\_\_\_\_client.go
|\_\_\_\_client_example_test.go
|\_\_\_\_client_test.go
|\_\_\_\_subscription.go
|\_\_\_\_subscription_test.go
|\_\_\_\_utils_test.go
|\_\_\_\_http_test.go
|\_\_\_\_types.go
|\_\_\_\_types_test.go
|\_\_\_\_json.go
|\_\_\_\_json_test.go

文件很多，一眼看去真的很头大，小编借鉴[rpc源码分析-github](https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/rpc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)中提供的一张图片先全局的介绍一下rpc模块中整体的文件结构，这样方便后面的理解：
{% asset_img 1.png  rpc模块文件结构 %}
图中`网络协议channels`和`Json`两部分，请其求和回应的编码和解码都是同时与服务端和客户端打交道的类。`网络协议channels`主要提供连接和数据传输的功能。 `json`的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。
另外需要知道，各种对外的服务都是被注册到server中的。
`ps`：要区分server和service的区别，server表示服务实体，service表示被注册到server中的一项服务

## types.go源码
要了解rpc，得先要了解rpc中对各大类的定义，因此我们很有必要先来看下这个文件。

### 对外开放的API定义
外部访问rpc的server进行通信是通过调用这个API来实现。
```go
type API struct {
	Namespace string      // 在该命名空间下，service的方法被公开
	Version   string      // 给dapp展示的api版本号
	Service   interface{} // 带有方法的service实例
	Public    bool        // 在公共使用中，指示方法是否为安全的
}
```

### service的定义
service定义了一个用来被注册到server中的服务，需要知道它内部结构是如何的：
```go
type service struct {
	name          string        // service的名称
	typ           reflect.Type  // 类型，反射的
	callbacks     callbacks     // 回调方法的集合
	subscriptions subscriptions // 订阅/发布集合
}
```
发现callbacks和subscriptions都是集合，它是如下定义的：
```go
type callbacks map[string]*callback      // 回调方法的集合，可以看出是一个map
type subscriptions map[string]*callback  // 订阅的集合，也可以看出是一个map
```
这两个集合都是map类型的，而它们个体本身其实就是一个callback，它的结构如下：
```go
type callback struct {
	rcvr        reflect.Value  // 反射出方法的值
	method      reflect.Method // 反射出方法本身
	argTypes    []reflect.Type // 输入的参数
	hasCtx      bool           // 检测第一个参数是否为context，
	errPos      int            // 返回错误的索引err，无法返回则为-1
	isSubscribe bool           // 该callback是否为订阅
}
```
可以看出，该callback主要就是使用反射来确定回调本身的。代码注释解释的可能不太好，大意上是那么一回事。。

### server的定义
上面说的service可以理解为一项服务，而server可以理解成是各种服务的容易，service最终是要被注册到server中的，而server的定义如下：
```go
type Server struct {
	services serviceRegistry  //用来存储service
	run      int32  //用来控制server运行还是停止，1为运行，非1为停止
	codecsMu sync.  //用来保护多线程访问codecs的锁
	codecs   *set.Set  //用来存储所有的编码解码器，其实就是所有的连接。
}
```
其中的services就是用来存储service集合的，可以看出它是通过serviceRegistry来定义的，而serviceRegistry本身是如下定义的：
```go
type serviceRegistry map[string]*service 
```
呵呵，这下知道了，service在server中是存在map中的

### ServerCodec的定义
server中的方法会用到这个东东，客户端发出的请求，对请求的处理，返回响应等过程，都是通过它来进行的。先来看看它的定义：
```go
type ServerCodec interface {
	ReadRequestHeaders() ([]rpcRequest, bool, Error)    //读取客户端发来的请求
	//根据给定的类型解析请求参数
	ParseRequestArguments(argTypes []reflect.Type, params interface{}) ([]reflect.Value, Error)
	CreateResponse(id interface{}, reply interface{}) interface{}  //response返回成功
	CreateErrorResponse(id interface{}, err Error) interface{}   //response返回失败
	//response返回失败，包括一些别的信息
	CreateErrorResponseWithInfo(id interface{}, err Error, info interface{}) interface{}
	CreateNotification(id, namespace string, event interface{}) interface{}  // 创建发布响应
	Write(msg interface{}) error  // 写信息到客户端
	Close()  // 关闭底层的数据流
	Closed() <-chan interface{}  // 当底层连接关闭后，则执行该接口方法
}
```
期间涉及到了两个比较重要的结构体：
* rpcRequest，它里面包含具体的请求信息：
```go
type rpcRequest struct {
	service  string
	method   string
	id       interface{}
	isPubSub bool
	params   interface{}
	err      Error // invalid batch element
}
```
* Error，错误信息结构：
```go
type Error interface {
	Error() string  // 返回错误信息
	ErrorCode() int // 返回错误代码
}
```

### BlockNumber的定义
这个就是块号的解析，根据输入的byte[]来判断返回的BlockNumber是多少。这个后面大家可以了解下。

## server.go和server_test.go源码
对上面的定义有了整体把握后，小编结合着server_test.go文件来讲解一下server.go源码。

### 先来看看server_test.go
为了方便测试，server_test.go中定义了一个`Service`，这个`Service`用来被注册到server中，关于这个Service很有必要知道是如何定义的：
```go
type Service struct{}

type Args struct {
	S string
}

type Result struct {
	String string
	Int    int
	Args   *Args
}

func (s *Service) NoArgsRets() {}  //第1个有效的回调方法

func (s *Service) Echo(str string, i int, args *Args) Result { //第2个有效的回调方法
	return Result{str, i, args}
}

func (s *Service) EchoWithCtx(ctx context.Context, str string, i int, args *Args) Result {  //第3个有效的回调方法
	return Result{str, i, args}  
}

func (s *Service) Sleep(ctx context.Context, duration time.Duration) {  //第4个有效的回调方法
	select {
	case <-time.After(duration):
	case <-ctx.Done():
	}
}

func (s *Service) Rets() (string, error) { //第5个有效的回调方法
	return "", nil
}

func (s *Service) InvalidRets1() (error, string) { //无效的回调方法
	return nil, ""
}

func (s *Service) InvalidRets2() (string, string) { //无效的回调方法
	return "", ""
}

func (s *Service) InvalidRets3() (string, string, error) { //无效的回调方法
	return "", "", nil
}

func (s *Service) Subscription(ctx context.Context) (*Subscription, error) { //一个有效的订阅
	return nil, nil
}
```

根据[`以太坊源码解读-第5.1讲-rpc官翻及个人理解`](/articles/original/ethereum/src_analysis/以太坊源码解读-第5.1讲-rpc官翻及个人理解.html)中描述，我们知道上述代码中，`Service`对应的共有5个有效回调方法（也就是开放的方法），3个无效的回调方法，还有1个有效的订阅方法。在server.services中，是有两个服务的，是不是很好奇，其实在NewServer()时候，就会有一个rpc服务被添加进去的，具体可以看小编后面的介绍。
需要知道，首字母为大写的方法名，被认为是对外开放的方法，不要问我为什么，后面代码里就是这么个逻辑。
我们通过下面的测试用例来验证有效还是无效：
```go
func TestServerRegisterName(t *testing.T) {
	server := NewServer()  //server新实例
	service := new(Service)  //具体某服务的实例
	if err := server.RegisterName("calc", service); err != nil //根据名称将某服务注册
		t.Fatalf("%v", err)
	if len(server.services) != 2  //是否有两个服务，其中一个是在NewServer)()时候添加的
		t.Fatalf("Expected 2 service entries, got %d", len(server.services))
	svc, ok := server.services["calc"]  //获取某服务
	if !ok 
		t.Fatalf("Expected service calc to be registered")
	if len(svc.callbacks) != 5 //是否有5个有效方法
		t.Errorf("Expected 5 callbacks for service 'calc', got %d", len(svc.callbacks))
	if len(svc.subscriptions) != 1  //是否有1个有效订阅方法
		t.Errorf("Expected 1 subscription for service 'calc', got %d", len(svc.subscriptions))
}
```

然后server_test.go中还有3个测试方法是用来测试`Service`中的每个方法是否正确，其中涉及到了rpc的方方面面。这几个测试方法小编就不列出来了，大家可以去看看，方法本身还是很容易理解的。

### server.go介绍
经过前面这么多的讲解，大家对rpc的server已经有了一些较为深刻的映像了吧？那我们就来看一下server.go中是如何实现server的。

#### 创建一个新server
需要先创建一个server，这样才能将service注册到该server中，具体是这样创建的，看代码：
```go
func NewServer() *Server {
	server := &Server{ //server先实例化
		services: make(serviceRegistry),  //开辟存储service的空间
		codecs:   set.New(),  //不解释，看前面
		run:      1,  //1,运行；非1不运行
	}

	//注册一个默认的rpc服务，该服务可以提供server的一些基本信息，具体看前面小编描述的
	rpcService := &RPCService{server}  //利用server生成一个rpcService，
	server.RegisterName(MetadataApi, rpcService) //MetadataApi=“rpc”
	return server
}
```
代码里，需要注意的是，初始化一个server，然后利用这个server生成一个rpcService，最后在用server把RPCService注册进去。
RPCService的目的是给出server中的一些基本参数信息，目前来说，貌似只能给出拥有的service名称和对应的版本号，而且都是1.0。。。
RPCService的定义以及它的方法如下：
```go
type RPCService struct {   //这个是RPCService的定义结构，很简单吧。。不解释
	server *Server  //可以看出，该server是指针引用进来的
}

func (s *RPCService) Modules() map[string]string {
	modules := make(map[string]string)
	for name := range s.server.services {
		modules[name] = "1.0"
	}
	return modules //其实只是返回每个service的名称和其版本号。。。
}
```
个人感觉，有点鸡肋额，，

#### server所拥有的方法
server.go文件中，剩下的内容都是server结构体所对应的方法，都比较重要，我们一个个来介绍

##### 注册服务
前面我们一直在用server.RegisterName()来注册一个服务，但这个服务具体是怎么来执行呢？来，上一坨代码你就知道了：
```go
func (s *Server) RegisterName(name string, rcvr interface{}) error {
	if s.services == nil {
		s.services = make(serviceRegistry)  //开辟存储service的空间
	}

	svc := new(service)
	svc.typ = reflect.TypeOf(rcvr)
	rcvrVal := reflect.ValueOf(rcvr)

	if name == "" {
		return fmt.Errorf("no service name for type %s", svc.typ.String())
	}
	if !isExported(reflect.Indirect(rcvrVal).Type().Name()) { //方法名中，首字母大写的被认为是对外开放的方法
		return fmt.Errorf("%s is not exported", reflect.Indirect(rcvrVal).Type().Name())
	}

	methods, subscriptions := suitableCallbacks(rcvrVal, svc.typ)  //将方法和订阅都反射解析出来

	// 若services中已经有了该service，则直接合并方法和订阅
	if regsvc, present := s.services[name]; present {
		if len(methods) == 0 && len(subscriptions) == 0 {
			return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
		}
		for _, m := range methods {
			regsvc.callbacks[formatName(m.method.Name)] = m
		}
		for _, s := range subscriptions {
			regsvc.subscriptions[formatName(s.method.Name)] = s
		}
		return nil
	}

	svc.name = name
	svc.callbacks, svc.subscriptions = methods, subscriptions

	if len(svc.callbacks) == 0 && len(svc.subscriptions) == 0 {
		return fmt.Errorf("Service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
	}

	s.services[svc.name] =   //根据名称存入服务
	return nil
}
```
可以发现：
* 方法或订阅如果是对外开放的，首先要满足其名称的首字母是大写
* 调用utils.go中的suitableCallbacks()方法，使用service反射后的结果来判断是属于对外开放的方法还是订阅
* 如果server中先前已经注册过该服务，则将新传入的service和该服务合并。

##### ServeCodec()方法，异步处理请求
先来看代码：
```go
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {
	defer codec.Close()
	s.serveRequest(codec, false, options) //具体实现后面再讲
}
```
参数codec中存储的是客户端发来的请求，经过处理后，会将响应结果写入codec中并返回给客户端。
该方法处理完codec中的内容后，会调用codec.Close()接口方法，处理请求结束时候的一些操作。
注意，看`s.serveRequest(codec, false, options)`，里面的`false`表示该方法是并发处理请求的

##### ServeSingleRequest()方法，同步处理请求
呵呵，这个方法和上面的那个方法刚好相反，是同步处理请求的，等处理结束后，整个过程才会结束。此结束不提供codec.Close()方法，不用想也该明白，同步结束了，后面该干嘛就干嘛。
代码就不列出来了，自己YY。

##### serveRequest()方法，具体处理客户端发来的请求
前面讲的两个方法，其实里面都是在调用这个方法的，这个也是我们服务器端的核心，下面小编就来好好探索一下。
在讲之前，小编建议大家好好了解下go语言中并发与并行的一些机制，也是为了更好的读懂这一部分代码，小编整理了下面几篇文章，希望大家先好好读读：

`此处暂停更新，待小编了解了go的并行机制后，再来更新`
--- 
草稿
serveRequset()方法用来处理codec中的请求内容，服务器使用codec读取请求，处理请求，再使用它返回请求给客户端。









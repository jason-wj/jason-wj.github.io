---
title: 官翻-第1篇-以太坊设计原理
mathjax: false
copyright: true
original: false
explain: 文中可能会根据需要做部分调整
top: false
notice: false
authorship: 月亮🌛
srcpath: https://ethfans.org/posts/510
categories:
  - 精品转载
  - 以太坊
  - 官翻
tags:
  - ethereum
abbrlink: 21e2b4a
date: 2018-05-20 22:26:54
---
## wj前言
区块链之路漫长而遥远，小编也是在一步步的探索着前进，近期发现自己有些急于求成，很多模块都想快速了解，反而模糊了自己的方向，使得自己对每个模块掌握并不扎实，这样浮躁的行为实在不是很好。
<!-- more -->
小编也曾说过，当迷茫的时候，就回出发点好好想想，经过一番思考，小编认为，如果真正想入了区块链这一行，真正想要了解以太坊，真得从头好好看看`设计原理`、`白皮书`、`黄皮书`了。
早期，小编也努力尝试着看过这些官方文档，或者是原先接触过早，里面很多内容晦涩难懂。
但相信经过这么长时间的区块链的洗礼，这次再阅读官方这些文档，应该会有很大收获。
小编会依次给出`设计原理`、`白皮书`、`黄皮书`这三部分中文内容。原本是想自己翻译的，但时间实在有限，能转载就只好转载了。`但是小编会根据英文原本给出一些新的解释的。`

`一定要记得，没有透彻了解顶层规划和设计，谈何源码实现？`
本文前半部分是wj小编自己翻译的。

---
原文链接：https://github.com/ethereum/wiki/wiki/Design-Rationale
尽管以太坊的很多技术和理念早先在比特币等已有加密货币中实现并运行了很久，但是还有很多具体的协议实现上是不一样的。一般情况下，以太坊会被作为新的经济模式，因为以太坊提供了很多别的区块链中不存在的理念。本文的主要目的是详细解释以太坊协议设计理念，以及其中涉及到的风险。

## 原则
以太坊协议的设计主要遵循以下几个原则：
1. **三明治复杂度模型（可以理解为分层模型不？）：**我们认为以太坊的底层设计要尽可能的简单，而且接口设计应当尽可能容易被理解（比如让使用高级编程语言的开发人员以及操作界面的普通用户能容易理解。对于一些不可避免的复杂模块（如高级语言编译器、参数序列化和反序列化、数据存储模型、`leveldb的接口和线路协议`等），需要将它加入到以太坊协议的“中间层”，该层次不属于核心部分，并且对终端用户是不可见的。当然，这一切并不是绝对的。
`wj备注: 线路协议，建议看看：https://en.wikipedia.org/wiki/Wire_protocol，了解下概念，小编或许用过，但真心没看懂。。。`
2. **自由：**我们不应该限制用户必须使用以太坊的协议，也不应该根据自身目的而倾向于支持或者不支持某些合约和交易。这个原则和“网络中立”背后的概念是类似的。举个例子，比特币的交易协议就没有遵循这一原则，它并不鼓励将区块链用于`非标签`的目的（如数据存储、元协议），比特币中若某个准协议被明显的修改了（例如OP_RETURN被限制在40字节内），会引起不法分子不满，并且进行一些未授权的攻击。
也因此在以太坊中，我们强烈建议设置交易费用，在奖励合法矿工的同时，也能让非法用户付出代价。
3. **泛化：**以太坊中的协议特征和操作码应该最大度的表现出低层级的概念，这样它们就能以任意方式组合，包括今天看起来可能不太有用，但可能以后会变得非常有用。剥离开不需要的功能，会使得低层次的概念更加高效。比如这样一个例子，我们选择了`LOG`操作码作为dapp的信息反馈（特别是轻客户端），而不是像之前建议的那样只是简简单单的记录所有的交易和消息--早先`消息`是多个概念合并起来的，包括“消息调用”和“外部观察者感兴趣的事件”，这两部分内容是完全值得分成两部分的。
4. **我们没有特点：**作为泛化的结果，我们通常拒绝将高层次的用例内嵌到协议中，不管该用例使用的有多频繁。如果人们真的很想使用这些用例，可以在合约中创建子协议（如基于以太坊的其它货币，或者侧链什么的）。比如在以太坊中就缺少比特币中“事件锁定”这个特征。但是这样一个特征可以通过该方式实现：用户发送“签名的数据包”到特定的合约中处理，如果该数据包在该合约中有效就可以运行对应的方法。
5. **无风险规避：**如果风险的增加能够提供可观的益处（比如：广义状态转换，50倍快速的阻塞时间，共识效率等），我们愿意承担更高的风险。

这些原则指导着以太坊的发展，但是这并不是绝对的；有些情况下为了减少开发时间或不愿意一次作出太多改变，即使这些改动会明显的有益，但我们推迟修改，把它留给未来的版本再修复。

## 区块链层协议
本文描述区块链层协议在以太坊中的变化，包括区块和交易是如何工作的，数据是怎样序列化和保存的，以及账户背后的机制。

## 这是账户，而不是UTXO①
比特币以及它的各种衍生品，将用户余额保存在`未花费的交易输出（UTXO）`这样一个结构中：系统的整个状态是由一系列的`未花费的输出（想象成一堆硬币）`，每个硬币都有自己的主人以及对应的价值，一次交易花费一个或者多个货币，并且创造一个或者多个新的硬币。这一切需要满足以下约束：
1. 每一个被引用的输入必须有效，并且没有被花费；
2. 交易的签名必须和每笔输入的拥有者的签名匹配；
3. 输入的总值必须等于或大于输出的总值。

因此，系统中用户的`余额`是指用户的私钥能够产生有效签名的所有UTXO的总值。就如下图所示：
{% asset_img 1.svg %}
以太坊抛弃了UTXO这种做法（估计是因为UTXI这种方案对于一般使用者并不容易操作和理解），而使用了这样一种简单的方法：使用状态存储一系列的账户，而每个账户拥有自己的余额以及以太坊自己特有的数据（代码和内部存储器）。如果交易发起方拥有足够的余额来支付该交易，则该交易将会被认为是有效的；然后发起方会被扣除相应的金额，而接受方会增加相应的金额。如果接受方拥有某些带代码，则交易后，该代码会被触发执行，同时内部存储器发生变化；或者该代码会创建额外的信息发送给别的账户，从而导致新的交易。

讲讲`UTXO`的优点（虽然以太坊没有用这结构，但不代表这个结构没有优点）：
1. **较高的隐私保护：**
如果用户为每笔收到的交易都使用一个新的地址，这样很难将每个地址都联系起来。这对货币很重要（高安全性），但对于一般的dapp来说就不太合适。因为dapp通常需要跟踪用户复杂的绑定状态，通常dapp中并不存在像货币系统那样简单划分的状态。
2. **潜在的可扩展模式：**
UTXO理论上的可扩展性更好，因为我们只能依赖货币拥有者来维护能够证明货币所有权的默克尔树，即使包括所有者在内的所有人都遗忘了某一数据，但真正受损的也只有该数据的拥有者。 但是在以太坊的账户理念中，如果某个账户在默克尔树中的信息被所有人都忘了，那么该账户将无法处理任何能够影响它的消息，包括发送给它的消息，它也无法处理。不过，并非只有UTXO能够可扩展，也存在不依赖UTXO就能扩展的方式（此处没有扩展开来讲，译者注）。

`账户`的好处有以下几点：
1. **节省大量空间**
如果一个账户有5个UTXO，则从UTXO模式转成账户模式所需空间会从300字节降到30字节。具体计算如下：
300 = (20+32+8）* 5 （20是地址字节数，32是TX的id字节数，8是交易金额值字节数）;
30 = 20 + 8 + 2 ( 20是地址字节数，8是交易金额值字节数，2是nonce②字节数)
但实际节约并没有这么大，因为账户需要被存储在帕特里夏树中。另外以太坊中交易也比比特币中的更小（以太坊中100字节，比特币中200-250字节），因为每次交易只需要生成一次引用，一次签名，以及一个输出。
2. **可替代性更高**
在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单/黑名单，并依据的这些“有效输出”的来源区分它们并不是很实际。
3. **简单**
以太坊编码更简单、更易于理解，尤其是在涉及到复杂脚本时。尽管任何去中心化应用都可以用UTXO方式来实现，但这种方式实质上是通过赋予一个脚本限制给定的UTXO能够使用以及请求的UTXO的种类的方式来实现，包括脚本评估的应用更改根状态的默克尔树证明。因此，UTXO实现方式比以太坊使用账户的方式要复杂的多。
4. **轻客户端**
轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了上文提到的UTXO根状态传播机制的dapp应用来说，无疑是繁重的。

我们认为，账户的好处大大超过了其他方式，尤其是对于我们正在处理的包含任意状态和代码的dapp应用而言。另外，本着“没有特点就是最大的特点”的指导原则，我们认为如果用户真的关心私密性，则可以通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。

账户方式的一个弱点是：为了阻止重播攻击，每笔交易必须有nonce，这就使得账户需要跟踪nonce的使用情况，并且只有在nonce最后使用后且值为1时才接受交易。这就意味着，即使不再使用的账户，也不能从账户状态中移除。解决这个问题的一个简单方法是让交易包含一个区块号，使它们在几个时间段内不重复，并且每个时间段重置nonce。由于完全扫描账户的开销太大，所以为了删除未使用的账户，矿工或用户需要通过“Ping”操作来实现。在1.0上我们没有实现这个机制，1.1及以上版本可能会使用这个机制。
`wj小编解释下重播攻击：是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。`

## Merkle Patricia Trees（MPT）
`wj小编备注：这块可以看看小编trie模块源码的解析，这块小编煞费苦心，解释的的很详细`
默克尔帕特里夏树(Merkle Patricia tree/trie),由Alan Reiner提出设想，并在瑞波协议中得到实现，是以太坊的主要数据结构，用于存储所有账户状态，以及每个区块中的交易和收据数据。MPT是[默克尔树](https://en.wikipedia.org/wiki/Merkle_tree)和[帕特里夏树](https://en.wikipedia.org/wiki/Radix_tree)的结合缩写，结合这两种树创建的结构具有以下属性：
1. 每个唯一键值对唯一映射到根的hash值；在MPT中，不可能仅用一个键值对来欺骗成员（除非攻击者有~2^128 的算力）；
2. 增、删、改键值对的时间复杂度是对数级别。

MPT为我们提供了一个高效、易更新、且代表整个状态树的“指纹”。
关于MPT更详细描述：https://github.com/ethereum/wiki/wiki/Patricia-Tree
MPT的具体设计决策如下：
1. **有两类节点**
KV节点和离散节点。KV节点的存在提高了效率，因为如果在特定区域树是稀疏的，KV节点可作为一个“快捷方式”，代替深度为64的树。
2. **离散节点是16进制，不是二进制**
这样让查找更有效率，我们现在认识到这种选择并不理想，因为16进制树的查找效率在二进制中可以通过批次存储节点来模拟。MPT树的结构实现是非常容易出错的，最终至少会造成状态根不匹配。
3. **空值(empty value)与非会员(non-membership)之间没有区别**
这样做是为了简化逻辑，以太坊中未设置的值默认为0，空字符串也用0表示。然而，需要强调的是，这样做牺牲了一些通用性，因而也不是最优的。
4. **终节点和非终节点的区别**
技术上，标识一个节点“是否是终节点”是没必要的，因为以太坊中所有的树都被用于存储静态秘钥长度，但为了增加通用性，我们还是会添加这个标识，以期望以太坊的MPT的实现方式能够被其他加密货币原样采纳。
5. **在安全树中采用SHA3(k)作为秘钥（在状态树和账户存储树中使用）**
使用SHA3(k)，通过设置离散节点的链的深度为64，以及反复调用SLOAD 和 SSTORE指令，使那些企图对树采取Dos攻击的行为变得非常困难。不过，这也让穷举树的节点变得困难，如果你希望你的客户端有穷举的能力，最简单的方法是维持一个数据库映射：sha3(k) -> k
`wj小编ps：在1.8.3版本中，这种安全树并未被使用，还在测试中`

## RLP
`wj小编ps：RLP模块源码小编解析过，有兴趣的可以参考下`
RLP(recursive length prefix)：递归长度前缀。
RLP编码是以太坊中主要的序列化格式，它的使用无处不在：区块、交易、账户状态以及线路协议消息。详见RLP正式描述： https://github.com/ethereum/wiki/wiki/RLP

RLP旨在成为高度简化的序列化格式，它唯一的目的是存储`嵌套数组③`。不同于protobuf、BSON等现有的解决方案，RLP并不定义任何指定的数据类型，如Boolean、floa、double或者integer。它仅仅是以嵌套数组的形式存储结构，并将其留给协议来确定数组的含义。RLP也没有明确支持map集合，半官方的建议是采用 [[k1, v1], [k2, v2], ...] 的嵌套数组来表示键值对集合，k1,k2 ... 按照字符串的标准排序。

与RLP具有相同功能的方案是protobuf或BSON，它们是一直被使用的算法。然而，以太坊中，我们更偏向于使用RLP，因为：
1. 它易于实现；
2. 绝对保证字节的一致性。

许多语言的Map集合没有明确的排序，并且浮点格式有很多特殊情况，这可能造成相同数据却导致不同编码和hash值。通过内部开发协议，我们能确保它是带着这些目标设计的（这是一般原则，也适用于代码的其他部分，如VM）。BitTorrent使用的编码方式bencode也许可以替代RLP。不过它采用的是十进制的编码方式，与采用二进制的RLP相比，稍微逊色了点。
`wj小编ps：这里一定要明白，为什么选择rlp`

## 压缩算法
线路协议和数据库都采用了一个自定义的压缩算法来存储数据。该算法可描述为：行程编码④值为0并同时保留其他值（除了一些特殊情况如sha3(' ') ），举例如下：
```text
>>> compress('horse')
'horse'
>>> compress('donkey dragon 1231231243')
'donkey dragon 1231231243'
>>> compress('\xf8\xaf\xf8\xab\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbe{b\xd5\xcd\x8d\x87\x97')
'\xf8\xaf\xf8\xab\xa0\xfe\x9e\xbe{b\xd5\xcd\x8d\x87\x97'
>>> compress("\xc5\xd2F\x01\x86\xf7#<\x92~}\xb2\xdc\xc7\x03\xc0\xe5\x00\xb6S\xca\x82';{\xfa\xd8\x04]\x85\xa4p")
'\xfe\x01'
```
压缩算法存在之前，以太坊协议的许多地方都有一些特殊情况，例如，sha3经常被覆盖，所以sha3(' ')=' '，这样不需要在账户中存储代码，可以节省64字节。然而，最近所有这些使得以太坊数据结构变得臃肿的特殊情况都被删除了，取而代之的是将数据保存函数添加到区块链协议之外的层，也就是将其放入线路协议以及将其插入用户数据库实现。这样增加了模块化能力，简化了共识层，使得压缩算法能持续更新以便相对容易部署。

## 树（trie）的使用
以太坊区块链中每个区块头都包含指向三个树的指针：`状态树`、`交易树`、`收据树`。
* 状态树代表访问区块后的整个状态；
* 交易树代表区块中所有交易，这些交易由index索引作为key；（例如，k0:第一个执行的交易，k1：第二个执行的交易）
* 收据树代表每笔交易相应的收据。交易的收据是一个RLP编码的数据结构：
```text
[ medstate, gas_used, logbloom, logs ]
```

	其中：
	* medstate：交易处理后，树的根的状态；
	* gas_used：交易处理后，gas的使用量；
	* logs：是表格[address, [topic1, topic2...], data]元素的列表。表格由交易执行期间调用的操作码LOG0 ... LOG4 生成（包含主调用和子调用）；address 是生成日志的合约的地址topics是最多4个32字节的值；data 是任意字节大小的数组；
	* logbloom：交易中所有logs的address和topic组成的布隆过滤器⑤。

区块头中也存在一个布隆过滤器，它是区块中交易的所有布隆过滤器的逻辑或组成。这样的构造使得以太坊协议[轻客户端](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)的使用尽可能的友好。

## Uncle块（过时区块）的奖励
2013年10月，由乔森纳和特拉维夫首次提出的GHOST协议是一项了不起的革新。它是加快生成区块时间的第一个认真尝试。因为区块在网络中传播需要一定时间，如果矿工A挖到一个区块并向全网广播，在广播的路上，B也挖出了区块，那么B的区块是过时的，且B的本次挖矿对网络的安全没有贡献。GHOST的目的正是要解决挖矿过时造成的安全性降低的问题。

根据乔森纳和特拉维夫的描述，GHOST解决了在计算哪个链是最长的链的过程中，因产生过时区块而造成的网络安全性下降的问题。也就是说，不仅是父区块和更早的区块,同时Uncle区块⑥也被添加到计算哪个块具有最大的工作量证明中去。

为了解决第二个问题：中心化问题，我们采用不同的策略：对过时区块也提供区块奖励：挖到过时区块的奖励是该区块基础奖励的7/8；挖到包含过时区块的nephew（外甥，可理解为过时区块的子块）区块将收到1/32的基础奖励作为赏金。但是，交易费并不奖励给Uncle区块或nephew区块。

在以太坊，过时分叉上7代内的亲属区块才能称作过时区块。之所以这样限制是因为，首先，GHOST协议若不限制过时区块数量，将会花费大量开销在计算过时区块的有效性上；其次，无限制的过时区块激励政策会让矿工失去在主链上挖矿的热情；最后，计算表明，过时区块奖励政策限制在7层内提供了大部分所需的效果，而且不会带来负面效应。

区块时间算法的设计决策包括:
* **区块时间12s：**选择12s是因为这已经是最快的时间了，基本上比网络延迟更长。在2013年的一份关于测量比特币网络延迟的论文中，确定了12.6秒是新产生的区块传播到95%节点的时间；然而，该论文还指出传播时间与区块大小成比例，因此在更快的货币中，我们可以期待传播时间大大减少。传播间隔时间是恒定的，约为2秒。然而，为了安全起见，在我们的分析中，我们假定区块的传播需要12秒。
* **7个祖先块的限制：**这样设计的目的是希望只保留少量区块，而将更早之前的区块清除。已经证明7个区块可以提供大部分所需的效果。
* **1个后裔区块的限制：**如c(c(p(p(p(head))))) c=child, p = parent,就不合法，因为它有两个后裔区块。这样设计的目的是为了简单，上面的模拟结果显示它并没有构成大的中心化风险。
* **uncle块要求具有有效性：**uncle块必须是有效的header，而不是有效的区块。这样做也是为了简化，将区块链模型保持为线性数据结构。不过，要求uncle块是有效的区块也是合法的方法。
* **奖金分配：**7/8的挖矿基础奖励分配给uncle块，1/32分给nephew块，它们交易费用都是0%。如果费用占多数，从中心化的角度看，这会使uncle块激励机制无效；然而，这也是为什么只要我们继续使用PoW，以太坊就会不断发行以太币的原因。

## 难度更新算法
目前以太坊通过以下规则进行难度更新：
```text
diff(genesis) = 2^32
diff(block) = diff.block.parent + floor(diff.block.parent / 1024) *
    1 if block.timestamp - block.parent.timestamp < 9 else
    -1 if block.timestamp - block.parent.timestamp >= 9
```
难度更新规则的设计目标如下：
* 快速更新：区块间的时间应该随着hash算力的增减而快速调整；
* 低波动性：如果Hash算力恒定，那么难度不应剧烈波动；
* 简单：算法的实现应相对简单；
* 低内存：算法不应依赖于过多的历史区块，要尽可能少的使用”内存变量“。假设有最新的十个区块，将存储在这十个区块头部的内存变量相加，这些区块都可用于算法的计算；
* 非开发性：算法不应让矿工有过多篡改时间戳或者矿池、反复添加或删除算力的能力，以使他们的收益最大化。

我们当前的算法在低波动性和非开发性上并不理想，至少我们计划切换时间戳比较父区块和祖父区块，所以矿工只有在连续挖2个区块时，才有动力去修改时间戳。另一个更强大的模拟公式： https://github.com/ethereum/economic-modeling/blob/master/diffadjust/blkdiff.py

## Gas和费用
比特币中所有交易大体相同，因此它们的网络成本可以建成一个模型。以太坊中的交易要更复杂，所以交易费用需要考虑到账户的许多方面，包括宽带费用，存储费用和计算费用。尤其重要的是，以太坊编程语言是图灵完备的，所以交易会使用任意数量的宽带、存储和计算成本。这就可能会导致在计算成本过程中，突遭停电而计算被迫中止。
### 以太坊交易费用的基本机制如下：
* 每笔交易必须指明一定数量的gas（即指定startgas的值），以及支付每单元gas所需费用（即gasprice），在交易执行开始时，startgas * gasprice 价值的以太币会从发送者账户中扣除；
* 交易执行期间的所有操作，包括读写数据库、发送消息以及每一步的计算都会消耗一定数量的gas；
* 如果交易执行完毕，消耗的gas值小于指定的限制值，则交易执行正常，并将剩余的gas值赋予变量gas_rem ; 在交易完成后，发送者会收到返回的gas_rem \* gasprice 价值的以太币，而给矿工的奖励是（startgas - gas_rem）\* gasprice价值的以太币；
* 如果交易执行中，gas消耗殆尽，则所有的执行恢复原样，但交易仍然有效，只是交易的唯一结果是将 startgas \* gasprice 价值的以太币支付给矿工，其他不变；
* 当一个合约发送消息给另一个合约，可以对这个消息引起的子执行设置一个gas限制。如果子执行耗尽了gas，则子执行恢复原样，但gas仍然消耗。

### 上述提到的几点都是必须满足的，例如：
* 如果交易没有指定gas限制，那么恶意用户就会发送一个有数十亿步循环的交易。没有人能够处理这样的交易，因为处理这样的交易花的时间可能很长很长，从而无法预先告知网络上的矿工，这会导致拒绝服务的漏洞产生。
* 替代严格的gas计数、时间限制等机制的方案不起作用，因为它们太主观了
* startgas \* gasprice 的整个值，在开始时就应该设置好，这样不至于在交易执行中因gas不够而造成交易终止。注意，仅仅检查账户余额是不够的，因为账户可以在其他地方发送余额。
* 如果在gas不够的情况下，交易执行没有恢复操作（回滚），合约必须采用强有力的安全措施来防止合约发生变化。
* 如果子限制不存在，则恶意账户会通过与其他账户达成协议来对它们采取拒绝服务攻击。在计算开始时插入一个大循环，那么发送消息给受害合约或者受害合约的任何补救尝试，都会使整个交易死锁。
* 要求交易发送者而不是合约来支付gas，这样大大增加了开发人员的可操作性。以太坊早期的版本是由合约来支付gas的，这导致了一个相当严重的问题：每个合约必须实现“守护”代码，确保每个传入的消息有足够的以太币供其消耗。

### gas消耗计算有以下特点：
* 对于任何交易，都将收取21000gas的基本费用。这些费用可用于支付运行椭圆曲线算法所需的费用。该算法旨在从签名中恢复发送者的地址以及存储交易所花费的硬盘和带宽空间。
* 交易可以包括无限量的“数据”。虚拟机中的某些操作码，可以让合约允许交易对这些数据的访问。数据的固定消耗计算是：每个零字节4gas，非零字节68gas。这个公式的产生是因为合约中大部分的交易数据由一些列的32字节的参数组成，其中多数参数具有许多前导零字节。该结构看起来似乎效率不高，但由于压缩算法的存在，实际上还是很有效率的。我们希望此结构能够代替其他更复杂的机制：这些机制根据预期字节数严格包装参数，从而导致编译阶段复杂性大增。这是三明治复杂模型的一个例外，但由于成本效益比，这也是合理的模型。
* 用于设置账户存储器的操作码SSTORE的消耗是：1.将零值改为非零值时，消耗20000gas；2.将零值变成零值，或非零值变非零值，消耗5000gas；3.将非零值变成零值，消耗5000gas，加上交易执行成功后退回的15000gas。退款金额上限是交易消耗gas总额的50%。这样设置会激励人们清除存储器。我们注意到，正因为缺乏这样的激励，许多合约造成了存储空间没有被有效使用，从而导致了存储快速膨胀；为存储收取费用提供了很多好处，同时不会失去合约一旦确立就可以永久存在的保证。延迟退款机制是必要的，因为可以阻止拒绝服务攻击。攻击者发送一笔含有少量gas的交易，循环清除大量的存储，直到用光gas，这样消耗了大量的验证算力，但实际并没有真正清除存储或消耗大量gas。50%的上限的是为了确保获得了一定交易gas的旷工依然能够确定执行交易的计算时间的上限。
`wj小编ps：这段小编没看懂。。。`
* 合约提供的消息的数据是没有成本的。因为在消息调用期间不需要实质复制任何数据，调用数据可以简单地视为指向父合约内存的指针，该指针在子进程执行时不会改变。
* 内存是一个可以无限扩展的数组，然而，每扩展32字节的内存就会消耗1gas的成本，不足32字节以32字节计。
* 某些操作码的计算时间极度依赖参数，gas开销计算是动态变化的。例如，EXP的的开销是指数级别的；复制操作码（如：CALLDATACOPY, CODECOPY, EXTCODECOPY）的开销是1+1(每复制32字节)。内存扩展的开销不包含在这里，因为它触发了二次攻击。
*  如果值不是零，操作码CALL会额外消耗9000gas。这是因为任何值传输都会引起归档节点的历史存储显著增大。请注意，实际消耗是6700，在此基础上，我们强制增加了一个自动给予接受者的gas值，这个值最小2300。这样做是为了让接受交易的钱包至少有足够的gas来记录交易。

gas机制的另一个重要部分是gas价格本身体现出的经济学原理。比特币中，默认的方法是采取纯粹自愿的收费方式，矿工扮演守门人的角色并且动态设置收费的最小值。以太坊中允许交易发送者设置任意数目的gas。这种方式在比特币社区非常受欢迎，因为它是“市场经济”的体现：允许矿工和交易者之间依据供需关系来决定价格。然而，这种方式的问题是，交易处理并不遵循市场原则。尽管可以将交易处理看作是矿工向发送者提供的服务（这听起来很直观），但实际上矿工所处理的每个交易都必须由网络中的每个节点处理，所以交易处理的大部分成本都由第三方机构承担，而不是决定是否处理它的矿工。

当前，因为缺乏矿工在实际中的行为的明确信息，所以我们将采取一个非常简单公平的方法：投票系统，来设定gas限定值。矿工有权将当前区块的gas限定值设定在最后区块的gas限定值的0.0975% (1/1024)内。所以最终的gas限定值应该是矿工们设置的中间值。我们希望将来能够采用软分叉的方法来使用更加精确的算法。

### 虚拟机

---
## 注释：
① UTXO: unspent transaction outputs。字面理解是：有效的交易输出，它是比特币协议中用于存储交易信息的数据结构。
② Nonce，Number used once或Number once的缩写，在密码学中Nonce是一个只被使用一次的任意或非重复的随机数值，在加密技术中的初始向量和加密散列函数都发挥着重要作用，在各类验证协议的通信应用中确保验证信息不被重复使用以对抗重放攻击(Replay Attack)。
③ 嵌套数组：创建一个数组，并使用其他数组填充该数组。如数组pets：
var cats : String[] = ["Cat","Beansprout", "Pumpkin", "Max"];
var dogs : String[] = ["Dog","Oly","Sib"];
var pets : String[][] = [cats, dogs];
④ 行程编码(run-length-encoding):一种统计编码。主要技术是检测重复的比特或字符序列，并用它们的出现次数取而代之。（百度百科）
⑤ 布隆过滤器：由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。（百度百科）
⑥ uncle：A挖出区块后广播途中，B也挖出了区块（过时区块），此时区块链会出现分叉。过时分叉上的区块就叫uncle区块。它不是这个块的父区块，父区块的兄弟区块（平级关系）。



`剩余内容下次更新`


---
title: 官翻-第1篇-以太坊设计原理
mathjax: false
copyright: true
original: false
explain: 文中可能会根据需要做部分调整
top: false
notice: false
authorship: 月亮🌛
srcpath: https://ethfans.org/posts/510
categories:
  - 精品转载
  - 以太坊
  - 官翻
tags:
  - ethereum
abbrlink: 21e2b4a
date: 2018-05-20 22:26:54
---
## wj前言
区块链之路漫长而遥远，小编也是在一步步的探索着前进，近期发现自己有些急于求成，很多模块都想快速了解，反而模糊了自己的方向，使得自己对每个模块掌握并不扎实，这样浮躁的行为实在不是很好。
<!-- more -->
小编也曾说过，当迷茫的时候，就回出发点好好想想，经过一番思考，小编认为，如果真正想入了区块链这一行，真正想要了解以太坊，真得从头好好看看`设计原理`、`白皮书`、`黄皮书`了。
早期，小编也努力尝试着看过这些官方文档，或者是原先接触过早，里面很多内容晦涩难懂。
但相信经过这么长时间的区块链的洗礼，这次再阅读官方这些文档，应该会有很大收获。
小编会依次给出`设计原理`、`白皮书`、`黄皮书`这三部分中文内容。原本是想自己翻译的，但时间实在有限，能转载就只好转载了。`但是小编会根据英文原本给出一些新的解释的。`

`一定要记得，没有透彻了解顶层规划和设计，谈何源码实现？`
本文前半部分是wj小编自己翻译的。

---
原文链接：https://github.com/ethereum/wiki/wiki/Design-Rationale
尽管以太坊的很多技术和理念早先在比特币等已有加密货币中实现并运行了很久，但是还有很多具体的协议实现上是不一样的。一般情况下，以太坊会被作为新的经济模式，因为以太坊提供了很多别的区块链中不存在的理念。本文的主要目的是详细解释以太坊协议设计理念，以及其中涉及到的风险。

## 原则
以太坊协议的设计主要遵循以下几个原则：
1. **三明治复杂度模型（可以理解为分层模型不？）：**我们认为以太坊的底层设计要尽可能的简单，而且接口设计应当尽可能容易被理解（比如让使用高级编程语言的开发人员以及操作界面的普通用户能容易理解。对于一些不可避免的复杂模块（如高级语言编译器、参数序列化和反序列化、数据存储模型、`leveldb的接口和线路协议`等），需要将它加入到以太坊协议的“中间层”，该层次不属于核心部分，并且对终端用户是不可见的。当然，这一切并不是绝对的。
`wj备注: 线路协议，建议看看：https://en.wikipedia.org/wiki/Wire_protocol，了解下概念，小编或许用过，但真心没看懂。。。`
2. **自由：**我们不应该限制用户必须使用以太坊的协议，也不应该根据自身目的而倾向于支持或者不支持某些合约和交易。这个原则和“网络中立”背后的概念是类似的。举个例子，比特币的交易协议就没有遵循这一原则，它并不鼓励将区块链用于`非标签`的目的（如数据存储、元协议），比特币中若某个准协议被明显的修改了（例如OP_RETURN被限制在40字节内），会引起不法分子不满，并且进行一些未授权的攻击。
也因此在以太坊中，我们强烈建议设置交易费用，在奖励合法矿工的同时，也能让非法用户付出代价。
3. **泛化：**以太坊中的协议特征和操作码应该最大度的表现出低层级的概念，这样它们就能以任意方式组合，包括今天看起来可能不太有用，但可能以后会变得非常有用。剥离开不需要的功能，会使得低层次的概念更加高效。比如这样一个例子，我们选择了`LOG`操作码作为dapp的信息反馈（特别是轻客户端），而不是像之前建议的那样只是简简单单的记录所有的交易和消息--早先`消息`是多个概念合并起来的，包括“消息调用”和“外部观察者感兴趣的事件”，这两部分内容是完全值得分成两部分的。
4. **我们没有特点：**作为泛化的结果，我们通常拒绝将高层次的用例内嵌到协议中，不管该用例使用的有多频繁。如果人们真的很想使用这些用例，可以在合约中创建子协议（如基于以太坊的其它货币，或者侧链什么的）。比如在以太坊中就缺少比特币中“事件锁定”这个特征。但是这样一个特征可以通过该方式实现：用户发送“签名的数据包”到特定的合约中处理，如果该数据包在该合约中有效就可以运行对应的方法。
5. **无风险规避：**如果风险的增加能够提供可观的益处（比如：广义状态转换，50倍快速的阻塞时间，共识效率等），我们愿意承担更高的风险。

这些原则指导着以太坊的发展，但是这并不是绝对的；有些情况下为了减少开发时间或不愿意一次作出太多改变，即使这些改动会明显的有益，但我们推迟修改，把它留给未来的版本再修复。

## 区块链层协议
本文描述区块链层协议在以太坊中的变化，包括区块和交易是如何工作的，数据是怎样序列化和保存的，以及账户背后的机制。

## 这是账户，而不是UTXO
比特币以及它的各种衍生品，将用户余额报存在`未花费的交易输出（UTXO）`这样一个结构中：系统的整个状态是由一系列的`未花费的输出（想象成一堆硬币）`，每个硬币都有自己的主人以及对应的价值，一次交易花费一个或者多个货币，并且创造一个或者多个新的硬币。这一切需要满足以下约束：
1. 每一个被引用的输入必须有效，并且没有被花费；
2. 交易的签名必须和每笔输入的拥有者的签名匹配；
3. 输入的总值必须等于或大于输出的总值。

因此，系统中用户的`余额`是指用户的私钥能够产生有效签名的所有UTXO的总值。就如下图所示：
{% asset_img 1.svg %}
以太坊抛弃了UTXO这种做法（估计是因为UTXI这种方案对于一般使用者并不容易操作和理解），而使用了这样一种简单的方法：使用状态存储一系列的账户，而每个账户拥有自己的余额以及以太坊自己特有的数据（代码和内部存储器）。如果交易发起方拥有足够的余额来支付该交易，则该交易将会被认为是有效的；然后发起方会被扣除相应的金额，而接受放会增加相应的金额。如果接受方拥有某些带代码，则交易后，该代码会被触发执行，同时内部存储器发生变化；或者该代码会创建额外的信息发送给别的账户，从而导致新的交易。

讲讲`UTXO`的优点（虽然以太坊没有用这结构，但不代表这个结构没有优点）：
1. **较高的隐私保护：**
如果用户为每笔收到的交易都使用一个新的地址，这样很难将每个地址都联系起来。这对货币很重要（高安全性），但对于一般的dapp来说就不太合适。因为通常dapp中并不存在像货币系统那样简单划分的状态。
2. **潜在的可扩展模式：**
UTXO理论上的可扩展性更好，因为我们只能依赖货币拥有者来维护能够证明货币所有权的默克尔树，即使包括所有者在内的所有人都遗忘了某一数据，但真正受损的也只有该数据的拥有者。 但是在以太坊的账户理念中，如果某个账户在默克尔树中的信息被所有人都忘了，那么该账户将无法处理任何能够影响它的消息，包括发送给它的消息，它也无法处理。不过，并非只有UTXO能够可扩展，也存在不依赖UTXO就能扩展的方式（此处没有扩展开来讲，译者注）。

`账户`的好处有以下几点：
1. **节省大量空间**
如果一个账户有5个UTXO，则从UTXO模式转成账户模式所需空间会从300字节降到30字节。具体计算如下：
300 = (20+32+8）* 5 （20是地址字节数，32是TX的id字节数，8是交易金额值字节数）;
30 = 20 + 8 + 2 ( 20是地址字节数，8是交易金额值字节数，2是nonce②字节数)
但实际节约并没有这么大，因为账户需要被存储在帕特里夏树中。另外以太坊中交易也比比特币中的更小（以太坊中100字节，比特币中200-250字节），因为每次交易只需要生成一次引用，一次签名，以及一个输出。
2. **可替代性更高**
在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单/
3. **简单**
以太坊编码更简单、更易于理解，尤其是在涉及到复杂脚本时。尽管任何去中心化应用都可以用UTXO方式来实现，但这种方式实质上是通过赋予一个脚本限制给定的UTXO能够使用以及请求的UTXO的种类的方式来实现，包括脚本评估的应用更改根状态的默克尔树证明。因此，UTXO实现方式比以太坊使用账户的方式要复杂的多。
4. **轻客户端**
轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了上文提到的UTXO根状态传播机制的dapp应用来说，无疑是繁重的。

我们认为，账户的好处大大超过了其他方式，尤其是对于我们正在处理的包含任意状态和代码的dapp应用而言。另外，本着“没有特点就是最大的特点”的指导原则，我们认为如果用户真的关心私密性，则可以通过合约中的签名数据包协议来建立一个加密“混合器”进行加密。

账户方式的一个弱点是：为了阻止重播攻击，每笔交易必须有nonce，这就使得账户需要跟踪nonce的使用情况，并且只有在nonce最后使用后且值为1时才接受交易。这就意味着，即使不再使用的账户，也不能从账户状态中移除。解决这个问题的一个简单方法是让交易包含一个区块号，使它们在几个时间段内不重复，并且每个时间段重置nonce。由于完全扫描账户的开销太大，所以为了删除未使用的账户，矿工或用户需要通过“Ping”操作来实现。在1.0上我们没有实现这个机制，1.1及以上版本可能会使用这个机制。
`wj小编解释下重播攻击：是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。`

## Merkle Patricia Trees（MPT）
`wj小编备注：这块可以看看小编trie模块源码的解析，这块小编煞费苦心，解释的的很详细`
默克尔帕特里夏树(Merkle Patricia tree/trie),由Alan Reiner提出设想，并在瑞波协议中得到实现，是以太坊的主要数据结构，用于存储所有账户状态，以及每个区块中的交易和收据数据。MPT是[默克尔树](https://en.wikipedia.org/wiki/Merkle_tree)和[帕特里夏树](https://en.wikipedia.org/wiki/Radix_tree)的结合缩写，结合这两种树创建的结构具有以下属性：
1. 每个唯一键值对唯一映射到根的hash值；在MPT中，不可能仅用一个键值对来欺骗成员（除非攻击者有~2^128 的算力）；
2. 增、删、改键值对的时间复杂度是对数级别。

MPT为我们提供了一个高效、易更新、且代表整个状态树的“指纹”。
关于MPT更详细描述：https://github.com/ethereum/wiki/wiki/Patricia-Tree
MPT的具体设计决策如下：
1. **有两类节点**
KV节点和离散节点。KV节点的存在提高了效率，因为如果在特定区域树是稀疏的，KV节点可作为一个“快捷方式”，代替深度为64的树。
2. **离散节点是16进制，不是二进制**
这样让查找更有效率，我们现在认识到这种选择并不理想，因为16进制树的查找效率在二进制中可以通过批次存储节点来模拟。MPT树的结构实现是非常容易出错的，最终至少会造成状态根不匹配。
3. **空值(empty value)与非会员(non-membership)之间没有区别**
这样做是为了简化逻辑，以太坊中未设置的值默认为0，空字符串也用0表示。然而，需要强调的是，这样做牺牲了一些通用性，因而也不是最优的。
4. **终节点和非终节点的区别**
技术上，标识一个节点“是否是终节点”是没必要的，因为以太坊中所有的树都被用于存储静态秘钥长度，但为了增加通用性，我们还是会添加这个标识，以期望以太坊的MPT的实现方式能够被其他加密货币原样采纳。
5. **在安全树中采用SHA3(k)作为秘钥（在状态树和账户存储树中使用）**
使用SHA3(k)，通过设置离散节点的链的深度为64，以及反复调用SLOAD 和 SSTORE指令，使那些企图对树采取Dos攻击的行为变得非常困难。不过，这也让穷举树的节点变得困难，如果你希望你的客户端有穷举的能力，最简单的方法是维持一个数据库映射：sha3(k) -> k
`wj小编ps：在1.8.3版本中，这种安全树并未被使用，还在测试中`

## RLP
RLP(recursive length prefix)：递归长度前缀。
RLP编码是以太坊中主要的序列化格式，它的使用无处不在：区块、交易、账户状态以及线路协议消息。详见RLP正式描述： https://github.com/ethereum/wiki/wiki/RLP

